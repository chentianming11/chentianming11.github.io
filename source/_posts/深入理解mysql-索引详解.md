---
title: 深入理解mysql-索引详解
tags: mysql
categories: 数据库
abbrlink: 2462378631
date: 2020-06-14 17:54:50
---

通过上一章节的学习，我们已经知道了**数据页内各个记录是按主键正序排列并组成了一个单向链表的，并且各个数据页之间形成了双向链表**。在数据页内，通过`页目录`，根据主键可以快速定位到一条记录。这一章中，我们深入理解一下mysql索引实现。

<!--more-->

## 索引

先回顾一下上一章节中`数据页基本结构`：
![数据页基本结构](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd1b8eafbb4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
从上图可以推断出，查询某条记录关键步骤只有2个：

1. 定位到数据页
2. 定位到记录

如果没有索引，查询某条记录只能先依次遍历数据页，确定记录所在的数据页；然后再从数据页中通过`页目录`定位到具体的记录，这样做效率肯定是极其低下的。

为了方便说明，先建一张示例表：

```sql
mysql> CREATE TABLE index_demo(
    ->     c1 INT,
    ->     c2 INT,
    ->     c3 CHAR(1),
    ->     PRIMARY KEY(c1)
    -> ) ROW_FORMAT = Compact;
Query OK, 0 rows affected (0.03 sec)
```

为了展示便方便，行格式中只展示`record_type`、`next_record`和`实际各列的值`。
![行格式简化](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd1b0cad198?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
把一些记录放到页里边的示意图就是：
![记录放到页里边的示意图](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd1be0d43ce?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

上面提到过，**数据页中的记录是按主键正序排列的**。实际上就是为了能够使用**二分查找法**快速定位一条记录。同理，要想快速定位一个数据页，也得保证各个数据页是按顺序排序的。**后一个数据页的最小主键必须大于当前数据页的最大主键**。这样实际上就保证了，所有记录的主键都是正序排列的了。

### 页分裂

假设每个数据页最多只能存放3条记录。现在`index_demo`插入了3条记录 `(1, 4, 'u'), (3, 9, 'd'), (5, 3, 'y')`。
![页分裂](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd1b5a6e2af?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
然后，再向`index_demo`插入一条记录`(4, 4, 'a')`。由于每个数据页最多只能存放3条记录，并且还要保证所有记录主键是按主键正序排列的。mysql会新建一个页面(假设是页28)，然后将主键值为5的记录移动到页28中，最后再把主键值为4的记录插入到页10中。
![页分裂](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2641f1c47?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
简单来说，**当向一个已经存满记录的数据页插入新记录时，mysql会以新插入记录的位置为界，把当前页面分裂为2个页面，最后再将新记录插入进去**。

### mysql索引实现

假设`index_demo`已经存在多条记录，数据页结构如下所示：
![索引实现](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd27e1f3cf3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
为了能够使用`二分法`快速查找，可以给每个数据页建一个目录项，每个目录项主要包含两部分数据：

1. 页的用户记录中最小的主键值，我们用`key`来表示。
2. 页号，我们用`page_no`表示。

![索引实现](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd282d6b9b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
在mysql中，这些目录项其实就是另一类型的数据记录，称为`目录项数据记录`（record_type=1）,`目录项数据记录`也是存储在`页`中的，同一页中的`目录项数据记录`也可以通过`页目录`快速定位。
![索引实现](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd295fd42b5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

虽然`目录项记录`基本**只存储了主键值和页号**。但是当表中的数据很多时，一个`数据页`肯定是无法保存所有的`目录项记录`的。因此`目录项记录`的`数据页`实际上也可能有很多个。
![索引实现](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd29ebc7a4c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
这个时候，我们就需要快速定位存储`目录项记录`的`数据页`了。实际上，我们只需要生成**更高级的目录即可**，保证最高一级的`目录项记录`的`数据页`只有一个。这样就能根据主键从上到下快速定位到一条记录了。
![索引实现](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2a6c7a65f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

实际上，上面就形成了一个B+树。**实际用户记录其实都存放在B+树的叶子节点上，而非叶子节点存放的是目录项**。

#### 聚簇索引

上面介绍的索引实际上就是聚簇索引，它有两个特点：

1. 使用主键值的大小进行记录和页的排序，这包括三个方面的含义：
   1. 页内的记录是按照主键的大小顺序排成一个单向链表。
   2. 各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。
   3. 存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。
2. B+树的叶子节点存储的是完整的用户记录。

InnoDB存储引擎会自动根据主键创建聚簇索引。同时，聚簇索引就是InnoDB存储引擎中数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的**索引即数据，数据即索引**。

#### 二级索引

在实际场景中，我们更多的是为某个列建立二级索引。实际上，二级索引和聚簇索引实现的原理一样的。主要的区别只有3个：

1. 目录项记录存放的数据是`索引列数据`和页号。
2. 叶子节点数据页存放记录是`索引列数据`和对应的主键。
3. 排序规则是按照`索引列数据`大小排序的。

如图是以`c2`列建立的二级索引：
![二级索引](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2a89adfa5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

由于叶子节点只存储了`索引列数据`和对应的`主键`。如果我们要查询完成记录的话，只能拿到主键之后，再到`聚簇索引`中查出用户记录，这个过程也叫`回表`。

#### 联合索引

在实际场景中，经常也出现为多个列建立一个索引的情况，这种索引也称为`联合索引`。`联合索引`本质上也是二级索引，区别仅仅在于由一个列变为多个列而已。同时以多个列的大小作为排序规则，也就是同时为多个列建立索引。比如我们为`c2`和`c3`列建立联合索引：

1. 先把各个记录和页按照c2列进行排序。
2. 在记录的c2列相同的情况下，采用c3列进行排序。

![联合索引](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2b0b70d72?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## InnoDB的B+树索引的注意事项

### 根节点不变性

上面介绍B+树的时候，为了理解方便，采用自下而上的方式介绍。实际上，B+树的形成过程如下：

1. 每次为某个表创建`B+`索引的时候，都会为这个索引创建一个根节点页面。当表中没有记录时，每个B+根节点既没有用户记录，也没有目录项记录。
2. 随后向表中插入用户记录时，先把用户记录存储到根节点中。
3. 当根节点空间用完后，再次插入数据。会将根节点数据复制到一个新页中，再对这个新页进行`页分裂`操作。此时，根节点自动升级为存储目录项记录的页。

可以看出，**一个B+树索引的根节点自诞生之日起，便不会再移动**。

### 内节点中目录项记录的唯一性

我们知道B+树索引的内节点中目录项记录的内容是索引列 + 页号的搭配，但是这个搭配对于二级索引来说有点儿不严谨。为了保证内节点目录项记录的唯一性，目录项还需要存储主键值数据。也就是说，目录项记录的内容包含`索引列的值`、`主键值`和`页号`。
![内节点中目录项记录的唯一性](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2c92fbca0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

## MyISAM中的索引方案简单介绍

我们知道**InnoDB中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了**，而MyISAM的索引方案虽然也使用树形结构，但是却将**索引和数据分开存储**：

- `MyISAM存储引擎`把记录按照记录的插入顺序单独存储在`数据文件`中。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。
  ![数据文件](https://user-gold-cdn.xitu.io/2019/4/9/16a01bd2d0c5ad53?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)
- `MyISAM存储引擎`会把索引信息另外存储到`索引文件`中。`MyISAM`会单独为表的主键创建一个索引，只不过在**索引的叶子节点中存储的不是完整的用户记录，而是主键值+行号的组合**。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！
  这一点和`InnoDB`是完全不相同的，在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录。而在MyISAM中却需要进行一次回表操作，意味着**MyISAM中建立的索引相当于全部都是二级索引**！
- 如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和InnoDB中的索引差不多，不过在叶子节点处存储的是相应的列+行号。这些索引也全部都是二级索引。

