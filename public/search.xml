<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Validation最佳实践及其实现原理，参数校验没那么简单！</title>
    <url>/posts/3181057117/</url>
    <content><![CDATA[<p>之前也写过一篇关于<code>Spring Validation</code>使用的文章，不过自我感觉还是浮于表面，本次打算彻底搞懂<code>Spring Validation</code>。本文会详细介绍<code>Spring Validation</code>各种场景下的最佳实践及其实现原理，死磕到底！<br>项目源码：<a href="https://github.com/chentianming11/spring-validation" target="_blank" rel="noopener">spring-validation</a></p>
<a id="more"></a>

<h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><p><code>Java API</code>规范(<code>JSR303</code>)定义了<code>Bean</code>校验的标准<code>validation-api</code>，但没有提供实现。<code>hibernate validation</code>是对这个规范的实现，并增加了校验注解如<code>@Email</code>、<code>@Length</code>等。<code>Spring Validation</code>是对<code>hibernate validation</code>的二次封装，用于支持<code>spring mvc</code>参数自动校验。接下来，我们以<code>spring-boot</code>项目为例，介绍<code>Spring Validation</code>的使用。</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><p>如果<code>spring-boot</code>版本小于<code>2.3.x</code>，<code>spring-boot-starter-web</code>会自动传入<code>hibernate-validator</code>依赖。如果<code>spring-boot</code>版本大于<code>2.3.x</code>，则需要手动引入依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.hibernate<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>hibernate-validator<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>6.0.1.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于<code>web</code>服务来说，为防止非法参数对业务造成影响，在<code>Controller</code>层一定要做参数校验的！大部分情况下，请求参数分为如下两种形式：</p>
<ol>
<li><code>POST</code>、<code>PUT</code>请求，使用<code>requestBody</code>传递参数；</li>
<li><code>GET</code>请求，使用<code>requestParam/PathVariable</code>传递参数。</li>
</ol>
<p>下面我们简单介绍下<code>requestBody</code>和<code>requestParam/PathVariable</code>的参数校验实战！</p>
<h3 id="requestBody参数校验"><a href="#requestBody参数校验" class="headerlink" title="requestBody参数校验"></a><code>requestBody</code>参数校验</h3><p><code>POST</code>、<code>PUT</code>请求一般会使用<code>requestBody</code>传递参数，这种情况下，后端使用<strong>DTO对象</strong>进行接收。<strong>只要给DTO对象加上<code>@Validated</code>注解就能实现自动参数校验</strong>。比如，有一个保存<code>User</code>的接口，要求<code>userName</code>长度是<code>2-10</code>，<code>account</code>和<code>password</code>字段长度是<code>6-20</code>。如果校验失败，会抛出<code>MethodArgumentNotValidException</code>异常，<code>Spring</code>默认会将其转为<code>400（Bad Request）</code>请求。</p>
<blockquote>
<p><strong>DTO表示数据传输对象（Data Transfer Object），用于服务器和客户端之间交互传输使用的</strong>。在spring-web项目中可以表示用于接收请求参数的<code>Bean</code>对象。</p>
</blockquote>
<ul>
<li><strong>在<code>DTO</code>字段上声明约束注解</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">2</span>, max = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">6</span>, max = <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">private</span> String account;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Length</span>(min = <span class="number">6</span>, max = <span class="number">20</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>在方法参数上声明校验注解</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveUser</span><span class="params">(@RequestBody @Validated UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这种情况下，<strong>使用<code>@Valid</code>和<code>@Validated</code>都可以</strong>。</p>
</blockquote>
<h3 id="requestParam-PathVariable参数校验"><a href="#requestParam-PathVariable参数校验" class="headerlink" title="requestParam/PathVariable参数校验"></a><code>requestParam/PathVariable</code>参数校验</h3><p><code>GET</code>请求一般会使用<code>requestParam/PathVariable</code>传参。如果参数比较多(比如超过6个)，还是推荐使用<code>DTO</code>对象接收。否则，推荐将一个个参数平铺到方法入参中。在这种情况下，<strong>必须在<code>Controller</code>类上标注<code>@Validated</code>注解，并在入参上声明约束注解(如<code>@Min</code>等)</strong>。如果校验失败，会抛出<code>ConstraintViolationException</code>异常。代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/user"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 路径变量</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"&#123;userId&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">detail</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> @<span class="title">Min</span><span class="params">(<span class="number">10000000000000000</span>L)</span> Long userId) </span>&#123;</span><br><span class="line">        <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">        UserDTO userDTO = <span class="keyword">new</span> UserDTO();</span><br><span class="line">        userDTO.setUserId(userId);</span><br><span class="line">        userDTO.setAccount(<span class="string">"11111111111111111"</span>);</span><br><span class="line">        userDTO.setUserName(<span class="string">"xixi"</span>);</span><br><span class="line">        userDTO.setAccount(<span class="string">"11111111111111111"</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询参数</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"getByAccount"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">getByAccount</span><span class="params">(@Length(min = <span class="number">6</span>, max = <span class="number">20</span>)</span> @NotNull String  account) </span>&#123;</span><br><span class="line">        <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">        UserDTO userDTO = <span class="keyword">new</span> UserDTO();</span><br><span class="line">        userDTO.setUserId(<span class="number">10000000000000003L</span>);</span><br><span class="line">        userDTO.setAccount(account);</span><br><span class="line">        userDTO.setUserName(<span class="string">"xixi"</span>);</span><br><span class="line">        userDTO.setAccount(<span class="string">"11111111111111111"</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(userDTO);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><p>前面说过，如果校验失败，会抛出<code>MethodArgumentNotValidException</code>或者<code>ConstraintViolationException</code>异常。在实际项目开发中，通常会用<strong>统一异常处理</strong>来返回一个更友好的提示。比如我们系统要求无论发送什么异常，<code>http</code>的状态码必须返回<code>200</code>，由业务码去区分系统的异常情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Result</span> <span class="title">handleMethodArgumentNotValidException</span>(<span class="title">MethodArgumentNotValidException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        BindingResult bindingResult = ex.getBindingResult();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="string">"校验失败:"</span>);</span><br><span class="line">        <span class="keyword">for</span> (FieldError fieldError : bindingResult.getFieldErrors()) &#123;</span><br><span class="line">            sb.append(fieldError.getField()).append(<span class="string">"："</span>).append(fieldError.getDefaultMessage()).append(<span class="string">", "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String msg = sb.toString();</span><br><span class="line">       <span class="keyword">return</span> Result.fail(BusinessCode.参数校验失败, msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(&#123;ConstraintViolationException<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Result</span> <span class="title">handleConstraintViolationException</span>(<span class="title">ConstraintViolationException</span> <span class="title">ex</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Result.fail(BusinessCode.参数校验失败, ex.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="进阶使用"><a href="#进阶使用" class="headerlink" title="进阶使用"></a>进阶使用</h2><h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>在实际项目中，可能多个方法需要使用同一个<code>DTO</code>类来接收参数，而不同方法的校验规则很可能是不一样的。这个时候，简单地在<code>DTO</code>类的字段上加约束注解无法解决这个问题。因此，<code>spring-validation</code>支持了<strong>分组校验</strong>的功能，专门用来解决这类问题。还是上面的例子，比如保存<code>User</code>的时候，<code>UserId</code>是可空的，但是更新<code>User</code>的时候，<code>UserId</code>的值必须<code>&gt;=10000000000000000L</code>；其它字段的校验规则在两种情况下一样。这个时候使用<strong>分组校验</strong>的代码示例如下：</p>
<ul>
<li><strong>约束注解上声明适用的分组信息<code>groups</code></strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">10000000000000000L</span>, groups = Update<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Long</span> <span class="title">userId</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">Length</span>(<span class="title">min</span> </span>= <span class="number">2</span>, max = <span class="number">10</span>, groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">userName</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">Length</span>(<span class="title">min</span> </span>= <span class="number">6</span>, max = <span class="number">20</span>, groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">account</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">Length</span>(<span class="title">min</span> </span>= <span class="number">6</span>, max = <span class="number">20</span>, groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">password</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Save</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Update</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong><code>@Validated</code>注解上指定校验分组</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/save"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveUser</span><span class="params">(@RequestBody @Validated(UserDTO.Save.class)</span> UserDTO userDTO) </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/update"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">updateUser</span><span class="params">(@RequestBody @Validated(UserDTO.Update.class)</span> UserDTO userDTO) </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="嵌套校验"><a href="#嵌套校验" class="headerlink" title="嵌套校验"></a>嵌套校验</h3><p>前面的示例中，<code>DTO</code>类里面的字段都是<code>基本数据类型</code>和<code>String</code>类型。但是实际场景中，有可能某个字段也是一个对象，这种情况先，可以使用<code>嵌套校验</code>。比如，上面保存<code>User</code>信息的时候同时还带有<code>Job</code>信息。需要注意的是，<strong>此时<code>DTO</code>类的对应字段必须标记<code>@Valid</code>注解</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Min</span>(value = <span class="number">10000000000000000L</span>, groups = Update<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Long</span> <span class="title">userId</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">Length</span>(<span class="title">min</span> </span>= <span class="number">2</span>, max = <span class="number">10</span>, groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">userName</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">Length</span>(<span class="title">min</span> </span>= <span class="number">6</span>, max = <span class="number">20</span>, groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">account</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">Length</span>(<span class="title">min</span> </span>= <span class="number">6</span>, max = <span class="number">20</span>, groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">password</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    @<span class="title">Valid</span></span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">Job</span> <span class="title">job</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Min</span>(value = <span class="number">1</span>, groups = Update<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">private</span> <span class="title">Long</span> <span class="title">jobId</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span>(groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">        @<span class="title">Length</span>(<span class="title">min</span> </span>= <span class="number">2</span>, max = <span class="number">10</span>, groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">        <span class="title">private</span> <span class="title">String</span> <span class="title">jobName</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@NotNull</span>(groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">        @<span class="title">Length</span>(<span class="title">min</span> </span>= <span class="number">2</span>, max = <span class="number">10</span>, groups = &#123;Save<span class="class">.<span class="keyword">class</span>, <span class="title">Update</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">        <span class="title">private</span> <span class="title">String</span> <span class="title">position</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 保存的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Save</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新的时候校验分组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Update</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>嵌套校验可以结合分组校验一起使用。还有就是<code>嵌套集合校验</code>会对集合里面的每一项都进行校验，例如<code>List&lt;Job&gt;</code>字段会对这个<code>list</code>里面的每一个<code>Job</code>对象都进行校验。</p>
</blockquote>
<h3 id="集合校验"><a href="#集合校验" class="headerlink" title="集合校验"></a>集合校验</h3><p>如果请求体直接传递了<code>json</code>数组给后台，并希望对数组中的每一项都进行参数校验。此时，如果我们直接使用<code>java.util.Collection</code>下的<code>list</code>或者<code>set</code>来接收数据，参数校验并不会生效！我们可以使用自定义<code>list</code>集合来接收参数：</p>
<ul>
<li><strong>包装<code>List</code>类型，并声明<code>@Valid</code>注解</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidationList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Delegate</span> <span class="comment">// @Delegate是lombok注解</span></span><br><span class="line">    <span class="meta">@Valid</span> <span class="comment">// 一定要加@Valid注解</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一定要记得重写toString方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>@Delegate</code>注解受<code>lombok</code>版本限制，<code>1.18.6</code>以上版本可支持。如果校验不通过，会抛出<code>NotReadablePropertyException</code>，同样可以使用统一异常进行处理。</p>
</blockquote>
<p>比如，我们需要一次性保存多个<code>User</code>对象，<code>Controller</code>层的方法可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/saveList"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveList</span><span class="params">(@RequestBody @Validated(UserDTO.Save.class)</span> ValidationList&lt;UserDTO&gt; userList) </span>&#123;</span><br><span class="line">    <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义校验"><a href="#自定义校验" class="headerlink" title="自定义校验"></a>自定义校验</h3><p>业务需求总是比框架提供的这些简单校验要复杂的多，我们可以自定义校验来满足我们的需求。自定义<code>spring validation</code>非常简单，假设我们自定义<code>加密id</code>（由数字或者<code>a-f</code>的字母组成，<code>32-256</code>长度）校验，主要分为两步：</p>
<ul>
<li><strong>自定义约束注解</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validatedBy = &#123;EncryptIdValidator<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EncryptId</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认错误消息</span></span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "加密id格式错误"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分组</span></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负载</span></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>实现<code>ConstraintValidator</code>接口编写约束校验器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncryptIdValidator</span> <span class="keyword">implements</span> <span class="title">ConstraintValidator</span>&lt;<span class="title">EncryptId</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern PATTERN = Pattern.compile(<span class="string">"^[a-f\\d]&#123;32,256&#125;$"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String value, ConstraintValidatorContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 不为null才进行校验</span></span><br><span class="line">        <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Matcher matcher = PATTERN.matcher(value);</span><br><span class="line">            <span class="keyword">return</span> matcher.find();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就可以使用<code>@EncryptId</code>进行参数校验了！</p>
<h3 id="编程式校验"><a href="#编程式校验" class="headerlink" title="编程式校验"></a>编程式校验</h3><p>上面的示例都是基于<code>注解</code>来实现自动校验的，在某些情况下，我们可能希望以<code>编程方式</code>调用验证。这个时候可以注入<code>javax.validation.Validator</code>对象，然后再调用其<code>api</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> javax.validation.Validator globalValidator;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编程式校验</span></span><br><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/saveWithCodingValidate"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Result <span class="title">saveWithCodingValidate</span><span class="params">(@RequestBody UserDTO userDTO)</span> </span>&#123;</span><br><span class="line">    Set&lt;ConstraintViolation&lt;UserDTO&gt;&gt; validate = globalValidator.validate(userDTO, UserDTO.Save<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">// 如果校验通过，validate为空；否则，validate包含未校验通过项</span></span><br><span class="line">    <span class="keyword">if</span> (validate.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 校验通过，才会执行业务逻辑处理</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (ConstraintViolation&lt;UserDTO&gt; userDTOConstraintViolation : validate) &#123;</span><br><span class="line">            <span class="comment">// 校验失败，做其它逻辑</span></span><br><span class="line">            System.out.println(userDTOConstraintViolation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Result.ok();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快速失败-Fail-Fast"><a href="#快速失败-Fail-Fast" class="headerlink" title="快速失败(Fail Fast)"></a>快速失败(Fail Fast)</h3><p><code>Spring Validation</code>默认会校验完所有字段，然后才抛出异常。可以通过一些简单的配置，开启<code>Fali Fast</code>模式，一旦校验失败就立即返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Validator <span class="title">validator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValidatorFactory validatorFactory = Validation.byProvider(HibernateValidator<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">configure</span>()</span></span><br><span class="line"><span class="class">            // 快速失败模式</span></span><br><span class="line"><span class="class">            .<span class="title">failFast</span>(<span class="title">true</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">buildValidatorFactory</span>()</span>;</span><br><span class="line">    <span class="keyword">return</span> validatorFactory.getValidator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Valid和-Validated区别"><a href="#Valid和-Validated区别" class="headerlink" title="@Valid和@Validated区别"></a><code>@Valid</code>和<code>@Validated</code>区别</h3><table>
<thead>
<tr>
<th>区别</th>
<th>@Valid</th>
<th>@Validated</th>
</tr>
</thead>
<tbody><tr>
<td>提供者</td>
<td>JSR-303规范</td>
<td>Spring</td>
</tr>
<tr>
<td>是否支持分组</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>标注位置</td>
<td>METHOD, FIELD, CONSTRUCTOR, PARAMETER, TYPE_USE</td>
<td>TYPE, METHOD, PARAMETER</td>
</tr>
<tr>
<td>嵌套校验</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h3 id="requestBody参数校验实现原理"><a href="#requestBody参数校验实现原理" class="headerlink" title="requestBody参数校验实现原理"></a><code>requestBody</code>参数校验实现原理</h3><p>在<code>spring-mvc</code>中，<code>RequestResponseBodyMethodProcessor</code>是用于解析<code>@RequestBody</code>标注的参数以及处理<code>@ResponseBody</code>标注方法的返回值的。显然，执行参数校验的逻辑肯定就在解析参数的方法<code>resolveArgument()</code>中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestResponseBodyMethodProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractMessageConverterMethodProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">resolveArgument</span><span class="params">(MethodParameter parameter, @Nullable ModelAndViewContainer mavContainer,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  NativeWebRequest webRequest, @Nullable WebDataBinderFactory binderFactory)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        parameter = parameter.nestedIfOptional();</span><br><span class="line">        <span class="comment">//将请求数据封装到DTO对象中</span></span><br><span class="line">        Object arg = readWithMessageConverters(webRequest, parameter, parameter.getNestedGenericParameterType());</span><br><span class="line">        String name = Conventions.getVariableNameForParameter(parameter);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (binderFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            WebDataBinder binder = binderFactory.createBinder(webRequest, arg, name);</span><br><span class="line">            <span class="keyword">if</span> (arg != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 执行数据校验</span></span><br><span class="line">                validateIfApplicable(binder, parameter);</span><br><span class="line">                <span class="keyword">if</span> (binder.getBindingResult().hasErrors() &amp;&amp; isBindExceptionRequired(binder, parameter)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> MethodArgumentNotValidException(parameter, binder.getBindingResult());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mavContainer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mavContainer.addAttribute(BindingResult.MODEL_KEY_PREFIX + name, binder.getBindingResult());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> adaptArgumentIfNecessary(arg, parameter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>resolveArgument()</code>调用了<code>validateIfApplicable()</code>进行参数校验。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">validateIfApplicable</span><span class="params">(WebDataBinder binder, MethodParameter parameter)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取参数注解，比如@RequestBody、@Valid、@Validated</span></span><br><span class="line">    Annotation[] annotations = parameter.getParameterAnnotations();</span><br><span class="line">    <span class="keyword">for</span> (Annotation ann : annotations) &#123;</span><br><span class="line">        <span class="comment">// 先尝试获取@Validated注解</span></span><br><span class="line">        Validated validatedAnn = AnnotationUtils.getAnnotation(ann, Validated<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//如果直接标注了@Validated，那么直接开启校验。</span></span><br><span class="line">        <span class="comment">//如果没有，那么判断参数前是否有Valid起头的注解。</span></span><br><span class="line">        <span class="keyword">if</span> (validatedAnn != <span class="keyword">null</span> || ann.annotationType().getSimpleName().startsWith(<span class="string">"Valid"</span>)) &#123;</span><br><span class="line">            Object hints = (validatedAnn != <span class="keyword">null</span> ? validatedAnn.value() : AnnotationUtils.getValue(ann));</span><br><span class="line">            Object[] validationHints = (hints <span class="keyword">instanceof</span> Object[] ? (Object[]) hints : <span class="keyword">new</span> Object[] &#123;hints&#125;);</span><br><span class="line">            <span class="comment">//执行校验</span></span><br><span class="line">            binder.validate(validationHints);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这里，大家应该能明白为什么这种场景下<code>@Validated</code>、<code>@Valid</code>两个注解可以混用。我们接下来继续看<code>WebDataBinder.validate()</code>实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validate</span><span class="params">(Object target, Errors errors, Object... validationHints)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.targetValidator != <span class="keyword">null</span>) &#123;</span><br><span class="line">        processConstraintViolations(</span><br><span class="line">            <span class="comment">//此处调用Hibernate Validator执行真正的校验</span></span><br><span class="line">            <span class="keyword">this</span>.targetValidator.validate(target, asValidationGroups(validationHints)), errors);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终发现底层最终还是调用了<code>Hibernate Validator</code>进行真正的校验处理。</p>
<h3 id="方法级别的参数校验实现原理"><a href="#方法级别的参数校验实现原理" class="headerlink" title="方法级别的参数校验实现原理"></a>方法级别的参数校验实现原理</h3><p>上面提到的将参数一个个平铺到方法参数中，然后在每个参数前面声明<code>约束注解</code>的校验方式，就是方法级别的参数校验。实际上，这种方式可用于任何<code>Spring Bean</code>的方法上，比如<code>Controller</code>/<code>Service</code>等。<strong>其底层实现原理就是<code>AOP</code>，具体来说是通过<code>MethodValidationPostProcessor</code>动态注册<code>AOP</code>切面，然后使用<code>MethodValidationInterceptor</code>对切点方法织入增强</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodValidationPostProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractBeanFactoryAwareAdvisingPostProcessorimplements</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//为所有`@Validated`标注的Bean创建切面</span></span><br><span class="line">        Pointcut pointcut = <span class="keyword">new</span> AnnotationMatchingPointcut(<span class="keyword">this</span>.validatedAnnotationType, <span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//创建Advisor进行增强</span></span><br><span class="line">        <span class="keyword">this</span>.advisor = <span class="keyword">new</span> DefaultPointcutAdvisor(pointcut, createMethodValidationAdvice(<span class="keyword">this</span>.validator));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Advice，本质就是一个方法拦截器</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Advice <span class="title">createMethodValidationAdvice</span><span class="params">(@Nullable Validator validator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (validator != <span class="keyword">null</span> ? <span class="keyword">new</span> MethodValidationInterceptor(validator) : <span class="keyword">new</span> MethodValidationInterceptor());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接着看一下<code>MethodValidationInterceptor</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodValidationInterceptor</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(MethodInvocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//无需增强的方法，直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (isFactoryBeanMetadataMethod(invocation.getMethod())) &#123;</span><br><span class="line">            <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取分组信息</span></span><br><span class="line">        Class&lt;?&gt;[] groups = determineValidationGroups(invocation);</span><br><span class="line">        ExecutableValidator execVal = <span class="keyword">this</span>.validator.forExecutables();</span><br><span class="line">        Method methodToValidate = invocation.getMethod();</span><br><span class="line">        Set&lt;ConstraintViolation&lt;Object&gt;&gt; result;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//方法入参校验，最终还是委托给Hibernate Validator来校验</span></span><br><span class="line">            result = execVal.validateParameters(</span><br><span class="line">                invocation.getThis(), methodToValidate, invocation.getArguments(), groups);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有异常直接抛出</span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConstraintViolationException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//真正的方法调用</span></span><br><span class="line">        Object returnValue = invocation.proceed();</span><br><span class="line">        <span class="comment">//对返回值做校验，最终还是委托给Hibernate Validator来校验</span></span><br><span class="line">        result = execVal.validateReturnValue(invocation.getThis(), methodToValidate, returnValue, groups);</span><br><span class="line">        <span class="comment">//有异常直接抛出</span></span><br><span class="line">        <span class="keyword">if</span> (!result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConstraintViolationException(result);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实际上，不管是<code>requestBody参数校验</code>还是<code>方法级别的校验</code>，最终都是调用<code>Hibernate Validator</code>执行校验，<code>Spring Validation</code>只是做了一层封装</strong>。</p>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql执行计划Explain详解，再也不用怕sql优化了！</title>
    <url>/posts/2001481941/</url>
    <content><![CDATA[<p>大家都知道，mysql在执行查询的时候会进行查询优化。简单来讲就是执行的时候先<strong>基于成本和规则优化</strong>生成<strong>执行计划</strong>，然后再按照执行计划执行查询。本文主要介绍<code>EXPLAIN</code>各输出项的含义，从而帮助大家更好的进行<strong>sql性能优化</strong>！</p>
<a id="more"></a>

<blockquote>
<p>本文主要内容是根据掘金小册《从根儿上理解 MySQL》整理而来。如想详细了解，建议购买掘金小册阅读。</p>
</blockquote>
<p>我们可以在查询语句前面加上<code>EXPLAIN</code>关键字来查看这个查询的<strong>执行计划</strong>。例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT 1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra          |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">|  1 | SIMPLE      | NULL  | NULL       | NULL | NULL          | NULL | NULL    | NULL | NULL |     NULL | No tables used |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，执行计划包含很多输出列，我们先简单过一下各列的大致作用，后面再进行详细讲解。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>在一个大的查询语句中每个<code>SELECT</code>关键字都对应一个唯一的id</td>
</tr>
<tr>
<td>select_type</td>
<td><code>SELECT</code>关键字对应的那个查询的类型</td>
</tr>
<tr>
<td>table</td>
<td>表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区信息</td>
</tr>
<tr>
<td>type</td>
<td>针对单表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际上使用的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>实际使用到的索引长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引列等值查询时，与索引列进行等值匹配的对象信息</td>
</tr>
<tr>
<td>rows</td>
<td>预估的需要读取的记录条数</td>
</tr>
<tr>
<td>filtered</td>
<td>某个表经过搜索条件过滤后剩余记录条数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>一些额外的信息</td>
</tr>
</tbody></table>
<h2 id="前置相关知识点"><a href="#前置相关知识点" class="headerlink" title="前置相关知识点"></a>前置相关知识点</h2><p>为了详细了解执行计划各列含义，我们先得了解以下相关知识点。</p>
<h3 id="不相关子查询"><a href="#不相关子查询" class="headerlink" title="不相关子查询"></a>不相关子查询</h3><p>如果<em>子查询</em>可以单独运行出结果，而不依赖于外层查询，我们把这个子查询称之为<em>不相关子查询</em>。</p>
<h3 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h3><p>如果子查询的执行需要依赖于外层查询的值，我们就把这个子查询称之为<em>相关子查询</em>。</p>
<h3 id="子查询物化"><a href="#子查询物化" class="headerlink" title="子查询物化"></a>子查询物化</h3><p><strong>不直接将不相关子查询的结果集当作外层查询的参数，而是将该结果集写入一个临时表(物化表)里</strong>。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 = <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>假设子查询物化表的名称为<code>materialized_table</code>，该物化表存储的子查询结果集的列为<code>m_val</code>。子查询物化之后<strong>可以将表<code>s1</code>和子查询物化表<code>materialized_table</code>进行内连接操作</strong>，然后获取对应的查询结果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.* <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> materialized_table <span class="keyword">ON</span> key1 = m_val;</span><br></pre></td></tr></table></figure>

<h3 id="将子查询转换为semi-join"><a href="#将子查询转换为semi-join" class="headerlink" title="将子查询转换为semi-join"></a>将子查询转换为semi-join</h3><p>将子查询进行物化之后再执行查询都会有建立临时表的成本，能不能不进行物化操作直接把子查询转换为连接呢？让我们重新审视一下上边的查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 = <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>我们可以把这个查询理解成：<strong>对于<code>s1</code>表中的某条记录，如果我们能在<code>s2</code>表（准确的说是执行完<code>WHERE s2.key3 = &#39;a&#39;</code>之后的结果集）中找到一条或多条符合<code>s2.common_field=s1.key1</code>的记录，那么该条<code>s1</code>表的记录就会被加入到最终的结果集</strong>。这个过程其实和把<code>s1</code>和<code>s2</code>两个表连接起来的效果很像：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.* <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key1 = s2.common_field <span class="keyword">WHERE</span> s2.key3 = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure>

<p>这么做唯一的问题在于，对于<code>s1</code>表的某条记录来说，如果<code>s2</code>表中有<strong>多条记录</strong>满足<code>s1.key1 = s2.common_field</code>这个条件，那么该记录会被多次加入最终的结果集，因此<strong>二者不能认为是完全等价</strong>的，因此就有了<code>semi-join</code>(半连接)。将<code>s1</code>表和<code>s2</code>表进行半连接的意思就是：<strong>对于<code>s1</code>表的某条记录来说，我们只关心在<code>s2</code>表中是否存在与之匹配的记录，而不关心具体有多少条记录与之匹配，最终的结果集中只保留<code>s1</code>表的记录</strong>。当然<code>semi-join</code>是mysql内部机制，无法直接用在sql语句中。</p>
<h4 id="semi-join实现机制"><a href="#semi-join实现机制" class="headerlink" title="semi-join实现机制"></a>semi-join实现机制</h4><h5 id="Table-pullout-（子查询中的表上拉）"><a href="#Table-pullout-（子查询中的表上拉）" class="headerlink" title="Table pullout （子查询中的表上拉）"></a>Table pullout （子查询中的表上拉）</h5><p>当子查询的查询列表处<strong>只有主键或者唯一索引列</strong>时，可以直接把子查询中的表上拉到外层查询的<code>FROM</code>子句中，并把子查询中的搜索条件合并到外层查询的搜索条件中，比如这个：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1  <span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key2 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 = <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>由于<code>key2</code>列是<code>s2</code>表的唯一二级索引列，所以我们可以直接把<code>s2</code>表上拉到外层查询的<code>FROM</code>子句中，并且把子查询中的搜索条件合并到外层查询的搜索条件中，实际上就是直接将子查询优化为连接查询，上拉之后的查询就是这样的：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> s1.* <span class="keyword">FROM</span> s1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> s2 <span class="keyword">ON</span> s1.key2 = s2.key2 <span class="keyword">WHERE</span> s2.key3 = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure>

<h5 id="DuplicateWeedout-execution-strategy-（重复值消除）"><a href="#DuplicateWeedout-execution-strategy-（重复值消除）" class="headerlink" title="DuplicateWeedout execution strategy （重复值消除）"></a>DuplicateWeedout execution strategy （重复值消除）</h5><p>比如下面这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1  <span class="keyword">WHERE</span> key1 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> common_field <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key3 = <span class="string">'a'</span>);</span><br></pre></td></tr></table></figure>

<p>转换为半连接查询后，<code>s1</code>表中的某条记录可能在<code>s2</code>表中有多条匹配的记录，所以该条记录可能多次被添加到最后的结果集中。为了消除重复，我们可以建立一个临时表，比方说这个临时表长这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> tmp (</span><br><span class="line">    <span class="keyword">id</span> PRIMARY <span class="keyword">KEY</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>这样在执行连接查询的过程中，每当某条s1表中的记录要加入结果集时，就首先把这条记录的id值加入到这个临时表里。这种使用临时表消除<code>semi-join</code>结果集中的重复值的方式称之为<code>DuplicateWeedout</code>。</p>
<h5 id="LooseScan-execution-strategy-（松散扫描）"><a href="#LooseScan-execution-strategy-（松散扫描）" class="headerlink" title="LooseScan execution strategy （松散扫描）"></a>LooseScan execution strategy （松散扫描）</h5><p>比如下面这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key3 <span class="keyword">IN</span> (<span class="keyword">SELECT</span> key1 <span class="keyword">FROM</span> s2 <span class="keyword">WHERE</span> key1 &gt; <span class="string">'a'</span> <span class="keyword">AND</span> key1 &lt; <span class="string">'b'</span>);</span><br></pre></td></tr></table></figure>

<p>在子查询中，对于<code>s2</code>表的访问可以使用到<code>key1</code>列的索引，而恰好子查询的查询列表处就是<code>key1</code>列，这样在将该查询转换为半连接查询后，如果将<code>s2</code>作为驱动表执行查询的话，那么执行过程就是这样：<br><img data-src="https://chentianming11.github.io/images/mysql/looseScan.webp" alt="looseScan"><br>如图所示，在<code>s2</code>表的<code>idx_key1</code>索引中，值为<code>&#39;aa&#39;</code>的二级索引记录一共有3条，那么只需要取第一条的值到s1表中查找<code>s1.key3 = &#39;aa&#39;</code>的记录，如果能在<code>s1</code>表中找到对应的记录，那么就把对应的记录加入到结果集。<strong>这种虽然是扫描索引，但只取值相同的记录的第一条去做匹配操作的方式称之为松散扫描。</strong></p>
<h5 id="FirstMatch-execution-strategy-（首次匹配）"><a href="#FirstMatch-execution-strategy-（首次匹配）" class="headerlink" title="FirstMatch execution strategy （首次匹配）"></a>FirstMatch execution strategy （首次匹配）</h5><p><code>FirstMatch</code>是一种最原始的半连接执行方式，简单来说就是说先取一条外层查询的中的记录，然后到子查询的表中寻找符合匹配条件的记录，如果能找到一条，则将该外层查询的记录放入最终的结果集并且停止查找更多匹配的记录，如果找不到则把该外层查询的记录丢弃掉；然后再开始取下一条外层查询中的记录，重复上边这个过程。</p>
<h2 id="执行计划详解"><a href="#执行计划详解" class="headerlink" title="执行计划详解"></a>执行计划详解</h2><p>为了详细解释执行计划各列含义，先建2张示例表<code>s1</code>和<code>s2</code>，它们的表结构完全一样。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> s1 (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="built_in">INT</span>,</span><br><span class="line">    key3 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key1 (key1),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> idx_key2 (key2),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key3 (key3),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><p>不论我们的查询语句有多复杂，里边儿包含了多少个表，到最后也是需要对每个表进行单表访问的，因此<strong>EXPLAIN语句输出的每条记录都对应着某个单表的访问方法</strong>。其中的<code>table</code>列代表的就是该表的表名。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>上面的查询只涉及单表查询，因此<code>EXPLAIN</code>只输出了一条记录。<code>table</code>列的值是<code>s1</code>，表示该条记录描述了<strong>对<code>s1</code>表的访问方法</strong>。</p>
<p>下边我们看一下一个连接查询的执行计划：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>EXPLAIN</code>只输出了两条记录。<code>table</code>列的值是<code>s1</code>和<code>s2</code>，分别表示了<strong>对<code>s1</code>表和<code>s2</code>表的访问方法</strong>。</p>
<h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>大家都知道，查询语句中一般都会包含一个或多个<code>select</code>关键字。可以简单认为，<strong>查询语句每出现一个<code>select</code>关键字，执行计划中就会有一个对应的id值</strong>。比如下边这个查询中只有一个<code>SELECT</code>关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<p><strong>对于连接查询来说，一个<code>select</code>往往是对多张表进行查询的，所以在执行计划中就会有多条记录，但是它们的<code>id</code>都是一样的</strong>。其中，出现在前边的表是驱动表，出现在后边的表是被驱动表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                 |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+---------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<p><strong>对于子查询来说，就可能包含多个<code>select</code>关键字，每个<code>select</code>关键字都会对应一个唯一的id值</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.02 sec)</span><br></pre></td></tr></table></figure>

<p>但是还有一点需要注意：<strong>查询优化器可能对涉及子查询的查询语句进行重写，从而转换为连接查询</strong>。此时执行计划的id值就是一样的了。</p>
<p>对于包含<code>union</code>关键字的查询来说，除了每个<code>select</code>关键字对应一个id值，还会包含一个<code>id</code>值为<code>NULL</code>的记录。这条记录主要用来表示将两次查询的结果集进行去重的(<code>union all</code>因为不需要去重，所以没有这条记录)。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1  UNION SELECT * FROM s2;</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h3><p>我们已经知道，每一个<code>select</code>关键字都代表一次小查询，而<code>select_type</code>属性就是用来描述当前这个小查询的含义的。<code>select_type</code>属性含义(直接用官网英文表示)如下：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">SIMPLE</td>
<td align="center">Simple SELECT (not using UNION or subqueries)</td>
</tr>
<tr>
<td align="center">PRIMARY</td>
<td align="center">Outermost SELECT</td>
</tr>
<tr>
<td align="center">UNION</td>
<td align="center">Second or later SELECT statement in a UNION</td>
</tr>
<tr>
<td align="center">UNION RESULT</td>
<td align="center">Result of a UNION</td>
</tr>
<tr>
<td align="center">SUBQUERY</td>
<td align="center">First SELECT in subquery</td>
</tr>
<tr>
<td align="center">DEPENDENT SUBQUERY</td>
<td align="center">First SELECT in subquery, dependent on outer query</td>
</tr>
<tr>
<td align="center">DEPENDENT UNION</td>
<td align="center">Second or later SELECT statement in a UNION, dependent on outer query</td>
</tr>
<tr>
<td align="center">DERIVED</td>
<td align="center">Derived table</td>
</tr>
<tr>
<td align="center">MATERIALIZED</td>
<td align="center">Materialized subquery</td>
</tr>
<tr>
<td align="center">UNCACHEABLE SUBQUERY</td>
<td align="center">A subquery for which the result cannot be cached and must be re-evaluated for each row of the outer query</td>
</tr>
<tr>
<td align="center">UNCACHEABLE UNION</td>
<td align="center">The second or later select in a UNION that belongs to an uncacheable subquery (see UNCACHEABLE SUBQUERY)</td>
</tr>
</tbody></table>
<h4 id="SIMPLE"><a href="#SIMPLE" class="headerlink" title="SIMPLE"></a>SIMPLE</h4><p>查询语句中不包含<code>UNION</code>或者<code>子查询</code>的查询都算作是<code>SIMPLE</code>类型，比如常见的单表查询和连接查询等。</p>
<h4 id="PRIMARY"><a href="#PRIMARY" class="headerlink" title="PRIMARY"></a>PRIMARY</h4><p>对于包含<code>UNION</code>、<code>UNION ALL</code>或者<code>子查询</code>的大查询来说，它是由几个小查询组成的，其中最左边的那个查询的<code>select_type</code>值就是<code>PRIMARY</code>，比方说：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 UNION SELECT * FROM s2;</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type  | table      | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | PRIMARY      | s1         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL            |</span><br><span class="line">|  2 | UNION        | s2         | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |   100.00 | NULL            |</span><br><span class="line">| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL  | NULL          | NULL | NULL    | NULL | NULL |     NULL | Using temporary |</span><br><span class="line">+----+--------------+------------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">3 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h4><p>对于包含<code>UNION</code>或者<code>UNION ALL</code>的大查询来说，它是由几个小查询组成的，其中除了最左边的那个小查询以外，其余的小查询的<code>select_type</code>值就是<code>UNION</code>。</p>
<h4 id="UNION-RESULT"><a href="#UNION-RESULT" class="headerlink" title="UNION RESULT"></a>UNION RESULT</h4><p><code>MySQL</code>选择使用临时表来完成<code>UNION</code>查询的去重工作，针对该临时表的查询的<code>select_type</code>就是<code>UNION RESULT</code>。</p>
<h4 id="SUBQUERY"><a href="#SUBQUERY" class="headerlink" title="SUBQUERY"></a>SUBQUERY</h4><p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是不相关子查询，并且查询优化器决定采用将该<strong>子查询物化</strong>的方案来执行该子查询时，该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>SUBQUERY</code>，比如下边这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2) OR key3 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | s1    | NULL       | ALL   | idx_key3      | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | SUBQUERY    | s2    | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9954 |   100.00 | Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="DEPENDENT-SUBQUERY"><a href="#DEPENDENT-SUBQUERY" class="headerlink" title="DEPENDENT SUBQUERY"></a>DEPENDENT SUBQUERY</h4><p>如果包含子查询的查询语句不能够转为对应的<code>semi-join</code>的形式，并且该子查询是相关子查询，则该子查询的第一个<code>SELECT</code>关键字代表的那个查询的<code>select_type</code>就是<code>DEPENDENT SUBQUERY</code>，比如下边这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE s1.key2 &#x3D; s2.key2) OR key3 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type        | table | partitions | type | possible_keys     | key      | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY            | s1    | NULL       | ALL  | idx_key3          | NULL     | NULL    | NULL              | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | s2    | NULL       | ref  | idx_key2,idx_key1 | idx_key2 | 5       | xiaohaizi.s1.key2 |    1 |    10.00 | Using where |</span><br><span class="line">+----+--------------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">2 rows in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="DEPENDENT-UNION"><a href="#DEPENDENT-UNION" class="headerlink" title="DEPENDENT UNION"></a>DEPENDENT UNION</h4><p>在包含<code>UNION</code>或者<code>UNION ALL</code>的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的<code>select_type</code>的值就是<code>DEPENDENT UNION</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2 WHERE key1 &#x3D; &#39;a&#39; UNION SELECT key1 FROM s1 WHERE key1 &#x3D; &#39;b&#39;);</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">| id | select_type        | table      | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra                    |</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">|  1 | PRIMARY            | s1         | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | 9688 |   100.00 | Using where              |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | s2         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |   12 |   100.00 | Using where; Using index |</span><br><span class="line">|  3 | DEPENDENT UNION    | s1         | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | Using where; Using index |</span><br><span class="line">| NULL | UNION RESULT       | &lt;union2,3&gt; | NULL       | ALL  | NULL          | NULL     | NULL    | NULL  | NULL |     NULL | Using temporary          |</span><br><span class="line">+----+--------------------+------------+------------+------+---------------+----------+---------+-------+------+----------+--------------------------+</span><br><span class="line">4 rows in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<h4 id="DERIVED"><a href="#DERIVED" class="headerlink" title="DERIVED"></a>DERIVED</h4><p>对于采用物化的方式执行的包含派生表的查询，该派生表对应的子查询的<code>select_type</code>就是<code>DERIVED</code>，比方说下边这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM (SELECT key1, count(*) as c FROM s1 GROUP BY key1) AS derived_s1 where c &gt; 1;</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type | table      | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY     | &lt;derived2&gt; | NULL       | ALL   | NULL          | NULL     | NULL    | NULL | 9688 |    33.33 | Using where |</span><br><span class="line">|  2 | DERIVED     | s1         | NULL       | index | idx_key1      | idx_key1 | 303     | NULL | 9688 |   100.00 | Using index |</span><br><span class="line">+----+-------------+------------+------------+-------+---------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="MATERIALIZED"><a href="#MATERIALIZED" class="headerlink" title="MATERIALIZED"></a>MATERIALIZED</h4><p>当查询优化器在执行包含子查询的语句时，选择将子查询物化之后与外层查询进行连接查询时，该子查询对应的<code>select_type</code>属性就是<code>MATERIALIZED</code>，比如下边这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key1 FROM s2);</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type  | table       | partitions | type   | possible_keys | key        | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE       | s1          | NULL       | ALL    | idx_key1      | NULL       | NULL    | NULL              | 9688 |   100.00 | Using where |</span><br><span class="line">|  1 | SIMPLE       | &lt;subquery2&gt; | NULL       | eq_ref | &lt;auto_key&gt;    | &lt;auto_key&gt; | 303     | xiaohaizi.s1.key1 |    1 |   100.00 | NULL        |</span><br><span class="line">|  2 | MATERIALIZED | s2          | NULL       | index  | idx_key1      | idx_key1   | 303     | NULL              | 9954 |   100.00 | Using index |</span><br><span class="line">+----+--------------+-------------+------------+--------+---------------+------------+---------+-------------------+------+----------+-------------+</span><br><span class="line">3 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h3 id="type"><a href="#type" class="headerlink" title="type"></a>type</h3><p>上面提到过，<strong>执行计划的一条记录就代表了对一张表的访问方法</strong>，其中的<code>type</code>列就是用描述访问方法的。完整的访问方法如下：<code>system</code>，<code>const</code>，<code>eq_ref</code>，<code>ref</code>，<code>fulltext</code>，<code>ref_or_null</code>，<code>index_merge</code>，<code>unique_subquery</code>，<code>index_subquery</code>，<code>range</code>，<code>index</code>，<code>ALL</code>。</p>
<h4 id="system"><a href="#system" class="headerlink" title="system"></a>system</h4><p>当表中只有一条记录并且该表使用的存储引擎的统计数据是精确的，比如<code>MyISAM</code>、<code>Memory</code>，那么对该表的访问方法就是<code>system</code>。</p>
<h4 id="const"><a href="#const" class="headerlink" title="const"></a>const</h4><p>根据主键或者唯一二级索引列与常数进行等值匹配时，对单表的访问方法就是<code>const</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE id &#x3D; 5;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | const | PRIMARY       | PRIMARY | 4       | const |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+---------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="eq-ref"><a href="#eq-ref" class="headerlink" title="eq_ref"></a>eq_ref</h4><p>在连接查询时，如果被驱动表是通过主键或者唯一二级索引列等值匹配的方式进行访问的（如果该主键或者唯一二级索引是联合索引的话，所有的索引列都必须进行等值比较），则对该被驱动表的访问方法就是<code>eq_ref</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.id &#x3D; s2.id;</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type   | possible_keys | key     | key_len | ref             | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL    | PRIMARY       | NULL    | NULL    | NULL            | 9688 |   100.00 | NULL  |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | eq_ref | PRIMARY       | PRIMARY | 4       | xiaohaizi.s1.id |    1 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+--------+---------------+---------+---------+-----------------+------+----------+-------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h4><p>当通过普通的二级索引列与常量进行等值匹配时来查询某个表，那么对该表的访问方法就可能是<code>ref</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.04 sec)</span><br></pre></td></tr></table></figure>

<h4 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h4><p>当对普通二级索引进行等值匹配查询，该索引列的值也可以是<code>NULL</code>值时，那么对该表的访问方法就可能是<code>ref_or_null</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39; OR key1 IS NULL;</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys | key      | key_len | ref   | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref_or_null | idx_key1      | idx_key1 | 303     | const |    9 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------------+---------------+----------+---------+-------+------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="index-merge"><a href="#index-merge" class="headerlink" title="index_merge"></a>index_merge</h4><p>一般情况下对于某个表的查询只能使用到一个索引，但是某些场景下也可能使用索引合并，此时的<code>type</code>就是<code>index_merge</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39; OR key3 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                       |</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key1,idx_key3 | 303,303 | NULL |   14 |   100.00 | Using union(idx_key1,idx_key3); Using where |</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+---------------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h5 id="索引合并"><a href="#索引合并" class="headerlink" title="索引合并"></a>索引合并</h5><p>一般情况下，执行一个查询最多只会用到一个索引。但是在特殊情况下也可能会使用多个二级索引，使用这种方式执行的查询称为<code>index_merge</code>。具体的索引合并算法有下边三种。</p>
<ul>
<li><p>Intersection合并<br><code>Intersection</code>翻译过来的意思是交集。这里是说某个查询可以使用多个二级索引，将从多个二级索引中查询到的结果取交集，比方说下边这个查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> key1 = <span class="string">'a'</span> <span class="keyword">AND</span> key3 = <span class="string">'b'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Union合并<br>我们在写查询语句时经常想把既符合某个搜索条件的记录取出来，也把符合另外的某个搜索条件的记录取出来，我们说这些不同的搜索条件之间是OR关系。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> key1 = <span class="string">'a'</span> <span class="keyword">OR</span> key3 = <span class="string">'b'</span></span><br></pre></td></tr></table></figure>

<p><code>Intersection</code>是交集的意思，这适用于使用不同索引的搜索条件之间使用<code>AND</code>连接起来的情况；<code>Union</code>是并集的意思，适用于使用不同索引的搜索条件之间使用<code>OR</code>连接起来的情况。</p>
</li>
<li><p>Sort-Union合并<br><code>Union</code>索引合并的使用条件太苛刻，必须保证各个二级索引列在进行等值匹配的条件下才可能被用到，比方说下边这个查询就无法使用到<code>Union</code>索引合并：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> single_table <span class="keyword">WHERE</span> key1 &lt; <span class="string">'a'</span> <span class="keyword">OR</span> key3 &gt; <span class="string">'z'</span></span><br></pre></td></tr></table></figure>

<p>我们把上述这种先按照二级索引记录的主键值进行排序，之后按照<code>Union</code>索引合并方式执行的方式称之为<code>Sort-Union</code>索引合并，很显然，这种<code>Sort-Union</code>索引合并比单纯的<code>Union</code>索引合并多了一步对二级索引记录的主键值排序的过程。</p>
</li>
</ul>
<h4 id="unique-subquery"><a href="#unique-subquery" class="headerlink" title="unique_subquery"></a>unique_subquery</h4><p>类似于两表连接中被驱动表的<code>eq_ref</code>访问方法，<code>unique_subquery</code>是针对在一些包含<code>IN</code>子查询的查询语句中，如果查询优化器决定将<code>IN</code>子查询转换为<code>EXISTS</code>子查询，而且子查询可以使用到主键进行等值匹配的话，那么该子查询执行计划的<code>type</code>列的值就是<code>unique_subquery</code>，比如下边的这个查询语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key2 IN (SELECT id FROM s2 where s1.key1 &#x3D; s2.key1) OR key3 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type        | table | partitions | type            | possible_keys    | key     | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY            | s1    | NULL       | ALL             | idx_key3         | NULL    | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | s2    | NULL       | unique_subquery | PRIMARY,idx_key1 | PRIMARY | 4       | func |    1 |    10.00 | Using where |</span><br><span class="line">+----+--------------------+-------+------------+-----------------+------------------+---------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="index-subquery"><a href="#index-subquery" class="headerlink" title="index_subquery"></a>index_subquery</h4><p><code>index_subquery</code>与<code>unique_subquery</code>类似，只不过访问子查询中的表时使用的是普通的索引，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key3 FROM s2 where s1.key1 &#x3D; s2.key1) OR key3 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">| id | select_type        | table | partitions | type           | possible_keys     | key      | key_len | ref  | rows | filtered | Extra       |</span><br><span class="line">+----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">|  1 | PRIMARY            | s1    | NULL       | ALL            | idx_key3          | NULL     | NULL    | NULL | 9688 |   100.00 | Using where |</span><br><span class="line">|  2 | DEPENDENT SUBQUERY | s2    | NULL       | index_subquery | idx_key1,idx_key3 | idx_key3 | 303     | func |    1 |    10.00 | Using where |</span><br><span class="line">+----+--------------------+-------+------------+----------------+-------------------+----------+---------+------+------+----------+-------------+</span><br><span class="line">2 rows in set, 2 warnings (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>如果使用索引获取某些范围区间的记录，那么就可能使用到<code>range</code>访问方法，比如下边的这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;);</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |   27 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="index"><a href="#index" class="headerlink" title="index"></a>index</h4><p>需要扫描全部的索引记录时，该表的访问方法就是<code>index</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT key_part2 FROM s1 WHERE key_part3 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key          | key_len | ref  | rows | filtered | Extra                    |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key_part | 909     | NULL | 9688 |    10.00 | Using where; Using index |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+--------------+---------+------+------+----------+--------------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="ALL"><a href="#ALL" class="headerlink" title="ALL"></a>ALL</h4><p>全表扫描</p>
<h3 id="possible-keys和key"><a href="#possible-keys和key" class="headerlink" title="possible_keys和key"></a>possible_keys和key</h3><p><code>possible_keys</code>列表示在某个查询语句中，对某个表执行单表查询时可能用到的索引有哪些，<code>key</code>列表示实际用到的索引有哪些，比方说下边这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39; AND key3 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref   | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1,idx_key3 | idx_key3 | 303     | const |    6 |     2.75 | Using where |</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------+------+----------+-------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h3 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h3><p><code>key_len</code>列表示当优化器决定使用某个索引执行查询时，该索引记录的最大长度，它是由这三个部分构成的：</p>
<ul>
<li>对于使用固定长度类型的索引列来说，它实际占用的存储空间的最大长度就是该固定值；对于指定字符集是变长类型的索引列来说，比如某个索引列的类型是<code>VARCHAR(100)</code>，使用的字符集是<code>utf8</code>，那么该列实际占用的最大存储空间就是<code>100 × 3 = 300</code>个字节。</li>
<li>如果该索引列可以存储<code>NULL</code>值，则<code>key_len</code>比不可以存储<code>NULL</code>值时多1个字节。</li>
<li>对于变长字段来说，都会有2个字节的空间来存储该变长列的实际长度。</li>
</ul>
<h3 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a><code>ref</code></h3><p>当使用索引列等值匹配的条件去执行查询时，也就是在访问方法是<code>const</code>、<code>eq_ref</code>、<code>ref</code>、<code>ref_or_null</code>、<code>unique_subquery</code>、<code>index_subquery</code>其中之一时，<code>ref</code>列展示的就是与索引列作等值匹配的具体信息，比如只是一个常数或者是某个列。大家看下边这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref   | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | const |    8 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h3 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h3><p>如果查询优化器决定使用全表扫描的方式对某个表执行查询时，执行计划的<code>rows</code>列就代表预计需要扫描的行数，如果使用索引来执行查询时，执行计划的<code>rows</code>列就代表预计扫描的索引记录行数。比如下边这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &gt; &#39;z&#39;;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL |  266 |   100.00 | Using index condition |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h3><p>我们更关注在连接查询中驱动表对应的执行计划记录的<code>filtered</code>值，因为这直接影响了驱动表的扇出值。在<code>rows</code>样的情况下，<code>filtered</code>越大，扇出值越小，效率可能也越高。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.key1 &#x3D; s2.key1 WHERE s1.common_field &#x3D; &#39;a&#39;;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra       |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key1      | NULL     | NULL    | NULL              | 9688 |    10.00 | Using where |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |    1 |   100.00 | NULL        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>从执行计划中可以看出来，查询优化器打算把<code>s1</code>当作驱动表，<code>s2</code>当作被驱动表。我们可以看到驱动表<code>s1</code>表的执行计划的<code>rows</code>列为9688， <code>filtered</code>列为10.00，这意味着驱动表s1的扇出值就是<code>9688 × 10.00% = 968.8</code>，这说明还要对被驱动表执行大约<code>968</code>次查询。</p>
<h3 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h3><p><code>Extra</code>是用来说明一些额信息的，从而帮助我们更加准确的理解查询。下面我们挑几个比较常见的进行介绍。</p>
<h4 id="No-tables-used"><a href="#No-tables-used" class="headerlink" title="No tables used"></a>No tables used</h4><p>当查询语句中没有<code>from</code>字句时会出现<code>No tables used</code>。</p>
<h4 id="Impossible-WHERE"><a href="#Impossible-WHERE" class="headerlink" title="Impossible WHERE"></a>Impossible WHERE</h4><p>当查询语句中的<code>where</code>字句永远为<code>false</code>时会出现<code>Impossible WHERE</code>。</p>
<h4 id="No-matching-min-max-row"><a href="#No-matching-min-max-row" class="headerlink" title="No matching min/max row"></a>No matching min/max row</h4><p>当查询列表有<code>min()</code>或者<code>max()</code>聚集函数，但是没有匹配到对应的记录时会出现<code>No matching min/max row</code>。</p>
<h4 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h4><p>当使用<code>索引覆盖</code>的时候，会出现<code>Using index</code>。</p>
<h4 id="Using-index-condition"><a href="#Using-index-condition" class="headerlink" title="Using index condition"></a>Using index condition</h4><p>如果查询的执行过程中使用了<strong>索引条件下推(Index Condition Pushdown)</strong>，就会出现<code>Using index condition</code>。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> s1 <span class="keyword">WHERE</span> key1 &gt; <span class="string">'z'</span> <span class="keyword">AND</span> key1 <span class="keyword">LIKE</span> <span class="string">'%a'</span>;</span><br></pre></td></tr></table></figure>

<p>1、先根据<code>key1 &gt; &#39;z&#39;</code>这个条件，定位到二级索引<code>idx_key1</code>中对应的二级索引记录。<br>2、先不回表，而是检测是否满足<code>key1 LIKE &#39;%a&#39;</code>条件，最后再将满足条件的二级索引记录回表。</p>
<h4 id="Using-where"><a href="#Using-where" class="headerlink" title="Using where"></a>Using where</h4><p>当使用全表扫描执行查询时，如果查询语句包含<code>where</code>条件，就会出现<code>Using where</code>。<br>当使用索引访问执行查询时，如果<code>where</code>字句包含非索引列字段，也会出现<code>Using where</code>。</p>
<h4 id="Using-join-buffer-Block-Nested-Loop"><a href="#Using-join-buffer-Block-Nested-Loop" class="headerlink" title="Using join buffer (Block Nested Loop)"></a>Using join buffer (Block Nested Loop)</h4><p>在连接查询执行过程中，当被驱动表不能有效的利用索引加快访问速度，<code>MySQL</code>一般会为其分配一块名叫<code>join buffer</code>的内存块来加快查询速度，也就是我们所讲的<em>基于块的嵌套循环算法</em>，比如下边这个查询语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 INNER JOIN s2 ON s1.common_field &#x3D; s2.common_field;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra                                              |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | NULL                                               |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9954 |    10.00 | Using where; Using join buffer (Block Nested Loop) |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+----------------------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<h4 id="Not-exists"><a href="#Not-exists" class="headerlink" title="Not exists"></a>Not exists</h4><p>当我们使用左（外）连接时，如果<code>WHERE</code>子句中包含要求被驱动表的某个列等于<code>NULL</code>值的搜索条件，而且那个列又是不允许存储<code>NULL</code>值的，那么在该表的执行计划的<code>Extra</code>列就会提示<code>Not exists</code>额外信息，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 LEFT JOIN s2 ON s1.key1 &#x3D; s2.key1 WHERE s2.id IS NULL;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                   |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+-------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL     | NULL    | NULL              | 9688 |   100.00 | NULL                    |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s1.key1 |    1 |    10.00 | Using where; Not exists |</span><br><span class="line">+----+-------------+-------+------------+-</span><br></pre></td></tr></table></figure>

<h4 id="Using-intersect-…-、Using-union-…-和Using-sort-union-…"><a href="#Using-intersect-…-、Using-union-…-和Using-sort-union-…" class="headerlink" title="Using intersect(…)、Using union(…)和Using sort_union(…)"></a>Using intersect(…)、Using union(…)和Using sort_union(…)</h4><p>如果使用了<em>索引合并</em>执行查询，则会出现<code>Using intersect(...)</code>或者<code>Using union(...)</code>或者<code>Using sort_union(...)</code>。<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 &#x3D; &#39;a&#39; AND key3 &#x3D; &#39;a&#39;;</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+-------------------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type        | possible_keys     | key               | key_len | ref  | rows | filtered | Extra                                           |</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+-------------------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index_merge | idx_key1,idx_key3 | idx_key3,idx_key1 | 303,303 | NULL |    1 |   100.00 | Using intersect(idx_key3,idx_key1); Using where |</span><br><span class="line">+----+-------------+-------+------------+-------------+-------------------+-------------------+---------+------+------+----------+-------------------------------------------------+</span><br><span class="line">1 row in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="Zero-limit"><a href="#Zero-limit" class="headerlink" title="Zero limit"></a>Zero limit</h4><p>当<code>limit</code>子句参数为0时，就会出现<code>Zero limit</code>。</p>
<h4 id="Using-filesort"><a href="#Using-filesort" class="headerlink" title="Using filesort"></a>Using filesort</h4><p>有一些情况下对结果集中的记录进行排序是可以使用到索引的，比如下边这个查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 ORDER BY key1 LIMIT 10;</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | index | NULL          | idx_key1 | 303     | NULL |   10 |   100.00 | NULL  |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+------+------+----------+-------+</span><br><span class="line">1 row in set, 1 warning (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>但是更多情况下，排序操作无法使用到索引，而是只能使用文件排序(<code>filesort</code>)。如果排序使用了<code>filesort</code>，那么在<code>Extra</code>列就会出现<code>Using filesort</code>。</p>
<h4 id="Using-temporary"><a href="#Using-temporary" class="headerlink" title="Using temporary"></a>Using temporary</h4><p>在许多查询的执行过程中，<code>MySQL</code>可能会借助临时表来完成一些功能，比如去重、排序之类的，比如我们在执行许多包含<code>DISTINCT</code>、<code>GROUP BY</code>、<code>UNION</code>等子句的查询过程中，如果不能有效利用索引来完成查询，<code>MySQL</code>很有可能寻求通过建立内部的临时表来执行查询。如果查询中使用到了内部的临时表，在执行计划的<code>Extra</code>列将会显示<code>Using temporary</code>提示，比方说这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT DISTINCT common_field FROM s1;</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key  | key_len | ref  | rows | filtered | Extra           |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 9688 |   100.00 | Using temporary |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+------+---------+------+------+----------+-----------------+</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>执行计划中出现<code>Using temporary</code>并不是一个好的征兆，因为建立与维护临时表要付出很大成本的，所以我们最好能使用索引来替代掉使用临时表。</p>
<h4 id="Start-temporary-End-temporary"><a href="#Start-temporary-End-temporary" class="headerlink" title="Start temporary, End temporary"></a>Start temporary, End temporary</h4><p>查询优化器会优先尝试将IN子查询转换成<code>semi-join</code>，而<code>semi-join</code>又有好多种执行策略，当执行策略为<code>DuplicateWeedout</code>时，也就是通过建立临时表来实现为外层查询中的记录进行去重操作时，驱动表查询执行计划的<code>Extra</code>列将显示<code>Start temporary</code>提示，被驱动表查询执行计划的<code>Extra</code>列将显示<code>End temporary</code>提示，就是这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key1 IN (SELECT key3 FROM s2 WHERE common_field &#x3D; &#39;a&#39;);</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys | key      | key_len | ref               | rows | filtered | Extra                        |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ALL  | idx_key3      | NULL     | NULL    | NULL              | 9954 |    10.00 | Using where; Start temporary |</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref  | idx_key1      | idx_key1 | 303     | xiaohaizi.s2.key3 |    1 |   100.00 | End temporary                |</span><br><span class="line">+----+-------------+-------+------------+------+---------------+----------+---------+-------------------+------+----------+------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.00 sec)</span><br></pre></td></tr></table></figure>

<h4 id="LooseScan"><a href="#LooseScan" class="headerlink" title="LooseScan"></a>LooseScan</h4><p>在将In子查询转为<code>semi-join</code>时，如果采用的是<code>LooseScan</code>执行策略，则在驱动表执行计划的<code>Extra</code>列就是显示<code>LooseScan</code>提示，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE key3 IN (SELECT key1 FROM s2 WHERE key1 &gt; &#39;z&#39;);</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------------------------------+</span><br><span class="line">| id | select_type | table | partitions | type  | possible_keys | key      | key_len | ref               | rows | filtered | Extra                               |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------------------------------+</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | range | idx_key1      | idx_key1 | 303     | NULL              |  270 |   100.00 | Using where; Using index; LooseScan |</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ref   | idx_key3      | idx_key3 | 303     | xiaohaizi.s2.key1 |    1 |   100.00 | NULL                                |</span><br><span class="line">+----+-------------+-------+------------+-------+---------------+----------+---------+-------------------+------+----------+-------------------------------------+</span><br><span class="line">2 rows in set, 1 warning (0.01 sec)</span><br></pre></td></tr></table></figure>

<h4 id="FirstMatch-tbl-name"><a href="#FirstMatch-tbl-name" class="headerlink" title="FirstMatch(tbl_name)"></a>FirstMatch(tbl_name)</h4><p>在将In子查询转为<code>semi-join</code>时，如果采用的是<code>FirstMatch</code>执行策略，则在被驱动表执行计划的<code>Extra</code>列就是显示<code>FirstMatch(tbl_name)</code>提示，比如这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; EXPLAIN SELECT * FROM s1 WHERE common_field IN (SELECT key1 FROM s2 where s1.key3 &#x3D; s2.key3);</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-----------------------------+</span><br><span class="line">| id | select_type | table | partitions | type | possible_keys     | key      | key_len | ref               | rows | filtered | Extra                       |</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-----------------------------+</span><br><span class="line">|  1 | SIMPLE      | s1    | NULL       | ALL  | idx_key3          | NULL     | NULL    | NULL              | 9688 |   100.00 | Using where                 |</span><br><span class="line">|  1 | SIMPLE      | s2    | NULL       | ref  | idx_key1,idx_key3 | idx_key3 | 303     | xiaohaizi.s1.key3 |    1 |     4.87 | Using where; FirstMatch(s1) |</span><br><span class="line">+----+-------------+-------+------------+------+-------------------+----------+---------+-------------------+------+----------+-----------------------------+</span><br><span class="line">2 rows in set, 2 warnings (0.00 sec)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>必须了解的mysql三大日志-binlog、redo log和undo log</title>
    <url>/posts/1294535823/</url>
    <content><![CDATA[<p>日志是<code>mysql</code>数据库的重要组成部分，记录着数据库运行期间各种状态信息。<code>mysql</code>日志主要包括错误日志、查询日志、慢查询日志、事务日志、二进制日志几大类。作为开发，我们重点需要关注的是二进制日志(<code>binlog</code>)和事务日志(包括<code>redo log</code>和<code>undo log</code>)，本文接下来会详细介绍这三种日志。</p>
<a id="more"></a>

<h2 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h2><p><code>binlog</code>用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中。<code>binlog</code>是<code>mysql</code>的逻辑日志，并且由<code>Server</code>层进行记录，使用任何存储引擎的<code>mysql</code>数据库都会记录<code>binlog</code>日志。</p>
<blockquote>
<p>逻辑日志：<strong>可以简单理解为记录的就是sql语句</strong>。<br>物理日志：<strong>因为<code>mysql</code>数据最终是保存在数据页中的，物理日志记录的就是数据页变更</strong>。</p>
</blockquote>
<p><code>binlog</code>是通过追加的方式进行写入的，可以通过<code>max_binlog_size</code>参数设置每个<code>binlog</code>文件的大小，当文件大小达到给定值之后，会生成新的文件来保存日志。</p>
<h3 id="binlog使用场景"><a href="#binlog使用场景" class="headerlink" title="binlog使用场景"></a>binlog使用场景</h3><p>在实际应用中，<code>binlog</code>的主要使用场景有两个，分别是<strong>主从复制</strong>和<strong>数据恢复</strong>。</p>
<ol>
<li><strong>主从复制</strong>：在<code>Master</code>端开启<code>binlog</code>，然后将<code>binlog</code>发送到各个<code>Slave</code>端，<code>Slave</code>端重放<code>binlog</code>从而达到主从数据一致。</li>
<li><strong>数据恢复</strong>：通过使用<code>mysqlbinlog</code>工具来恢复数据。</li>
</ol>
<h3 id="binlog刷盘时机"><a href="#binlog刷盘时机" class="headerlink" title="binlog刷盘时机"></a>binlog刷盘时机</h3><p>对于<code>InnoDB</code>存储引擎而言，只有在事务提交时才会记录<code>biglog</code>，此时记录还在内存中，那么<code>biglog</code>是什么时候刷到磁盘中的呢？<code>mysql</code>通过<code>sync_binlog</code>参数控制<code>biglog</code>的刷盘时机，取值范围是<code>0-N</code>：</p>
<ul>
<li>0：不去强制要求，由系统自行判断何时写入磁盘；</li>
<li>1：每次<code>commit</code>的时候都要将<code>binlog</code>写入磁盘；</li>
<li>N：每N个事务，才会将<code>binlog</code>写入磁盘。</li>
</ul>
<p>从上面可以看出，<code>sync_binlog</code>最安全的是设置是<code>1</code>，这也是<code>MySQL 5.7.7</code>之后版本的默认值。但是设置一个大一些的值可以提升数据库性能，因此实际情况下也可以将值适当调大，牺牲一定的一致性来获取更好的性能。</p>
<h3 id="binlog日志格式"><a href="#binlog日志格式" class="headerlink" title="binlog日志格式"></a>binlog日志格式</h3><p><code>binlog</code>日志有三种格式，分别为<code>STATMENT</code>、<code>ROW</code>和<code>MIXED</code>。</p>
<blockquote>
<p>在 <code>MySQL 5.7.7</code>之前，默认的格式是<code>STATEMENT</code>，<code>MySQL 5.7.7</code>之后，默认值是<code>ROW</code>。日志格式通过<code>binlog-format</code>指定。</p>
</blockquote>
<ul>
<li><code>STATMENT</code><br><strong>基于<code>SQL</code>语句的复制(<code>statement-based replication, SBR</code>)，每一条会修改数据的sql语句会记录到<code>binlog</code>中</strong>。<br>优点：<strong>不需要记录每一行的变化，减少了<code>binlog</code>日志量，节约了<code>IO</code>, 从而提高了性能</strong>；<br>缺点：<strong>在某些情况下会导致主从数据不一致，比如执行<code>sysdate()</code>、<code>slepp()</code>等</strong>。</li>
<li><code>ROW</code><br><strong>基于行的复制(<code>row-based replication, RBR</code>)，不记录每条sql语句的上下文信息，仅需记录哪条数据被修改了</strong>。<br>优点：<strong>不会出现某些特定情况下的存储过程、或function、或trigger的调用和触发无法被正确复制的问题</strong>；<br>缺点：<strong>会产生大量的日志，尤其是<code>alter table</code>的时候会让日志暴涨</strong></li>
<li><code>MIXED</code><br><strong>基于<code>STATMENT</code>和<code>ROW</code>两种模式的混合复制(<code>mixed-based replication, MBR</code>)，一般的复制使用<code>STATEMENT</code>模式保存<code>binlog</code>，对于<code>STATEMENT</code>模式无法复制的操作使用<code>ROW</code>模式保存<code>binlog</code></strong></li>
</ul>
<h2 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h2><h3 id="为什么需要redo-log"><a href="#为什么需要redo-log" class="headerlink" title="为什么需要redo log"></a>为什么需要redo log</h3><p>我们都知道，事务的四大特性里面有一个是<strong>持久性</strong>，具体来说就是<strong>只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态</strong>。那么<code>mysql</code>是如何保证持久性的呢？最简单的做法是在每次事务提交的时候，将该事务涉及修改的数据页全部刷新到磁盘中。但是这么做会有严重的性能问题，主要体现在两个方面：</p>
<ol>
<li>因为<code>Innodb</code>是以<code>页</code>为单位进行磁盘交互的，而一个事务很可能只修改一个数据页里面的几个字节，这个时候将完整的数据页刷到磁盘的话，太浪费资源了！</li>
<li>一个事务可能涉及修改多个数据页，并且这些数据页在物理上并不连续，使用随机IO写入性能太差！</li>
</ol>
<p>因此<code>mysql</code>设计了<code>redo log</code>，<strong>具体来说就是只记录事务对数据页做了哪些修改</strong>，这样就能完美地解决性能问题了(相对而言文件更小并且是顺序IO)。</p>
<h3 id="redo-log基本概念"><a href="#redo-log基本概念" class="headerlink" title="redo log基本概念"></a>redo log基本概念</h3><p><code>redo log</code>包括两部分：一个是内存中的日志缓冲(<code>redo log buffer</code>)，另一个是磁盘上的日志文件(<code>redo log file</code>)。<code>mysql</code>每执行一条<code>DML</code>语句，先将记录写入<code>redo log buffer</code>，后续某个时间点再一次性将多个操作记录写到<code>redo log file</code>。这种<strong>先写日志，再写磁盘</strong>的技术就是<code>MySQL</code>里经常说到的<code>WAL(Write-Ahead Logging)</code> 技术。</p>
<p>在计算机操作系统中，用户空间(<code>user space</code>)下的缓冲区数据一般情况下是无法直接写入磁盘的，中间必须经过操作系统内核空间(<code>kernel space</code>)缓冲区(<code>OS Buffer</code>)。因此，<code>redo log buffer</code>写入<code>redo log file</code>实际上是先写入<code>OS Buffer</code>，然后再通过系统调用<code>fsync()</code>将其刷到<code>redo log file</code>中，过程如下：<br><img data-src="https://chentianming11.github.io/images/mysql/log-buffer.png" alt="log-buffer"></p>
<p><code>mysql</code>支持三种将<code>redo log buffer</code>写入<code>redo log file</code>的时机，可以通过<code>innodb_flush_log_at_trx_commit</code>参数配置，各参数值含义如下：</p>
<table>
<thead>
<tr>
<th>参数值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>0（延迟写）</td>
<td>事务提交时不会将<code>redo log buffer</code>中日志写入到<code>os buffer</code>，而是每秒写入<code>os buffer</code>并调用<code>fsync()</code>写入到<code>redo log file</code>中。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</td>
</tr>
<tr>
<td>1（实时写，实时刷）</td>
<td>事务每次提交都会将<code>redo log buffer</code>中的日志写入<code>os buffer</code>并调用<code>fsync()</code>刷到<code>redo log file</code>中。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO的性能较差。</td>
</tr>
<tr>
<td>2（实时写，延迟刷）</td>
<td>每次提交都仅写入到<code>os buffer</code>，然后是每秒调用<code>fsync()</code>将<code>os buffer</code>中的日志写入到<code>redo log file</code>。</td>
</tr>
</tbody></table>
<p><img data-src="https://chentianming11.github.io/images/mysql/innodb_flush_log_at_trx_commit.png" alt="log-buffer"></p>
<h3 id="redo-log记录形式"><a href="#redo-log记录形式" class="headerlink" title="redo log记录形式"></a>redo log记录形式</h3><p>前面说过，<code>redo log</code>实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此<code>redo log</code>实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。如下图：<br><img data-src="https://chentianming11.github.io/images/mysql/redo-log.png" alt="redo-log"></p>
<p>同时我们很容易得知，<strong>在innodb中，既有<code>redo log</code>需要刷盘，还有<code>数据页</code>也需要刷盘，<code>redo log</code>存在的意义主要就是降低对<code>数据页</code>刷盘的要求</strong>。在上图中，<code>write pos</code>表示<code>redo log</code>当前记录的<code>LSN</code>(逻辑序列号)位置，<code>check point</code>表示<strong>数据页更改记录</strong>刷盘后对应<code>redo log</code>所处的<code>LSN</code>(逻辑序列号)位置。<code>write pos</code>到<code>check point</code>之间的部分是<code>redo log</code>空着的部分，用于记录新的记录；<code>check point</code>到<code>write pos</code>之间是<code>redo log</code>待落盘的数据页更改记录。当<code>write pos</code>追上<code>check point</code>时，会先推动<code>check point</code>向前移动，空出位置再记录新的日志。</p>
<p>启动<code>innodb</code>的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为<code>redo log</code>记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如<code>binlog</code>)要快很多。<br>重启<code>innodb</code>时，首先会检查磁盘中数据页的<code>LSN</code>，如果数据页的<code>LSN</code>小于日志中的<code>LSN</code>，则会从<code>checkpoint</code>开始恢复。<br>还有一种情况，在宕机前正处于<code>checkpoint</code>的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的<code>LSN</code>大于日志中的<code>LSN</code>，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</p>
<h3 id="redo-log与binlog区别"><a href="#redo-log与binlog区别" class="headerlink" title="redo log与binlog区别"></a>redo log与binlog区别</h3><table>
<thead>
<tr>
<th></th>
<th>redo log</th>
<th>binlog</th>
</tr>
</thead>
<tbody><tr>
<td>文件大小</td>
<td><code>redo log</code>的大小是固定的。</td>
<td><code>binlog</code>可通过配置参数<code>max_binlog_size</code>设置每个<code>binlog</code>文件的大小。</td>
</tr>
<tr>
<td>实现方式</td>
<td><code>redo log</code>是<code>InnoDB</code>引擎层实现的，并不是所有引擎都有。</td>
<td><code>binlog</code>是<code>Server</code>层实现的，所有引擎都可以使用 <code>binlog</code>日志</td>
</tr>
<tr>
<td>记录方式</td>
<td>redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。</td>
<td>binlog 通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上</td>
</tr>
<tr>
<td>适用场景</td>
<td><code>redo log</code>适用于崩溃恢复(crash-safe)</td>
<td><code>binlog</code>适用于主从复制和数据恢复</td>
</tr>
</tbody></table>
<p>由<code>binlog</code>和<code>redo log</code>的区别可知：<code>binlog</code>日志只用于归档，只依靠<code>binlog</code>是没有<code>crash-safe</code>能力的。但只有<code>redo log</code>也不行，因为<code>redo log</code>是<code>InnoDB</code>特有的，且日志上的记录落盘后会被覆盖掉。因此需要<code>binlog</code>和<code>redo log</code>二者同时记录，才能保证当数据库发生宕机重启时，数据不会丢失。</p>
<h2 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h2><p>数据库事务四大特性中有一个是<strong>原子性</strong>，具体来说就是 <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。实际上，<strong>原子性</strong>底层就是通过<code>undo log</code>实现的。<code>undo log</code>主要记录了数据的逻辑变化，比如一条<code>INSERT</code>语句，对应一条<code>DELETE</code>的<code>undo log</code>，对于每个<code>UPDATE</code>语句，对应一条相反的<code>UPDATE</code>的<code>undo log</code>，这样在发生错误时，就能回滚到事务之前的数据状态。同时，<code>undo log</code>也是<code>MVCC</code>(多版本并发控制)实现的关键，这部分内容在<a href="https://juejin.im/post/6855129007336521741" target="_blank" rel="noopener">面试中的老大难-mysql事务和锁，一次性讲清楚！</a>中有介绍，不再赘述。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://juejin.im/post/6844903794073960455" target="_blank" rel="noopener">https://juejin.im/post/6844903794073960455</a></li>
<li><a href="https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html" target="_blank" rel="noopener">https://www.cnblogs.com/f-ck-need-u/archive/2018/05/08/9010872.html</a></li>
<li><a href="https://www.cnblogs.com/ivy-zheng/p/11094528.html" target="_blank" rel="noopener">https://www.cnblogs.com/ivy-zheng/p/11094528.html</a></li>
<li><a href="https://yq.aliyun.com/articles/592937" target="_blank" rel="noopener">https://yq.aliyun.com/articles/592937</a></li>
<li><a href="https://www.jianshu.com/p/5af73b203f2a" target="_blank" rel="noopener">https://www.jianshu.com/p/5af73b203f2a</a></li>
<li><a href="https://www.jianshu.com/p/20e10ed721d0" target="_blank" rel="noopener">https://www.jianshu.com/p/20e10ed721d0</a></li>
</ol>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>面试中的老大难-mysql事务和锁，一次性讲清楚！</title>
    <url>/posts/293834368/</url>
    <content><![CDATA[<p>众所周知，<code>事务和锁</code>是mysql中非常重要功能，同时也是面试的重点和难点。本文会详细介绍<code>事务和锁</code>的相关概念及其实现原理，相信大家看完之后，一定会对<code>事务和锁</code>有更加深入的理解。</p>
<a id="more"></a>

<blockquote>
<p>本文主要内容是根据掘金小册《从根儿上理解 MySQL》整理而来。如想详细了解，建议购买掘金小册阅读。</p>
</blockquote>
<h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>在维基百科中，对事务的定义是：<strong>事务是数据库管理系统(DBMS)执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成</strong>。</p>
<h3 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h3><p>事务包含四大特性，即<strong>原子性（Atomicity）</strong>、<strong>一致性（Consistency）</strong>、<strong>隔离性（Isolation）</strong>和<strong>持久性（Durability）</strong>(ACID)。</p>
<ol>
<li>原子性（Atomicity）<br> <strong>原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况</strong>。以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的。</li>
<li>一致性（Consistency）<br> <strong>一致性是指数据库的完整性约束没有被破坏，在事务执行前后都是合法的数据状态</strong>。这里的一致可以表示数据库自身的约束没有被破坏，比如某些字段的唯一性约束、字段长度约束等等；还可以表示各种实际场景下的业务约束，比如上面转账操作，一个账户减少的金额和另一个账户增加的金额一定是一样的。</li>
<li>隔离性（Isolation）<br> <strong>隔离性指的是多个事务彼此之间是完全隔离、互不干扰的</strong>。隔离性的最终目的也是为了保证一致性。</li>
<li>持久性（Durability）<br> <strong>持久性是指只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态</strong>。</li>
</ol>
<h3 id="事务的状态"><a href="#事务的状态" class="headerlink" title="事务的状态"></a>事务的状态</h3><p>根据事务所处的不同阶段，事务大致可以分为以下5个状态：</p>
<ol>
<li>活动的（active）<br>当事务对应的数据库操作正在执行过程中，则该事务处于<code>活动</code>状态。</li>
<li>部分提交的（partially committed）<br>当事务中的最后一个操作执行完成，但还未将变更刷新到磁盘时，则该事务处于<code>部分提交</code>状态。</li>
<li>失败的（failed）<br>当事务处于<code>活动</code>或者<code>部分提交</code>状态时，由于某些错误导致事务无法继续执行，则事务处于<code>失败</code>状态。</li>
<li>中止的（aborted）<br>当事务处于<code>失败</code>状态，且回滚操作执行完毕，数据恢复到事务执行之前的状态时，则该事务处于<code>中止</code>状态。</li>
<li>提交的（committed）<br>当事务处于<code>部分提交</code>状态，并且将修改过的数据都同步到磁盘之后，此时该事务处于<code>提交</code>状态。</li>
</ol>
<p><img data-src="https://chentianming11.github.io/images/mysql/transaction-status.webp" alt="事务状态"></p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>前面提到过，事务必须具有隔离性。实现隔离性最简单的方式就是不允许事务并发，每个事务都排队执行，但是这种方式性能实在太差了。为了兼顾事务的隔离性和性能，事务支持不同的隔离级别。</p>
<p>为了方便表述后续的内容，我们先建一张示例表<code>hero</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hero (</span><br><span class="line">    <span class="built_in">number</span> <span class="built_in">INT</span>,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    country <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="built_in">number</span>)</span><br><span class="line">) <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure>

<h4 id="事务并发执行遇到的问题"><a href="#事务并发执行遇到的问题" class="headerlink" title="事务并发执行遇到的问题"></a>事务并发执行遇到的问题</h4><p>在事务并发执行时，如果不进行任何控制，可能会出现以下4类问题：</p>
<ul>
<li>脏写（Dirty Write）<br> <strong>脏写是指一个事务修改了其它事务未提交的数据</strong>。<br> <img data-src="https://chentianming11.github.io/images/mysql/dirty-write.webp" alt="脏写"><br> 如上图，<code>Session A</code>和<code>Session B</code>各开启了一个事务，<code>Session B</code>中的事务先将<code>number</code>列为1的记录的<code>name</code>列更新为’关羽’，然后<code>Session A</code>中的事务接着又把这条<code>number</code>列为1的记录的<code>name</code>列更新为张飞。如果之后<code>Session B</code>中的事务进行了回滚，那么<code>Session A</code>中的更新也将不复存在，这种现象就称之为<strong>脏写</strong>。</li>
<li>脏读（Dirty Read）<br><strong>脏读是指一个事务读到了其它事务未提交的数据</strong>。<br><img data-src="https://chentianming11.github.io/images/mysql/dirty-read.webp" alt="脏读"><br>如上图，<code>Session A</code>和<code>Session B</code>各开启了一个事务，<code>Session B</code>中的事务先将<code>number</code>列为1的记录的<code>name</code>列更新为<code>&#39;关羽&#39;</code>，然后<code>Session A</code>中的事务再去查询这条<code>number</code>为1的记录，如果读到列<code>name</code>的值为<code>&#39;关羽&#39;</code>，而<code>Session B</code>中的事务稍后进行了回滚，那么<code>Session A</code>中的事务相当于读到了一个不存在的数据，这种现象就称之为<strong>脏读</strong>。  </li>
<li>不可重复读（Non-Repeatable Read）<br><strong>不可重复读指的是在一个事务执行过程中，读取到其它事务已提交的数据，导致两次读取的结果不一致</strong>。<br><img data-src="https://chentianming11.github.io/images/mysql/no-repeat.webp" alt="不可重复读"><br>如上图，我们在<code>Session B</code>中提交了几个隐式事务(mysql会自动为增删改语句加事务)，这些事务都修改了<code>number</code>列为1的记录的列<code>name</code>的值，每次事务提交之后，如果<code>Session A中</code>的事务都可以查看到最新的值，这种现象也被称之为<strong>不可重复读</strong>。</li>
<li>幻读（Phantom）<br><strong>幻读是指的是在一个事务执行过程中，读取到了其他事务新插入数据，导致两次读取的结果不一致</strong>。<br><img data-src="https://chentianming11.github.io/images/mysql/phantom.webp" alt="幻读"><br>如上图，<code>Session A</code>中的事务先根据条件<code>number &gt; 0</code>这个条件查询表<code>hero</code>，得到了<code>name</code>列值为<code>&#39;刘备&#39;</code>的记录；之后<code>Session B</code>中提交了一个隐式事务，该事务向表<code>hero</code>中插入了一条新记录；之后<code>Session A</code>中的事务再根据相同的条件<code>number &gt; 0</code>查询表<code>hero</code>，得到的结果集中包含<code>Session B</code>中的事务新插入的那条记录，这种现象也被称之为<strong>幻读</strong>。</li>
</ul>
<blockquote>
<p>不可重复读和幻读的区别在于<strong>不可重复读是读到的是其他事务修改或者删除的数据，而幻读读到的是其它事务新插入的数据</strong>。</p>
</blockquote>
<p>脏写的问题太严重了，任何隔离级别都必须避免。其它无论是脏读，不可重复读，还是幻读，它们都属于数据库的读一致性的问题，都是在一个事务里面前后两次读取出现了不一致的情况。</p>
<h4 id="四种隔离级别"><a href="#四种隔离级别" class="headerlink" title="四种隔离级别"></a>四种隔离级别</h4><p>在<code>SQL</code>标准中设立了4种隔离级别，用来解决上面的读一致性问题。不同的隔离级别可以解决不同的读一致性问题。</p>
<ul>
<li><p><code>READ UNCOMMITTED</code>：未提交读。</p>
</li>
<li><p><code>READ COMMITTED</code>：已提交读。</p>
</li>
<li><p><code>REPEATABLE READ</code>：可重复读。</p>
</li>
<li><p><code>SERIALIZABLE</code>：串行化。</p>
</li>
</ul>
<p>各个隔离级别下可能出现的读一致性问题如下：</p>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody><tr>
<td>未提交读（READ UNCOMMITTED）</td>
<td>可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>已提交读（READ COMMITTED）</td>
<td>不可能</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>可重复读（REPEATABLE READ）</td>
<td>不可能</td>
<td>不可能</td>
<td>可能（对InnoDB不可能）</td>
</tr>
<tr>
<td>串行化（SERIALIZABLE）</td>
<td>不可能</td>
<td>不可能</td>
<td>不可能</td>
</tr>
</tbody></table>
<p><code>InnoDB</code>支持四个隔离级别（和<code>SQL</code>标准定义的基本一致）。隔离级别越高，事务的并发度就越低。唯一的区别就在于，<strong><code>InnoDB</code> 在<code>可重复读（REPEATABLE READ）</code>的级别就解决了幻读的问题</strong>。这也是<code>InnoDB</code>使用<code>可重复读</code> 作为事务默认隔离级别的原因。</p>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>MVCC(Multi Version Concurrency Control)，中文名是多版本并发控制，简单来说就是通过维护数据历史版本，从而解决并发访问情况下的读一致性问题。</p>
<h3 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h3><p>在<code>InnoDB</code>中，每行记录实际上都包含了两个隐藏字段：事务id(<code>trx_id</code>)和回滚指针(<code>roll_pointer</code>)。</p>
<ol>
<li><code>trx_id</code>：事务id。每次修改某行记录时，都会把该事务的事务id赋值给<code>trx_id</code>隐藏列。</li>
<li><code>roll_pointer</code>：回滚指针。每次修改某行记录时，都会把<code>undo</code>日志地址赋值给<code>roll_pointer</code>隐藏列。</li>
</ol>
<p>假设<code>hero</code>表中只有一行记录，当时插入的事务id为80。此时，该条记录的示例图如下：<br><img data-src="https://chentianming11.github.io/images/mysql/mvcc1.webp" alt="mvcc1"><br>假设之后两个事务<code>id</code>分别为<code>100</code>、<code>200</code>的事务对这条记录进行<code>UPDATE</code>操作，操作流程如下：<br><img data-src="https://chentianming11.github.io/images/mysql/mvcc2.webp" alt="mvcc2"><br>由于每次变动都会先把<code>undo</code>日志记录下来，并用<code>roll_pointer</code>指向<code>undo</code>日志地址。因此可以认为，<strong>对该条记录的修改日志串联起来就形成了一个<code>版本链</code>，版本链的头节点就是当前记录最新的值</strong>。如下：<br><img data-src="https://chentianming11.github.io/images/mysql/mvcc3.webp" alt="mvcc3"></p>
<h3 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h3><p>如果数据库隔离级别是<code>未提交读（READ UNCOMMITTED）</code>，那么读取版本链中最新版本的记录即可。如果是是<code>串行化（SERIALIZABLE）</code>，事务之间是加锁执行的，不存在读不一致的问题。<strong>但是如果是<code>已提交读（READ COMMITTED）</code>或者<code>可重复读（REPEATABLE READ）</code>，就需要遍历版本链中的每一条记录，判断该条记录是否对当前事务可见，直到找到为止(遍历完还没找到就说明记录不存在)</strong>。<code>InnoDB</code>通过<code>ReadView</code>实现了这个功能。<code>ReadView</code>中主要包含以下4个内容：</p>
<ul>
<li><code>m_ids</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务的事务id列表。</li>
<li><code>min_trx_id</code>：表示在生成<code>ReadView</code>时当前系统中活跃的读写事务中最小的事务id，也就是<code>m_ids</code>中的最小值。</li>
<li><code>max_trx_id</code>：表示生成<code>ReadView</code>时系统中应该分配给<strong>下一个事务的id值</strong>。</li>
<li><code>creator_trx_id</code>：表示生成该<code>ReadView</code>事务的事务id。</li>
</ul>
<p>有了<code>ReadView</code>之后，我们可以基于以下步骤判断某个版本的记录是否对当前事务可见。</p>
<ol>
<li>如果被访问版本的<code>trx_id</code>属性值与<code>ReadView</code>中的<code>creator_trx_id</code>值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的<code>trx_id</code>属性值小于<code>ReadView</code>中的<code>min_trx_id</code>值，表明生成该版本的事务在当前事务生成<code>ReadView</code>前已经提交，所以该版本可以被当前事务访问。</li>
<li>如果被访问版本的<code>trx_id</code>属性值大于或等于<code>ReadView</code>中的<code>max_trx_id</code>值，表明生成该版本的事务在当前事务生成<code>ReadView</code>后才开启，所以该版本不可以被当前事务访问。</li>
<li>如果被访问版本的<code>trx_id</code>属性值在<code>ReadView</code>的<code>min_trx_id</code>和<code>max_trx_id</code>之间，那就需要判断一下<code>trx_id</code>属性值是不是在<code>m_ids</code>列表中，如果在，说明创建<code>ReadView</code>时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建<code>ReadView</code>时生成该版本的事务已经被提交，该版本可以被访问。</li>
</ol>
<p>在<code>MySQL</code>中，<code>READ COMMITTED</code>和<code>REPEATABLE READ</code>隔离级别的的一个非常大的区别就是它们生成<code>ReadView</code>的时机不同。<strong><code>READ COMMITTED</code>在每次读取数据前都会生成一个<code>ReadView</code></strong>，这样就能保证每次都能读到其它事务已提交的数据。<strong><code>REPEATABLE READ</code> 只在第一次读取数据时生成一个<code>ReadView</code></strong>，这样就能保证后续读取的结果完全一致。</p>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>事务并发访问同一数据资源的情况主要就分为<code>读-读</code>、<code>写-写</code>和<code>读-写</code>三种。</p>
<ol>
<li><code>读-读</code><br> 即并发事务同时访问同一行数据记录。由于两个事务都进行只读操作，不会对记录造成任何影响，因此并发读完全允许。</li>
<li><code>写-写</code><br> 即并发事务同时修改同一行数据记录。这种情况下可能导致<code>脏写</code>问题，这是任何情况下都不允许发生的，因此只能通过<code>加锁</code>实现，也就是当一个事务需要对某行记录进行修改时，首先会先给这条记录加锁，如果加锁成功则继续执行，否则就排队等待，事务执行完成或回滚会自动释放锁。</li>
<li><code>读-写</code><br> 即一个事务进行读取操作，另一个进行写入操作。这种情况下可能会产生<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>。最好的方案是<strong>读操作利用多版本并发控制（<code>MVCC</code>），写操作进行加锁</strong>。</li>
</ol>
<h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>按锁作用的数据范围进行分类的话，锁可以分为<code>行级锁</code>和<code>表级锁</code>。</p>
<ol>
<li><code>行级锁</code>：作用在数据行上，锁的粒度比较小。</li>
<li><code>表级锁</code>：作用在整张数据表上，锁的粒度比较大。</li>
</ol>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>为了实现<code>读-读</code>之间不受影响，并且<code>写-写</code>、<code>读-写</code>之间能够相互阻塞，<code>Mysql</code>使用了<code>读写锁</code>的思路进行实现，具体来说就是分为了<code>共享锁</code>和<code>排它锁</code>：</p>
<ol>
<li><code>共享锁(Shared Locks)</code>：简称<code>S锁</code>，在事务要读取一条记录时，需要先获取该记录的<code>S锁</code>。<code>S锁</code>可以在同一时刻被多个事务同时持有。我们可以用<code>select ...... lock in share mode;</code>的方式手工加上一把<code>S锁</code>。</li>
<li><code>排他锁(Exclusive Locks)</code>：简称<code>X锁</code>，在事务要改动一条记录时，需要先获取该记录的<code>X锁</code>。<code>X锁</code>在同一时刻最多只能被一个事务持有。<code>X锁</code>的加锁方式有两种，第一种是自动加锁，在对数据进行增删改的时候，都会默认加上一个<code>X锁</code>。还有一种是手工加锁，我们用一个<code>FOR UPDATE</code>给一行数据加上一个<code>X锁</code>。</li>
</ol>
<p>还需要注意的一点是，如果一个事务已经持有了某行记录的<code>S锁</code>，另一个事务是无法为这行记录加上<code>X锁</code>的，反之亦然。</p>
<p>除了<code>共享锁(Shared Locks)</code>和<code>排他锁(Exclusive Locks)</code>，<code>Mysql</code>还有<code>意向锁(Intention Locks)</code>。意向锁是由数据库自己维护的，一般来说，当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加一个<code>意向共享锁(IS锁)</code>；当我们给一行数据加上排他锁之前，数据库会自动在这张表上面加一个<code>意向排他锁(IX锁)</code>。<strong><code>意向锁</code>可以认为是<code>S锁</code>和<code>X锁</code>在数据表上的标识，通过意向锁可以快速判断表中是否有记录被上锁，从而避免通过遍历的方式来查看表中有没有记录被上锁，提升加锁效率</strong>。例如，我们要加表级别的<code>X锁</code>，这时候数据表里面如果存在行级别的<code>X锁</code>或者<code>S锁</code>的，加锁就会失败，此时直接根据<code>意向锁</code>就能知道这张表是否有行级别的<code>X锁</code>或者<code>S锁</code>。</p>
<h3 id="InnoDB中的表级锁"><a href="#InnoDB中的表级锁" class="headerlink" title="InnoDB中的表级锁"></a>InnoDB中的表级锁</h3><p><code>InnoDB</code>中的表级锁主要包括表级别的<code>意向共享锁(IS锁)</code>和<code>意向排他锁(IX锁)</code>以及<code>自增锁(AUTO-INC锁)</code>。其中<code>IS锁</code>和<code>IX锁</code>在前面已经介绍过了，这里不再赘述，我们接下来重点了解一下<code>AUTO-INC锁</code>。</p>
<p>大家都知道，如果我们给某列字段加了<code>AUTO_INCREMENT</code>自增属性，插入的时候不需要为该字段指定值，系统会自动保证递增。系统实现这种自动给<code>AUTO_INCREMENT</code>修饰的列递增赋值的原理主要是两个：</p>
<ol>
<li><code>AUTO-INC锁</code>：在执行插入语句的时先加上表级别的<code>AUTO-INC锁</code>，插入执行完成后立即释放锁。<strong>如果我们的插入语句在执行前无法确定具体要插入多少条记录，比如<code>INSERT ... SELECT</code>这种插入语句，一般采用<code>AUTO-INC锁</code>的方式</strong>。</li>
<li><code>轻量级锁</code>：在插入语句生成<code>AUTO_INCREMENT</code>值时先才获取这个<code>轻量级锁</code>，然后在<code>AUTO_INCREMENT</code>值生成之后就释放<code>轻量级锁</code>。<strong>如果我们的插入语句在执行前就可以确定具体要插入多少条记录，那么一般采用轻量级锁的方式对AUTO_INCREMENT修饰的列进行赋值</strong>。这种方式可以避免锁定表，可以提升插入性能。</li>
</ol>
<blockquote>
<p>mysql默认根据实际场景自动选择加锁方式，当然也可以通过<code>innodb_autoinc_lock_mode</code>强制指定只使用其中一种。</p>
</blockquote>
<h3 id="InnoDB中的行级锁"><a href="#InnoDB中的行级锁" class="headerlink" title="InnoDB中的行级锁"></a>InnoDB中的行级锁</h3><p>前面说过，通过<code>MVCC</code>可以解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>这些读一致性问题，但实际上这只是解决了普通<code>select</code>语句的数据读取问题。事务利用<code>MVCC</code>进行的读取操作称之为<code>快照读</code>，所有普通的<code>SELECT</code>语句在<code>READ COMMITTED</code>、<code>REPEATABLE READ</code>隔离级别下都算是<code>快照读</code>。除了<code>快照读</code>之外，还有一种是<code>锁定读</code>，即在读取的时候给记录加锁，在<code>锁定读</code>的情况下依然要解决<code>脏读</code>、<code>不可重复读</code>、<code>幻读</code>的问题。由于都是在记录上加锁，这些锁都属于<code>行级锁</code>。</p>
<p><strong><code>InnoDB</code>的行锁，是通过锁住索引来实现的，如果加锁查询的时候没有使用过索引，会将整个聚簇索引都锁住，相当于锁表了</strong>。根据锁定范围的不同，行锁可以使用<code>记录锁(Record Locks)</code>、<code>间隙锁(Gap Locks)</code>和<code>临键锁(Next-Key Locks)</code>的方式实现。假设现在有一张表<code>t</code>，主键是<code>id</code>。我们插入了4行数据，主键值分别是 1、4、7、10。接下来我们就以聚簇索引为例，具体介绍三种形式的行锁。</p>
<ul>
<li><p>记录锁(Record Locks)<br>所谓记录，就是指聚簇索引中真实存放的数据，比如上面的1、4、7、10都是记录。<br><img data-src="https://chentianming11.github.io/images/mysql/record.png" alt="Record"><br>显然，记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如<code>select * from t where id =4 for update;</code>就会将<code>id=4</code>的记录锁定。</p>
</li>
<li><p>间隙锁(Gap Locks)<br>间隙指的是两个记录之间逻辑上尚未填入数据的部分，比如上述的(1,4)、(4,7)等。<br><img data-src="https://chentianming11.github.io/images/mysql/gap.png" alt="Gap"><br>同理，间隙锁就是锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个<code>record</code>，此时就会将对应的间隙区间锁定。例如<code>select * from t where id =3 for update;</code>或者<code>select * from t where id &gt; 1 and id &lt; 4 for update;</code>就会将(1,4)区间锁定。</p>
</li>
<li><p>临键锁(Next-Key Locks)<br>临键指的是间隙加上它右边的记录组成的左开右闭区间。比如上述的(1,4]、(4,7]等。<br><img data-src="https://chentianming11.github.io/images/mysql/next-key.png" alt="Next-Key"><br>临键锁就是记录锁(Record Locks)和间隙锁(Gap Locks)的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分<code>record</code>记录，此时锁住的就是临键区间。注意，临键锁锁住的区间会包含最后一个record的右边的临键区间。例如<code>select * from t where id &gt; 5 and id &lt;= 7 for update;</code>会锁住(4,7]、(7,+∞)。mysql默认行锁类型就是<code>临键锁(Next-Key Locks)</code>。当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。</p>
</li>
</ul>
<p><code>间隙锁(Gap Locks)</code>和<code>临键锁(Next-Key Locks)</code>都是用来解决幻读问题的，在<code>已提交读（READ COMMITTED）</code>隔离级别下，<code>间隙锁(Gap Locks)</code>和<code>临键锁(Next-Key Locks)</code>都会失效！</p>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>你真的理解索引吗？从数据结构层面解析mysql索引原理</title>
    <url>/posts/2462378631/</url>
    <content><![CDATA[<p>从《<a href="https://juejin.im/post/6844904190477598733" target="_blank" rel="noopener">mysql存储引擎InnoDB详解，从底层看清InnoDB数据结构</a>》中，我们已经知道了<strong>数据页内各个记录是按主键正序排列并组成了一个单向链表的，并且各个数据页之间形成了双向链表</strong>。在数据页内，通过<code>页目录</code>，根据主键可以快速定位到一条记录。这一章中，我们深入理解一下mysql索引实现。</p>
<a id="more"></a>

<blockquote>
<p>本文主要内容是根据掘金小册《从根儿上理解 MySQL》整理而来。如想详细了解，建议购买掘金小册阅读。</p>
</blockquote>
<h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><p>先回顾一下上一章节中<code>数据页基本结构</code>：<br><img data-src="https://chentianming11.github.io/images/mysql/%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84.webp" alt="数据页基本结构"><br>从上图可以推断出，查询某条记录关键步骤只有2个：</p>
<ol>
<li>定位到数据页</li>
<li>定位到记录</li>
</ol>
<p>如果没有索引，查询某条记录只能先依次遍历数据页，确定记录所在的数据页之后；再从数据页中通过<code>页目录</code>定位到具体的记录，这样做效率肯定是很低的。</p>
<p>为了方便说明，先建一张示例表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE index_demo(</span><br><span class="line">    -&gt;     c1 INT,</span><br><span class="line">    -&gt;     c2 INT,</span><br><span class="line">    -&gt;     c3 CHAR(1),</span><br><span class="line">    -&gt;     PRIMARY KEY(c1)</span><br><span class="line">    -&gt; ) ROW_FORMAT = Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>为了展示便方便，行格式中只展示<code>record_type</code>、<code>next_record</code>和<code>实际各列的值</code>。<br><img data-src="https://chentianming11.github.io/images/mysql/%E8%A1%8C%E6%A0%BC%E5%BC%8F%E7%AE%80%E5%8C%96.webp" alt="行格式简化"><br>把一些记录放到页里边的示意图就是：<br><img data-src="https://chentianming11.github.io/images/mysql/%E8%AE%B0%E5%BD%95%E6%94%BE%E5%88%B0%E9%A1%B5%E9%87%8C%E8%BE%B9%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.webp" alt="记录放到页里边的示意图"></p>
<p>上面提到过，<strong>数据页中的记录是按主键正序排列的</strong>。实际上就是为了能够使用<strong>二分查找法</strong>快速定位一条记录。同理，要想快速定位一个数据页，也得保证各个数据页是按顺序排序的。排序的规则就是<strong>后一个数据页的最小主键必须大于当前数据页的最大主键</strong>。这样实际上就保证了，所有记录的主键都是正序排列的了。</p>
<h3 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h3><p>假设每个数据页最多只能存放3条记录。现在<code>index_demo</code>插入了3条记录 <code>(1, 4, &#39;u&#39;), (3, 9, &#39;d&#39;), (5, 3, &#39;y&#39;)</code>。<br><img data-src="https://chentianming11.github.io/images/mysql/%E5%AD%98%E6%BB%A1%E8%AE%B0%E5%BD%95%E7%9A%84%E6%95%B0%E6%8D%AE%E9%A1%B5.webp" alt="存满记录的数据页"><br>然后，再向<code>index_demo</code>插入一条记录<code>(4, 4, &#39;a&#39;)</code>。由于每个数据页最多只能存放3条记录，并且还要保证所有记录主键是按主键正序排列的。mysql会新建一个页面(假设是页28)，然后将主键值为5的记录移动到页28中，最后再把主键值为4的记录插入到页10中。<br><img data-src="https://chentianming11.github.io/images/mysql/%E9%A1%B5%E5%88%86%E8%A3%82.webp" alt="页分裂"><br>简单来说，<strong>当向一个已经存满记录的数据页插入新记录时，mysql会以新插入记录的位置为界，把当前页面分裂为2个页面，最后再将新记录插入进去</strong>。</p>
<h3 id="mysql索引实现"><a href="#mysql索引实现" class="headerlink" title="mysql索引实现"></a>mysql索引实现</h3><p>假设<code>index_demo</code>已经存在多条记录，数据页结构如下所示：<br><img data-src="https://chentianming11.github.io/images/mysql/%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B01.webp" alt="索引实现"><br>为了能够使用<code>二分法</code>快速查找数据页，我们可以给每个数据页建一个目录项，每个目录项主要包含两部分数据：</p>
<ol>
<li>页的用户记录中最小的主键值，我们用<code>key</code>来表示。</li>
<li>页号，我们用<code>page_no</code>表示。</li>
</ol>
<p><img data-src="https://chentianming11.github.io/images/mysql/%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B02.webp" alt="索引实现"><br>在mysql中，这些目录项其实就是另一类型的数据记录，称为<code>目录项数据记录</code>（record_type=1）,<code>目录项数据记录</code>也是存储在<code>页</code>中的，同一页中的<code>目录项数据记录</code>也可以通过<code>页目录</code>快速定位。<br><img data-src="https://chentianming11.github.io/images/mysql/%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B03.webp" alt="索引实现"></p>
<p>虽然<code>目录项记录</code>基本<strong>只存储了主键值和页号</strong>。但是当表中的数据很多时，一个<code>数据页</code>肯定是无法保存所有的<code>目录项记录</code>的。因此存储<code>目录项记录</code>的<code>数据页</code>实际上可能有很多个。<br><img data-src="https://chentianming11.github.io/images/mysql/%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B04.webp" alt="索引实现"><br>这个时候，我们就需要快速定位存储<code>目录项记录</code>的<code>数据页</code>了。实际上，我们只需要生成<strong>更高级的目录即可，同时保证最高一级的<code>目录项记录</code>的<code>数据页</code>只有一个</strong>。这样就能根据主键从上到下快速定位到一条记录了。<br><img data-src="https://chentianming11.github.io/images/mysql/%E7%B4%A2%E5%BC%95%E5%AE%9E%E7%8E%B05.webp" alt="索引实现"></p>
<p>实际上，上面的结构就是一颗B+树。<strong>实际的用户记录其实都存放在B+树的<code>叶子节点</code>上，而<code>非叶子节点</code>存放的是目录项</strong>。</p>
<h4 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h4><p>上面介绍的索引实际上就是聚簇索引，它有两个特点：</p>
<ol>
<li>使用主键值的大小进行记录和页的排序，这包括三个方面的含义：<ol>
<li>页内的记录是按照主键的大小顺序排成一个单向链表。</li>
<li>各个存放用户记录的页也是根据页中用户记录的主键大小顺序排成一个双向链表。</li>
<li>存放目录项记录的页分为不同的层次，在同一层次中的页也是根据页中目录项记录的主键大小顺序排成一个双向链表。</li>
</ol>
</li>
<li>B+树的叶子节点存储的是完整的用户记录。</li>
</ol>
<p>InnoDB存储引擎会自动根据主键创建聚簇索引。同时，聚簇索引就是InnoDB存储引擎中数据的存储方式（所有的用户记录都存储在了叶子节点），也就是所谓的<strong>索引即数据，数据即索引</strong>。</p>
<h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>在实际场景中，我们更多的是为某个列建立二级索引。实际上，二级索引和聚簇索引实现的原理一样的。主要的区别只有2个：</p>
<ol>
<li>使用<code>索引列的值</code>的大小进行记录和页的排序。</li>
<li>B+树的叶子节点存储的是对应记录的主键值。</li>
</ol>
<p>如图是以<code>c2</code>列建立的二级索引：<br><img data-src="https://chentianming11.github.io/images/mysql/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95.webp" alt="二级索引"></p>
<p>由于B+树的叶子节点存储的是对应记录的主键值。如果我们要查询完成记录的话，在拿到主键之后，再需要再到<code>聚簇索引</code>中查出用户记录，这个过程也叫<code>回表</code>。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>在实际场景中，经常也出现为多个列建立一个索引的情况，这种索引也称为<code>联合索引</code>。<code>联合索引</code>本质上也是二级索引，区别仅仅在于由一个列变为多个列而已。简单来说就是<strong>同时以多个列的大小作为排序规则，也就是同时为多个列建立索引</strong>。比如我们为<code>c2</code>和<code>c3</code>列建立联合索引：</p>
<ol>
<li>先把各个记录和页按照c2列进行排序。</li>
<li>在记录的c2列相同的情况下，采用c3列进行排序。</li>
</ol>
<p><img data-src="https://chentianming11.github.io/images/mysql/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95.webp" alt="联合索引"></p>
<h2 id="InnoDB的B-树索引的注意事项"><a href="#InnoDB的B-树索引的注意事项" class="headerlink" title="InnoDB的B+树索引的注意事项"></a>InnoDB的B+树索引的注意事项</h2><h3 id="根节点不变性"><a href="#根节点不变性" class="headerlink" title="根节点不变性"></a>根节点不变性</h3><p>上面介绍B+树的时候，为了理解方便，采用自下而上的方式介绍。实际上，B+树的形成过程如下：</p>
<ol>
<li>每次为某个表创建<code>B+</code>索引的时候，都会为这个索引创建一个根节点页面。当表中没有记录时，每个B+根节点既没有用户记录，也没有目录项记录。</li>
<li>随后向表中插入用户记录时，先把用户记录存储到根节点中。</li>
<li>当根节点空间用完后，再次插入数据。会将根节点数据复制到一个新页中，再对这个新页进行<code>页分裂</code>操作。此时，根节点自动升级为存储目录项记录的页。</li>
</ol>
<p>可以看出，<strong>一个B+树索引的根节点自诞生之日起，便不会再移动</strong>。</p>
<h3 id="内节点中目录项记录的唯一性"><a href="#内节点中目录项记录的唯一性" class="headerlink" title="内节点中目录项记录的唯一性"></a>内节点中目录项记录的唯一性</h3><p>我们知道B+树索引的内节点中目录项记录的内容是索引列+页号的搭配，但是这个搭配对于二级索引来说有点儿不严谨。为了保证内节点目录项记录的唯一性，目录项还需要存储主键值数据。也就是说，目录项记录的内容包含<code>索引列的值</code>、<code>主键值</code>和<code>页号</code>。<br><img data-src="https://chentianming11.github.io/images/mysql/%E5%86%85%E8%8A%82%E7%82%B9%E4%B8%AD%E7%9B%AE%E5%BD%95%E9%A1%B9%E8%AE%B0%E5%BD%95%E7%9A%84%E5%94%AF%E4%B8%80%E6%80%A7.webp" alt="内节点中目录项记录的唯一性"></p>
<h2 id="MyISAM中的索引方案简单介绍"><a href="#MyISAM中的索引方案简单介绍" class="headerlink" title="MyISAM中的索引方案简单介绍"></a>MyISAM中的索引方案简单介绍</h2><p>我们知道<strong>InnoDB中索引即数据，也就是聚簇索引的那棵B+树的叶子节点中已经把所有完整的用户记录都包含了</strong>，而MyISAM的索引方案虽然也使用树形结构，但是却将<strong>索引和数据分开存储</strong>：</p>
<ul>
<li><code>MyISAM存储引擎</code>把记录按照记录的插入顺序单独存储在<code>数据文件</code>中。这个文件并不划分为若干个数据页，有多少记录就往这个文件中塞多少记录就成了。我们可以通过行号而快速访问到一条记录。<br><img data-src="https://chentianming11.github.io/images/mysql/MyISAM%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6.webp" alt="MyISAM数据文件"></li>
<li><code>MyISAM存储引擎</code>会把索引信息另外存储到<code>索引文件</code>中。<code>MyISAM</code>会单独为表的主键创建一个索引，只不过在<strong>索引的叶子节点中存储的不是完整的用户记录，而是主键值+行号的组合</strong>。也就是先通过索引找到对应的行号，再通过行号去找对应的记录！<br>这一点和<code>InnoDB</code>是完全不相同的，在InnoDB存储引擎中，我们只需要根据主键值对聚簇索引进行一次查找就能找到对应的记录。而在MyISAM中却需要进行一次回表操作，意味着<strong>MyISAM中建立的索引相当于全部都是二级索引</strong>！</li>
<li>如果有需要的话，我们也可以对其它的列分别建立索引或者建立联合索引，原理和InnoDB中的索引差不多，不过在叶子节点处存储的是相应的列+行号。这些索引也全部都是二级索引。</li>
</ul>
<h2 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h2><p>上面介绍了B+索引的原理，接下来介绍如何更好的使用索引。大家都知道索引不是建的越多越好，因为创建索引在空间上和时间上都会付出代价。</p>
<ol>
<li>空间上的代价<br>每创建一个索引，本质上就是要建立一个B+树，创建索引肯定会占用一部分存储空间。</li>
<li>时间上的代价<br>每次对表中的数据进行增删改操作时，都需要去修改各个B+树索引，而B+树索引的记录又是按照<code>索引列的值</code>排序的。每次增删改操作时，不可避免的会破坏原有记录的顺序，所以存储引擎需要额外的时间来进行记录移位、页面分裂等操作来维护记录的顺序。</li>
</ol>
<p>简单来说，<strong>一张表的索引越多，占用的存储空间也会越多，增删改的性能会更差</strong>。</p>
<h3 id="B-树索引适用的条件"><a href="#B-树索引适用的条件" class="headerlink" title="B+树索引适用的条件"></a>B+树索引适用的条件</h3><p>首先创建一张示例表<code>person_info</code>，用来存储人的一些基本信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    phone_number <span class="built_in">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    country <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">KEY</span> idx_name_birthday_phone_number (<span class="keyword">name</span>, birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>简要说明一下：</p>
<ol>
<li><code>id</code>列为主键，自动递增。InnoDB会自动为id列建立聚簇索引。</li>
<li>为<code>name</code>, <code>birthday</code>, <code>phone_number</code>建立了一个联合索引。所以这个二级索引的叶子节点包含了<code>name</code>, <code>birthday</code>, <code>phone_number</code>和<code>id</code>列的值。</li>
</ol>
<p>下面，简要画一下<code>idx_name_birthday_phone_number</code>联合索引的示意图。<br><img data-src="https://chentianming11.github.io/images/mysql/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.webp" alt="联合索引的示意图"><br>从图中可以看出，这个<code>idx_name_birthday_phone_number</code>索引对应的B+树中页面和记录的排序方式就是这样的：</p>
<ol>
<li>先按照<code>name</code>列的值进行排序。</li>
<li>如果<code>name</code>列的值相同，则按照<code>birthday</code>列的值进行排序。</li>
<li>如果<code>birthday</code>列的值也相同，则按照<code>phone_number</code>的值进行排序。</li>
</ol>
<h4 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h4><p>全值匹配指的是<strong>搜索条件中的列和索引列一致</strong>。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> <span class="keyword">AND</span> birthday = <span class="string">'1990-09-27'</span> <span class="keyword">AND</span> phone_number = <span class="string">'15123983239'</span>;</span><br></pre></td></tr></table></figure>

<p>在<code>idx_name_birthday_phone_number</code>联合索引上进行全值匹配的查询过程如下：</p>
<ol>
<li>因为B+树的数据页和记录先是按照<code>name</code>列的值进行排序的，所以先可以很快定位name列的值是<code>Ashburn</code>的记录位置。</li>
<li>在<code>name</code>列相同的记录里又是按照<code>birthday</code>列的值进行排序的，所以在<code>name</code>列的值是<code>Ashburn</code>的记录里又可以快速定位<code>birthday</code>列的值是’1990-09-27’的记录。</li>
<li>如果<code>name</code>和<code>birthday</code>列的值都是相同的，那记录是按照phone_number列的值排序的，<strong>所以联合索引中的三个列都可能被用到</strong>。</li>
</ol>
<h4 id="联合索引最左匹配"><a href="#联合索引最左匹配" class="headerlink" title="联合索引最左匹配"></a>联合索引最左匹配</h4><p>其实在搜索语句中不用包含全部联合索引的列，只包含左边的列也能够使用索引，这就是联合索引的<strong>最左匹配原则</strong>。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> <span class="keyword">AND</span> birthday = <span class="string">'1990-09-27'</span>;</span><br></pre></td></tr></table></figure>

<p><strong>如果我们想使用联合索引中尽可能多的列，搜索条件中的各个列必须是联合索引中从最左边连续的列</strong>。</p>
<h4 id="前缀匹配"><a href="#前缀匹配" class="headerlink" title="前缀匹配"></a>前缀匹配</h4><p><strong>对于字符串类型的索引列来说，我们只匹配它的前缀也是可以快速定位记录的</strong>。因为字符串比较本质上按一个一个字符比较得出的，也就是说这些字符串的前n个字符，也就是前缀都是排好序的。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'As%'</span>;</span><br></pre></td></tr></table></figure>

<p>但是如果只给出后缀或者中间的某个字符串，是无法使用索引的，比如这样：<code>%As</code>或者<code>%As%</code>。如果实际场景中碰到要以字符串后缀查询数据的话，可以考虑<code>逆序存储</code>，将后缀匹配转化为前缀匹配。</p>
<h4 id="范围匹配"><a href="#范围匹配" class="headerlink" title="范围匹配"></a>范围匹配</h4><p>因为索引B+树是按照索引列大小排序的，因此按索引列范围查询可以快速查询出数据记录。比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">'Asa'</span> <span class="keyword">AND</span> <span class="keyword">name</span> &lt; <span class="string">'Barlow'</span>;</span><br></pre></td></tr></table></figure>

<p>由于B+树中的数据页和记录是先按<code>name</code>列排序的，所以我们上边的查询过程其实是这样的：</p>
<ol>
<li>找到name值为<code>Asa</code>的记录。</li>
<li>找到name值为<code>Barlow</code>的记录。</li>
<li>由于叶子节点记录本身是一个链表，直接取出范围之内的记录。</li>
<li>回表查询完整记录。</li>
</ol>
<h4 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h4><p>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精确查找，则右边的列可以进行范围查找，这种场景下依然会使用索引。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> <span class="keyword">AND</span> birthday &gt; <span class="string">'1980-01-01'</span> <span class="keyword">AND</span> birthday &lt; <span class="string">'2000-12-31'</span> <span class="keyword">AND</span> phone_number &gt; <span class="string">'15100000000'</span>;</span><br></pre></td></tr></table></figure>

<p>整个查询过程大致如下：</p>
<ol>
<li><code>name = &#39;Ashburn&#39;</code>，对<code>name</code>列进行精确查找，当然可以使用B+树索引了。</li>
<li><code>birthday &gt; &#39;1980-01-01&#39; AND birthday &lt; &#39;2000-12-31&#39;</code>，由于<code>name</code>列是精确查找，所以通过<code>name = &#39;Ashburn&#39;</code>条件查找后得到的结果的name值都是相同的，它们会再按照<code>birthday</code>的值进行排序。所以此时对<code>birthday</code>列进行范围查找是可以用到B+树索引的。</li>
<li><code>phone_number &gt; &#39;15100000000&#39;</code>，通过<code>birthday</code>的范围查找的记录的<code>birthday</code>的值可能不同，所以这个条件无法再利用B+树索引了，只能遍历上一步查询得到的记录。</li>
</ol>
<h4 id="用于排序"><a href="#用于排序" class="headerlink" title="用于排序"></a>用于排序</h4><p>在实际业务场景中，经常需要对查询出来的结果进行排序。一般情况下，只能将记录全部加载到内存中（结果集太大可能使用磁盘存放中间结果），再使用排序算法排序。这种<strong>在内存中或者磁盘上的排序方式统称为文件排序<code>filesort</code>，性能较差</strong>。但是如果<code>order by</code>子句使用到了索引列，就可能避免<code>filesort</code>。比如下面这个查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> person_info <span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span>, birthday, phone_number <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>这个查询结果依次按<code>name</code>、<code>birthday</code>和<code>phone_number</code>排序，而<code>idx_name_birthday_phone_number</code>B+索引树也刚好是按上述规则排好序的，因此只需要直接从索引中提取数据，然后回表即可。<br>需要注意的是，对于联合索引来说，<code>ORDER BY</code>的子句后边的列的顺序也必须跟索引列的顺序一致，否则排序的时候就无法使用索引了。</p>
<h4 id="用于分组"><a href="#用于分组" class="headerlink" title="用于分组"></a>用于分组</h4><p>有时候我们为了方便统计表中的一些信息，会把表中的记录按照某些列进行分组。比如下边这个分组查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, birthday, phone_number, <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> person_info <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span>, birthday, phone_number</span><br></pre></td></tr></table></figure>

<p>和使用B+树索引进行排序是一个道理，分组列的顺序也需要和索引列的顺序一致，也可以只使用索引列中左边的列进行分组。</p>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>上面提到到，所谓回表就是在二级索引中获取到主键id集合之后，再分别到聚簇索引查询出完整记录，简单来说就是<strong>一次二级索引查询，多次聚簇索引回表</strong>。这意味着<strong>二级索引命中的主键记录越多，需要回表的记录也会也多，整体的性能就会越低</strong>。因此某些查询，宁可使用全表扫描也不使用二级索引。<br>为了更好的使用<code>二级索引+回表</code>的方式进行查询，一般推荐使用<code>limit</code>限制要查询的记录，这样<code>回表</code>的次数也能得到控制。</p>
<p>为了彻底告别回表操作带来的性能损耗，建议：<strong>在查询列表里只包含索引列</strong>，比如这样：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, birthday, phone_number <span class="keyword">FROM</span> person_info <span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">'Asa'</span> <span class="keyword">AND</span> <span class="keyword">name</span> &lt; <span class="string">'Barlow'</span></span><br></pre></td></tr></table></figure>

<p>因为只查询<code>name</code>, <code>birthday</code>, <code>phone_number</code>这三个索引列的值，所以就没必要进行回表操作了。我们把这种<strong>只需要用到索引的查询方式称为覆盖索引</strong>。</p>
<h3 id="如何挑选索引"><a href="#如何挑选索引" class="headerlink" title="如何挑选索引"></a>如何挑选索引</h3><p>上面主要介绍了索引的适用场景，接下来我们介绍下建立索引时或者编写查询语句时就应该注意的一些事项。</p>
<h4 id="只为用于搜索、排序或分组的列创建索引"><a href="#只为用于搜索、排序或分组的列创建索引" class="headerlink" title="只为用于搜索、排序或分组的列创建索引"></a>只为用于搜索、排序或分组的列创建索引</h4><p>只为出现在<code>WHERE</code>子句中的列、连接子句中的连接列，或者出现在ORDER BY或GROUP BY子句中的列创建索引。而出现在查询列表中的列就没必要建立索引了。</p>
<h4 id="考虑列的基数"><a href="#考虑列的基数" class="headerlink" title="考虑列的基数"></a>考虑列的基数</h4><p><code>列的基数</code>指的是某一列中不重复数据的个数。，在记录行数一定的情况下，<strong>列的基数越大，该列中的值越分散，列的基数越小，该列中的值越集中</strong>。因此推荐的方式是<strong>为那些列的基数大的列建立索引</strong>，为基数太小列的建立索引效果可能不好。</p>
<h4 id="索引列的类型尽量小"><a href="#索引列的类型尽量小" class="headerlink" title="索引列的类型尽量小"></a>索引列的类型尽量小</h4><p><strong>在表示的整数范围允许的情况下，尽量让索引列使用较小的类型</strong>。原因如下：</p>
<ol>
<li>数据类型越小，在查询时进行的比较操作越快</li>
<li>数据类型越小，索引占用的存储空间就越少，在一个数据页内就可以放下更多的记录，从而减少磁盘I/O带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li>
</ol>
<h4 id="使用前缀索引"><a href="#使用前缀索引" class="headerlink" title="使用前缀索引"></a>使用前缀索引</h4><p>当字段值比较长的时候，建立索引会消耗很多的空间，搜索起来也会很慢。我们可以通过<strong>截取字段的前面一部分内容建立索引</strong>，这个就叫前缀索引。<br>例如：创建一张商户表，因为地址字段比较长，在地址字段上建立前缀索引:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> shop(address <span class="built_in">varchar</span>(<span class="number">120</span>) <span class="keyword">not</span> <span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>问题是，截取多少呢?截取得多了，达不到节省索引存储空间的目的，截取得少了， 重复内容太多，字段的基数会降低。实际场景中，可以通过不同长度的基数与总记录数据基数的比值，选择一个较为合理的截取长度。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">10</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sub10,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">11</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sub11,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">12</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sub12,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(address,<span class="number">13</span>))/<span class="keyword">count</span>(*) <span class="keyword">as</span> sub13</span><br><span class="line"><span class="keyword">from</span> shop;</span><br></pre></td></tr></table></figure>

<h4 id="避免索引列字段参与计算"><a href="#避免索引列字段参与计算" class="headerlink" title="避免索引列字段参与计算"></a>避免索引列字段参与计算</h4><p><strong>如果索引列在比较表达式中不是以单独列的形式出现，而是以某个表达式，或者函数调用形式出现的话，是用不到索引的</strong>。<br>比如有一个整数列<code>my_col</code>，<code>WHERE my_col * 2 &lt; 4</code>查询是不会使用索引的，而<code>WHERE my_col &lt; 4/2</code>能正常使用索引。</p>
<h4 id="主键插入顺序"><a href="#主键插入顺序" class="headerlink" title="主键插入顺序"></a>主键插入顺序</h4><p>我们知道，对于InnoDB来说，数据实际上是按主键大小正序存储在聚簇索引的叶子节点上的。所以如果我们插入的记录的主键值是依次增大的话，那我们每插满一个数据页就换到下一个数据页继续插入。而如果我们插入的主键值忽大忽小的话，就会造成频繁的<code>页分裂</code>，严重影响性能。因此，为了保证性能，需要保证主键是递增的。</p>
<h3 id="无法使用索引的几种情况"><a href="#无法使用索引的几种情况" class="headerlink" title="无法使用索引的几种情况"></a>无法使用索引的几种情况</h3><ol>
<li><code>ORDER BY</code>的子句后边的列的顺序也必须跟索引列的顺序不一致。</li>
<li><code>ASC</code>、<code>DESC</code>混用</li>
<li>排序列包含非同一个索引的列</li>
<li>排序列使用了复杂的表达式</li>
<li>索引列上使用函数<code>(replace\SUBSTR\CONCAT\sum count avg)、表达式、 计算(+ - * /)</code></li>
<li>like 条件中前面带%</li>
<li>字符串不加引号，出现隐式转换</li>
</ol>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql存储引擎InnoDB详解，从底层看清InnoDB数据结构</title>
    <url>/posts/786374041/</url>
    <content><![CDATA[<p>InnoDB一个支持事务安全的存储引擎，同时也是mysql的默认存储引擎。本文主要从数据结构的角度，详细介绍InnoDB行记录格式和数据页的实现原理，从底层看清InnoDB存储引擎。</p>
<a id="more"></a>

<blockquote>
<p>本文主要内容是根据掘金小册《从根儿上理解 MySQL》整理而来。如想详细了解，建议购买掘金小册阅读。</p>
</blockquote>
<h2 id="InnoDB简介"><a href="#InnoDB简介" class="headerlink" title="InnoDB简介"></a>InnoDB简介</h2><p>大家都知道mysql中数据是存储在物理磁盘上的，而真正的数据处理又是在内存中执行的。由于磁盘的读写速度非常慢，如果每次操作都对磁盘进行频繁读写的话，那么性能一定非常差。为了上述问题，<strong>InnoDB将数据划分为若干页，以页作为磁盘与内存交互的基本单位，一般页的大小为16KB</strong>。这样的话，一次性至少读取1页数据到内存中或者将1页数据写入磁盘。通过减少内存与磁盘的交互次数，从而提升性能。</p>
<p>其实，这本质上就是一种典型的缓存设计思想，一般缓存的设计基本都是从<code>时间维度</code>或者<code>空间维度</code>进行考量的：</p>
<ol>
<li><code>时间维度</code>：如果一条数据正在在被使用，那么在接下来一段时间内大概率还会再被使用。可以认为<code>热点数据缓存</code>都属于这种思路的实现。</li>
<li><code>空间维度</code>：如果一条数据正在在被使用，那么存储在它附近的数据大概率也会很快被使用。<code>InnoDB的数据页</code>和<code>操作系统的页缓存</code>则是这种思路的体现。</li>
</ol>
<h2 id="InnoDB行格式"><a href="#InnoDB行格式" class="headerlink" title="InnoDB行格式"></a>InnoDB行格式</h2><p>mysql是以记录(一行数据)为单位向数据表中插入数据的，这些记录在磁盘上的存放方式称为<code>行格式</code>。mysql支持4种不同类型的行格式：<code>Compact</code>、<code>Redundant</code>（比较老，本文就不具体介绍了）、<code>Dynamic</code>、<code>Compressed</code>。<br>我们可以在创建或修改表的语句中指定行格式：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名 (列的信息) ROW_FORMAT=行格式名称</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 ROW_FORMAT=行格式名称</span><br></pre></td></tr></table></figure>

<p>比如，我们要创建一个行格式为<code>Compact</code>，字符集为<code>ascii</code>的数据表<code>record_format_demo</code>，sql如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE record_format_demo (</span><br><span class="line">    -&gt;     c1 VARCHAR(10),</span><br><span class="line">    -&gt;     c2 VARCHAR(10) NOT NULL,</span><br><span class="line">    -&gt;     c3 CHAR(10),</span><br><span class="line">    -&gt;     c4 VARCHAR(10)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=COMPACT;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<p>假设我们向<code>record_format_demo</code>表中插入了2行数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SELECT * FROM record_format_demo;</span></span><br><span class="line">+------+-----+------+------+</span><br><span class="line">| c1   | c2  | c3   | c4   |</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">| aaaa | bbb | cc   | d    |</span><br><span class="line">| eeee | fff | NULL | NULL |</span><br><span class="line">+------+-----+------+------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<h3 id="COMPACT行格式"><a href="#COMPACT行格式" class="headerlink" title="COMPACT行格式"></a>COMPACT行格式</h3><p><img data-src="https://chentianming11.github.io/images/mysql/compact%E8%A1%8C%E6%A0%BC%E5%BC%8F.webp" alt="COMPACT行格式"></p>
<p>从上图可以看出，一条完整的记录包含<code>记录的额外信息</code>和<code>记录的真实数据</code>两大部分。</p>
<h4 id="记录的额外信息"><a href="#记录的额外信息" class="headerlink" title="记录的额外信息"></a>记录的额外信息</h4><p>记录的额外信息主要包含3类：<code>变长字段长度列表</code>、<code>NULL值列表</code>和<code>记录头信息</code>。</p>
<h5 id="变长字段长度列表"><a href="#变长字段长度列表" class="headerlink" title="变长字段长度列表"></a>变长字段长度列表</h5><p>mysql中支持一些变长数据类型（比如<code>VARCHAR(M)</code>、<code>TEXT</code>等），它们存储数据占用的存储空间不是固定的，而是会随着存储内容的变化而变化。为了准确描述这种数据，这种变长字段占用的存储空间要同时包含：</p>
<ol>
<li>真正的数据内容</li>
<li>占用的字节数</li>
</ol>
<p>在Compact行格式中，把<strong>所有变长字段的真实数据占用的字节长度都存放在记录的开头部位，从而形成一个变长字段长度列表，各变长字段数据占用的字节数按照列的顺序<code>逆序</code>存放</strong>。</p>
<p>我们以<code>record_format_demo</code>第一行数据为例。由于<code>c1</code>、<code>c2</code>和<code>c4</code>都是变成数据类型(<code>VARCHAR(10)</code>),因此要将这3列值得长度保存在记录的开头处。<br><img data-src="https://chentianming11.github.io/images/mysql/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A8.webp" alt="变长字段长度列表"></p>
<p>另外需要注意的一点是，<strong>变长字段长度列表中只存储值为 非NULL 的列内容占用的长度，值为 NULL 的列的长度是不储存的</strong>。也就是说对于第二条记录来说，因为c4列的值为NULL，所以第二条记录的变长字段长度列表只需要存储c1和c2列的长度即可。<br><img data-src="https://chentianming11.github.io/images/mysql/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A82.webp" alt="变长字段长度列表"></p>
<h5 id="NULL值列表"><a href="#NULL值列表" class="headerlink" title="NULL值列表"></a>NULL值列表</h5><p>对于可为NULL的列，为了节约存储空间，mysql不会将<code>NULL</code>值保存在<code>记录的真实数据</code>部分。而是会将其保存在<code>记录的额外信息</code>里面的<code>NULL值列表</code>中。</p>
<p>具体的做法是先统计表中允许存储<code>NULL</code>值的列，然后将每个允许存储<code>NULL</code>值的列对应一个二进制位（1：值为<code>NULL</code>，0：值不为<code>NULL</code>）用来表示是否存储<code>NULL</code>值，并按照逆序排列。MySQL规定<strong>NULL值列表必须用整数个字节的位表示</strong>，如果使用的二进制位个数不是整数个字节，则在字节的高位补0。<br>对应<code>record_format_demo</code>表中，<code>c1</code>、<code>c3</code>、<code>c4</code>都是允许存储NULL值的。前两条记录在填充了<code>NULL</code>值列表后的示意图就是这样：</p>
<p><img data-src="https://chentianming11.github.io/images/mysql/NULL%E5%80%BC%E5%88%97%E8%A1%A8.webp" alt="NULL值列表"></p>
<h5 id="记录头信息"><a href="#记录头信息" class="headerlink" title="记录头信息"></a>记录头信息</h5><p>记录头信息是由固定的5个字节(40位)组成, 不同的位代表不同的含义：<br><img data-src="https://chentianming11.github.io/images/mysql/%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF.webp" alt="记录头信息"><br>暂时不详细展开。</p>
<h3 id="记录的真实数据"><a href="#记录的真实数据" class="headerlink" title="记录的真实数据"></a>记录的真实数据</h3><p>记录的真实数据除了包含各列具体的数据外，还会自动添加一些隐藏列数据。</p>
<table>
<thead>
<tr>
<th>列名</th>
<th>是否必须</th>
<th>占用空间</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>row_id</td>
<td>否</td>
<td>6字节</td>
<td>行ID，唯一标识一条记录</td>
</tr>
<tr>
<td>transaction_id</td>
<td>是</td>
<td>6字节</td>
<td>事务ID</td>
</tr>
<tr>
<td>roll_pointer</td>
<td>是</td>
<td>7字节</td>
<td>回滚指针</td>
</tr>
</tbody></table>
<blockquote>
<p>实际上这几个列的真正名称其实是：DB_ROW_ID、DB_TRX_ID、DB_ROLL_PTR，为了美观才写成了row_id、transaction_id和roll_pointer。</p>
</blockquote>
<p>只有当数据库没有定义<code>主键</code>或者<code>唯一键</code>时，隐藏列<code>row_id</code>才会存在，并且将其作为数据表<code>主键</code>。<br>因为表<code>record_format_demo</code>并没有定义主键，所以MySQL服务器会为每条记录增加上述的3个列。现在看一下加上<code>记录的真实数据</code>的两个记录的数据结构：<br><img data-src="https://chentianming11.github.io/images/mysql/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.webp" alt="记录的真实数据"></p>
<h3 id="CHAR-M-列的存储格式"><a href="#CHAR-M-列的存储格式" class="headerlink" title="CHAR(M)列的存储格式"></a>CHAR(M)列的存储格式</h3><p>对于 CHAR(M) 类型的列来说，当列采用的是定长字符集时，该列占用的字节数不会被加到变长字段长度列表，而<strong>如果采用变长字符集时，该列占用的字节数也会被加到变长字段长度列表</strong>。<br>另外有一点还需要注意，变长字符集的<code>CHAR(M)</code>类型的列要求至少占用<code>M</code>个字节，而<code>VARCHAR(M)</code>却没有这个要求。比方说对于使用<code>utf8</code>字符集的<code>CHAR(10)</code>的列来说，该列存储的数据字节长度的范围是<code>10～30</code>个字节，即使我们向该列中存储一个空字符串也会占用<code>10</code>个字节。</p>
<h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><h4 id="VARCHAR-M-最多能存储的数据"><a href="#VARCHAR-M-最多能存储的数据" class="headerlink" title="VARCHAR(M)最多能存储的数据"></a>VARCHAR(M)最多能存储的数据</h4><p>MySQL对一条记录占用的最大存储空间是有限制的，除了<code>BLOB</code>或者<code>TEXT</code>类型的列之外，<strong>其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节</strong>。可以不严谨的认为，<strong>mysql一行记录占用的存储空间不能超过65535个字节</strong>。这个65535个字节除了列本身的数据之外，还包括一些其他的数据（storage overhead），比如说我们为了存储一个VARCHAR(M)类型的列，其实需要占用3部分存储空间：</p>
<ol>
<li>真实数据</li>
<li>真实数据占用字节的长度</li>
<li>NULL值标识，如果该列有NOT NULL属性则可以没有这部分存储空间</li>
</ol>
<p>假设<code>varchar_size_demo</code>只有一个<code>VARCHAR</code>类型的字段，那么该字段最大占用的65532个字节。因为真实数据的长度可能占用2个字节，<code>NULL值标识</code>需要占用1个字节。如果该<code>VARCHAR</code>类型的列没有<code>NOT NULL</code>属性，那最多只能存储<code>65532</code>个字节的数据。如果该列是<code>ascii</code>字符集，对应的最大字符数最大为<code>65532</code>；如果是<code>utf8</code>字符集，则对应的最大字符数为<code>21844</code>。</p>
<h4 id="记录中的数据太多产生的溢出"><a href="#记录中的数据太多产生的溢出" class="headerlink" title="记录中的数据太多产生的溢出"></a>记录中的数据太多产生的溢出</h4><p>我们以ascii字符集下的<code>varchar_size_demo</code>表为例，插入一条记录：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE varchar_size_demo(</span><br><span class="line">    -&gt;       c VARCHAR(65532)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO varchar_size_demo(c) VALUES(REPEAT('a', 65532));</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br></pre></td></tr></table></figure>

<p>mysql中磁盘与内存交互的基本单位是页，一般为16KB，16384个字节，而一行记录最大可以占用<code>65535</code>个字节，这就造成了<strong>一页存不下一行数据的情况</strong>。在Compact和Redundant行格式中，对于占用存储空间非常大的列，在记录的真实数据处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后记录的真实数据处用20个字节存储指向这些页的地址，从而可以找到剩余数据所在的页，如图所示：<br><img data-src="https://chentianming11.github.io/images/mysql/%E8%A1%8C%E6%BA%A2%E5%87%BA.webp" alt="行溢出数据"><br>这种<strong>在本记录的真实数据处只会存储该列的前768个字节的数据和一个指向其他页的地址，然后把剩下的数据存放到其他页中的情况就叫做<code>行溢出</code>，存储超出768字节的那些页面也被称为<code>溢出页</code></strong>。<br><img data-src="https://chentianming11.github.io/images/mysql/%E8%A1%8C%E6%BA%A2%E5%87%BA%E8%AE%B0%E5%BD%95.webp" alt="行溢出数据"></p>
<h4 id="行溢出的临界点"><a href="#行溢出的临界点" class="headerlink" title="行溢出的临界点"></a>行溢出的临界点</h4><p><strong>MySQL中规定一个页中至少存放两行记录</strong>。以上边的<code>varchar_size_demo</code>表为例，它只有一个列<code>c</code>，我们往这个表中插入两条记录，每条记录最少插入多少字节的数据才会行溢出的现象呢？这得分析一下页中的空间都是如何利用的。</p>
<ol>
<li>每个页除了存放我们的记录以外，也需要存储一些额外的信息，大概132个字节。</li>
<li>每个记录需要的额外信息是27字节。</li>
</ol>
<p>假设一个列中存储的数据字节数为n，如要要保证该列不发生溢出，则需要满足：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">132</span> + <span class="number">2</span>×(<span class="number">27</span> + n) &lt; <span class="number">16384</span></span><br></pre></td></tr></table></figure>

<p>结果是<code>n &lt; 8099</code>。<strong>也就是说如果一个列中存储的数据小于8099个字节，那么该列就不会成为溢出列</strong>。如果表中有多个列，那么这个值更小。</p>
<h3 id="Dynamic和Compressed行格式"><a href="#Dynamic和Compressed行格式" class="headerlink" title="Dynamic和Compressed行格式"></a>Dynamic和Compressed行格式</h3><p>mysql中默认的行格式就是<code>Dynamic</code>。<code>Dynamic</code>和<code>Compressed</code>行格式和<code>Compact</code>行格式很像，只是在处理<code>行溢出</code>数据上有差异。<code>Dynamic</code>和<code>Compressed</code>行格式不会在<code>记录的真实数据</code>出存放前768个字节，而是将所有字节都存储在其它页面中。<code>Compressed</code>行格式会采用压缩算法对页面进行压缩，以节省空间。<br><img data-src="https://chentianming11.github.io/images/mysql/Dynamic%E8%A1%8C%E6%BA%A2%E5%87%BA.webp" alt="Dynamic"></p>
<h2 id="InnoDB数据页结构"><a href="#InnoDB数据页结构" class="headerlink" title="InnoDB数据页结构"></a>InnoDB数据页结构</h2><p>我们已经知道页是InnoDB管理存储空间的基本单位，一个页的大小一般是16KB。InnoDB为了不同的目的设计了许多不同类型的页，我们这里主要关注<code>存储数据记录</code>的页，官方称为<code>索引页</code>。由于还没介绍索引，暂且我们先称为<code>数据页</code>吧。</p>
<h3 id="数据页结构的快速浏览"><a href="#数据页结构的快速浏览" class="headerlink" title="数据页结构的快速浏览"></a>数据页结构的快速浏览</h3><p>数据页在结构上可以划分为多个部分，不同的部分有不同的功能，如下图所示：<br><img data-src="https://chentianming11.github.io/images/mysql/%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.webp" alt="数据页结构"></p>
<p>一个InnoDB数据页被划分为了7个部分，下面大概描述一下这7个部分内容。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>中文名</th>
<th>占用空间大小</th>
<th>简单描述</th>
</tr>
</thead>
<tbody><tr>
<td>File Header</td>
<td>文件头部</td>
<td>38字节</td>
<td>页的一些通用信息</td>
</tr>
<tr>
<td>Page Header</td>
<td>页面头部</td>
<td>56字节</td>
<td>数据页专有的一些信息</td>
</tr>
<tr>
<td>Infimum + Supremum</td>
<td>最小记录和最大记录</td>
<td>26字节</td>
<td>两个虚拟的行记录</td>
</tr>
<tr>
<td>User Records</td>
<td>用户记录</td>
<td>不确定</td>
<td>实际存储的行记录内容</td>
</tr>
<tr>
<td>Free Space</td>
<td>空闲空间</td>
<td>不确定</td>
<td>页中尚未使用的空间</td>
</tr>
<tr>
<td>Page Directory</td>
<td>页面目录</td>
<td>不确定</td>
<td>页中的某些记录的相对位置</td>
</tr>
<tr>
<td>File Trailer</td>
<td>文件尾部</td>
<td>8字节</td>
<td>校验页是否完整</td>
</tr>
</tbody></table>
<h3 id="记录在页中的存储"><a href="#记录在页中的存储" class="headerlink" title="记录在页中的存储"></a>记录在页中的存储</h3><p>用户自己的存储的数据会按照对应的<code>行格式</code>存在<code>User Records</code>中。实际上，新生成的页面是没有<code>User Records</code>的，只有当我们第一次插入数据时，才会从<code>Free Space</code>划一个记录大小的空间给<code>User Records</code>。当<code>Free Space</code>用完之后，就意味着当前的数据页也使用完了。<br><img data-src="https://chentianming11.github.io/images/mysql/%E8%AE%B0%E5%BD%95%E5%9C%A8%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8.webp" alt="记录在页中的存储"><br>为了能够将<code>User Records</code>讲清楚，我们先得理解前面提到的<code>记录头信息</code>。</p>
<h4 id="理解记录头信息"><a href="#理解记录头信息" class="headerlink" title="理解记录头信息"></a>理解记录头信息</h4><p>先简单介绍一下记录头信息各属性描述：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>大小（单位：bit）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>预留位1</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>预留位2</td>
<td>1</td>
<td>没有使用</td>
</tr>
<tr>
<td>delete_mask</td>
<td>1</td>
<td>标记该记录是否被删除</td>
</tr>
<tr>
<td>min_rec_mask</td>
<td>1</td>
<td>B+树的每层非叶子节点中的最小记录都会添加该标记</td>
</tr>
<tr>
<td>n_owned</td>
<td>4</td>
<td>表示当前记录拥有的记录数</td>
</tr>
<tr>
<td>heap_no</td>
<td>13</td>
<td>表示当前记录在记录堆的位置信息</td>
</tr>
<tr>
<td>record_type</td>
<td>3</td>
<td>表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录</td>
</tr>
<tr>
<td>next_record</td>
<td>16</td>
<td>表示下一条记录的相对位置</td>
</tr>
</tbody></table>
<p>接下来以<code>page_demo</code>表为例，并插入一些数据,详细介绍记录头信息。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE page_demo(</span><br><span class="line">    -&gt;     c1 INT,</span><br><span class="line">    -&gt;     c2 INT,</span><br><span class="line">    -&gt;     c3 VARCHAR(10000),</span><br><span class="line">    -&gt;     PRIMARY KEY (c1)</span><br><span class="line">    -&gt; ) CHARSET=ascii ROW_FORMAT=Compact;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; INSERT INTO page_demo VALUES(1, 100, 'aaaa'), (2, 200, 'bbbb'), (3, 300, 'cccc'), (4, 400, 'dddd');</span><br><span class="line">Query OK, 4 rows affected (0.00 sec)</span><br><span class="line">Records: 4  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<p>这4条记录在InnoDB中的行格式如下（只展示记录头和真实数据），列中数据均用十进制表示：<br><img data-src="https://chentianming11.github.io/images/mysql/%E7%90%86%E8%A7%A3%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF1.webp" alt="记录头"><br>我们对照着这个图来重点介绍几个属性的详细信息：</p>
<ul>
<li><code>delete_mask</code>：标记着当前记录是否被删除，0表示未删除，1表示删除。未删除的记录不会立即从磁盘上移除，而是先打上删除标记，所有被删除的记录会组成一个<code>垃圾链表</code>。之后新插入的记录可能会重用<code>垃圾链表</code>占用的空间，因此垃圾链表占用的存储空间也被成为<code>可重用空间</code>。</li>
<li><code>heap_no</code>：表示当前记录在本页中的位置，比如上边4条记录在本页中的位置分别是<code>2、3、4、5</code>。实际上，InnoDB会自动为每页加上两条虚拟记录，一条是<code>最小记录</code>，另一条是<code>最大记录</code>。这两条记录的构造十分简单，都是由<code>5字节大小的记录头信息</code>和<code>8字节大小的固定部分</code>(其实内容就是infimum或者supremum)组成的。这两条记录被单独放在<code>Infimum + Supremum</code>的部分。<br><img data-src="https://chentianming11.github.io/images/mysql/%E7%90%86%E8%A7%A3%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF2.webp" alt="heap_no"><br>从图中我们可以看出来，最小记录和最大记录的<code>heap_no</code>值分别是0和1，也就是说它们的位置最靠前。</li>
<li><code>next_record</code>：表示从<strong>当前记录的真实数据到下一条记录的真实数据的地址偏移量</strong>。可以简单理解为是一个单向链表，最小记录的下一个是第一条记录，最后一条记录的下一个是最大记录。为了更加形象的展示，我们可以用箭头来替代一下next_record中的地址偏移量：<br><img data-src="https://chentianming11.github.io/images/mysql/%E7%90%86%E8%A7%A3%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF3.webp" alt="next_record"><br>从图中也能看出来，<strong>用户记录实际上按照主键大小正序排序行成一个单向链表</strong>。如果从中删除掉一条记录，这个链表也是会跟着变化的，比如我们把第2条记录删掉：<br><img data-src="https://chentianming11.github.io/images/mysql/%E7%90%86%E8%A7%A3%E8%AE%B0%E5%BD%95%E5%A4%B4%E4%BF%A1%E6%81%AF4.webp" alt="next_record"><ul>
<li>第2条记录并没有从存储空间中移除，而是把该条记录的<code>delete_mask</code>值设置为1。</li>
<li>第2条记录的<code>next_record</code>值变为了0，意味着该记录没有下一条记录了。</li>
<li>第1条记录的<code>next_record</code>指向了第3条记录。</li>
</ul>
</li>
</ul>
<h3 id="Page-Directory（页目录）"><a href="#Page-Directory（页目录）" class="headerlink" title="Page Directory（页目录）"></a>Page Directory（页目录）</h3><p>我们已经知道，记录在页中按照主键大小正序串联成了一个单链表。如果我们要根据主键查找具体的某条记录应该怎么办，简单的方式是根据链表进行遍历。但是在数据量比较大的情况下，这种方式显然效率太差了。因此mysql使用了<code>Page Directory（页目录）</code>来解决这个问题。<code>Page Directory（页目录）</code>大致的原理如下：</p>
<ol>
<li>将所有正常的记录（包括最大和最小记录，不包括标记为已删除的记录）划分为几个组。怎么划分先不关注。</li>
<li>每个组的最后一条记录（也就是组内最大的那条记录）的头信息中的n_owned属性表示该组内共有几条记录。</li>
<li>将每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到靠近页尾部的地方，这个地方就是所谓的<code>Page Directory</code>。</li>
</ol>
<p><strong>mysql规定对于最小记录所在的分组只能有 1 条记录，最大记录所在的分组拥有的记录条数只能在 1-8 条之间，剩下的分组中记录的条数范围只能在是 4-8 条之间</strong>。<br>比方说现在的<code>page_demo</code>表中正常的记录共有18条，InnoDB会把它们分成5组，第一组中只有一个最小记录，如下所示：<br><img data-src="https://chentianming11.github.io/images/mysql/%E9%A1%B5%E7%9B%AE%E5%BD%95.webp" alt="Page Directory"></p>
<p>通过<code>Page Directory</code>在一个数据页中查找指定主键值的记录的过程分为两步：</p>
<ol>
<li><strong>通过二分法确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录。</strong></li>
<li><strong>通过记录的<code>next_record</code>属性遍历该槽所在的组中的各个记录。</strong></li>
</ol>
<blockquote>
<p>对于链表的查询性能优化，思想上基本上都是通过<code>二分法</code>实现的。上面介绍的<code>Page Directory</code>，<code>跳跃表</code>和<code>查找树</code>都是如此。</p>
</blockquote>
<h3 id="Page-Header（页面头部）"><a href="#Page-Header（页面头部）" class="headerlink" title="Page Header（页面头部）"></a>Page Header（页面头部）</h3><p><code>Page Header</code>专门用来存储数据页相关的各种状态信息，比如本页中已经存储了多少条记录，第一条记录的地址是什么，页目录中存储了多少个槽等等。固定占用56个字节，各部分字节属性含义如下：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PAGE_N_DIR_SLOTS</td>
<td>2字节</td>
<td>在页目录中的槽数量</td>
</tr>
<tr>
<td>PAGE_HEAP_TOP</td>
<td>2字节</td>
<td>还未使用的空间最小地址，也就是说从该地址之后就是<code>Free Space</code></td>
</tr>
<tr>
<td>PAGE_N_HEAP</td>
<td>2字节</td>
<td>本页中的记录的数量（包括最小和最大记录以及标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_FREE</td>
<td>2字节</td>
<td>第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录可以被重新利用）</td>
</tr>
<tr>
<td>PAGE_GARBAGE</td>
<td>2字节</td>
<td>已删除记录占用的字节数</td>
</tr>
<tr>
<td>PAGE_LAST_INSERT</td>
<td>2字节</td>
<td>最后插入记录的位置</td>
</tr>
<tr>
<td>PAGE_DIRECTION</td>
<td>2字节</td>
<td>最后一条记录插入的方向</td>
</tr>
<tr>
<td>PAGE_N_DIRECTION</td>
<td>2字节</td>
<td>一个方向连续插入的记录数量，如果最后一条记录的插入方向改变了的话，这个状态的值会被清零重新统计。</td>
</tr>
<tr>
<td>PAGE_N_RECS</td>
<td>2字节</td>
<td>该页中记录的数量（不包括最小和最大记录以及被标记为删除的记录）</td>
</tr>
<tr>
<td>PAGE_MAX_TRX_ID</td>
<td>8字节</td>
<td>修改当前页的最大事务ID，该值仅在二级索引中定义</td>
</tr>
<tr>
<td>PAGE_LEVEL</td>
<td>2字节</td>
<td>当前页在B+树中所处的层级</td>
</tr>
<tr>
<td>PAGE_INDEX_ID</td>
<td>8字节</td>
<td>索引ID，表示当前页属于哪个索引</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_LEAF</td>
<td>10字节</td>
<td>B+树叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
<tr>
<td>PAGE_BTR_SEG_TOP</td>
<td>10字节</td>
<td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td>
</tr>
</tbody></table>
<p>这里只是罗列出来，暂时不需要全部理解。</p>
<h3 id="File-Header（文件头部）"><a href="#File-Header（文件头部）" class="headerlink" title="File Header（文件头部）"></a>File Header（文件头部）</h3><p><code>File Header</code>是用来描述各种页都适用的一些通用信息的，由以下内容组成：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>占用空间大小</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_SPACE_OR_CHKSUM</td>
<td>4字节</td>
<td>页的校验和（checksum值）</td>
</tr>
<tr>
<td>FIL_PAGE_OFFSET</td>
<td>4字节</td>
<td>页号</td>
</tr>
<tr>
<td>FIL_PAGE_PREV</td>
<td>4字节</td>
<td>上一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_NEXT</td>
<td>4字节</td>
<td>下一个页的页号</td>
</tr>
<tr>
<td>FIL_PAGE_LSN</td>
<td>8字节</td>
<td>页面被最后修改时对应的日志序列位置（英文名是：Log Sequence Number）</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE</td>
<td>2字节</td>
<td>该页的类型</td>
</tr>
<tr>
<td>FIL_PAGE_FILE_FLUSH_LSN</td>
<td>8字节</td>
<td>仅在系统表空间的一个页中定义，代表文件至少被刷新到了对应的LSN值</td>
</tr>
<tr>
<td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td>
<td>4字节</td>
<td>页属于哪个表空间</td>
</tr>
</tbody></table>
<p>这里只是罗列出来，暂时不需要全部理解。我们重点关注一下几个属性：</p>
<ol>
<li><code>FIL_PAGE_SPACE_OR_CHKSUM</code><br>当前页面的校验和（checksum）。对于一个很长的字节串来说，我们可以通过某种算法来计算一个比较短的值来代表这个很长的字节串，这个比较短的值就称为<code>校验和</code>。通过<code>校验和</code>可以大幅度提升字符串等值比较的效率。</li>
<li><code>FIL_PAGE_OFFSET</code><br>每一个页都有一个唯一的页号，<code>InnoDB</code>通过页号来可以定位一个页。</li>
<li><code>FIL_PAGE_TYPE</code><br>代表当前页的类型，我们前边说过，InnoDB为了不同的目的而把页分为不同的类型。<table>
<thead>
<tr>
<th>类型名称</th>
<th>十六进制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>FIL_PAGE_TYPE_ALLOCATED</td>
<td>0x0000</td>
<td>最新分配，还没使用</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_ALLOCATED</td>
<td>0x0000</td>
<td>最新分配，还没使用</td>
</tr>
<tr>
<td>FIL_PAGE_UNDO_LOG</td>
<td>0x0002</td>
<td>Undo日志页</td>
</tr>
<tr>
<td>FIL_PAGE_INODE</td>
<td>0x0003</td>
<td>段信息节点</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_FREE_LIST</td>
<td>0x0004</td>
<td>Insert Buffer空闲列表</td>
</tr>
<tr>
<td>FIL_PAGE_IBUF_BITMAP</td>
<td>0x0005</td>
<td>Insert Buffer位图</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_SYS</td>
<td>0x0006</td>
<td>系统页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_TRX_SYS</td>
<td>0x0007</td>
<td>事务系统数据</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_FSP_HDR</td>
<td>0x0008</td>
<td>表空间头部信息</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_XDES</td>
<td>0x0009</td>
<td>扩展描述页</td>
</tr>
<tr>
<td>FIL_PAGE_TYPE_BLOB</td>
<td>0x000A</td>
<td>溢出页</td>
</tr>
<tr>
<td>FIL_PAGE_INDEX</td>
<td>0x45BF</td>
<td>索引页，也就是我们所说的数据页</td>
</tr>
</tbody></table>
</li>
<li><code>FIL_PAGE_PREV</code>和F<code>IL_PAGE_NEXT</code><br>表示本页的上一个和下一个页的页号，各个页通过<code>FIL_PAGE_PREV</code>和F<code>IL_PAGE_NEXT</code>形成双向链表。<br><img data-src="https://chentianming11.github.io/images/mysql/%E6%96%87%E4%BB%B6%E5%A4%B4%E9%83%A8.webp" alt="FIL_PAGE_PREV"></li>
</ol>
<h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><p>mysql中内存和磁盘的基本交互单位是页。如果内存中页被修改了，那么某个时刻一定会将内存页同步到磁盘中。如果在同步的过程中，系统出现问题，就可能导致磁盘中的页数据没能完全同步，也就是发生了<code>脏页</code>的情况。为了避免发生这种问题，mysql在每个页的尾部加上了<code>File Trailer</code>来校验页的完整性。<code>File Trailer</code>由8个字节组成：</p>
<ol>
<li>前4个字节代表页的校验和<br>这个部分是和File Header中的校验和相对应的。简单理解，就是<code>File Header</code>和<code>File Trailer</code>都有校验和，如果两者一致则表示数据页是完整的。否则，则表示数据页是<code>脏页</code>。</li>
<li>后4个字节代表页面被最后修改时对应的日志序列位置（LSN）<br>这个部分也是为了校验页的完整性的，暂不详细了解。</li>
</ol>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql进阶知识点，启动项、系统变量、字符集介绍！</title>
    <url>/posts/2624407690/</url>
    <content><![CDATA[<p>mysql数据库是当前应用最为的广泛的数据库，在实际工作中也经常接触到。真正用好mysql也不仅仅是会写sql就行，更重要的是真正理解其内部的工作原理。本文先从宏观角度介绍一些mysql相关的知识点，目的是为了让大家对mysql能有一个大体上的认知，后续再逐一对每个知识点的进行深入解读。</p>
<a id="more"></a>

<blockquote>
<p>本文主要内容是根据掘金小册《从根儿上理解 MySQL》整理而来。如想详细了解，建议购买掘金小册阅读。</p>
</blockquote>
<h2 id="通信方式"><a href="#通信方式" class="headerlink" title="通信方式"></a>通信方式</h2><p>mysql采用了典型的<strong>客户端/服务器架构(C/S架构)</strong>模式。对于计算机而言，数据库客户端程序和服务器程序分别运在不同的进程中。所以客户端进程向服务器进程发送sql请求并得到返回结果的过程本质上就是<strong>进程间通信</strong>。mysql支持的进程间通信方式包括<code>TCP/IP</code>、<code>命名管道</code>、<code>共享内存</code>、<code>unix域套接字文件</code>。</p>
<ol>
<li><code>TCP/IP</code>: <strong>如果服务端进程和客户端进程运行在不同的主机中，只能通过<code>TCP/IP</code>网络通信协议进行通信</strong>。mysql服务器启动时监听某个端口(默认3306)，等待客户端进程来连接。当然，服务端进程和客户端进程在同一主机中，通过本机回环地址(127.0.0.1)也是可以使用<code>TCP/IP</code>进行通信的。</li>
<li><code>命名管道或共享内存</code>: <strong>如果服务端进程和客户端进程都运行在一台windows主机上，可以通过命名管道或共享内存方式进行通信</strong>。<ol>
<li>使用<code>命名管道</code>来进行进程间通信： 需要在启动服务器程序的命令中加上<code>--enable-named-pipe</code>参数，然后在启动客户端程序的命令中加入<code>--pipe</code>或者<code>--protocol=pipe</code>参数。</li>
<li>使用<code>共享内存</code>来进行进程间通信: 需要在启动服务器程序的命令中加上<code>--shared-memory</code>参数，在成功启动服务器后，共享内存便成为本地客户端程序的默认连接方式，不过我们也可以在启动客户端程序的命令中加入<code>--protocol=memory</code>参数来显式的指定使用共享内存进行通信。</li>
</ol>
</li>
<li><code>Unix域套接字文件</code>: 如果我们的服务器进程和客户端进程都运行在同一台操作系统为类Unix的机器上的话，我们可以使用Unix域套接字文件来进行进程间通信。</li>
</ol>
<p>真实环境中，服务器和客户端基本都是运行在不同主机中的，它们之间采用的通信方式就是<code>TCP/IP</code>。</p>
<h2 id="一条查询sql的基本处理过程"><a href="#一条查询sql的基本处理过程" class="headerlink" title="一条查询sql的基本处理过程"></a>一条查询sql的基本处理过程</h2><p>不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：<strong>客户端向服务器发送一段文本（sql语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）</strong>。下面以查询sql为例，简单说明一下服务器处理客户端请求的大致处理过程。</p>
<p><img data-src="https://chentianming11.github.io/images/mysql/mysql%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.webp" alt="mysql基本处理过程"></p>
<p>从图中我们可以看出，服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是<code>连接管理</code>、<code>解析与优化</code>、<code>存储引擎</code>。</p>
<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>每当有一个客户端连接到服务器时，服务器都会创建一个线程来专门处理与这个客户端的交互。在客户端程序发起连接的时候，需要携带主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。<br>当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送请求，MySQL服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理才能将最后的处理结果返回客户端。</p>
<h3 id="解析与优化"><a href="#解析与优化" class="headerlink" title="解析与优化"></a>解析与优化</h3><p>到现在为止，MySQL服务器已经获得了文本形式的请求，接着还需要经过<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>等进行处理。</p>
<h4 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a>查询缓存</h4><p>如果服务器开启了查询缓存，在执行查询的时候会先从查询缓存中获取查询结果。如果命中缓存则直接返回结果，否则接着执行。mysql不推荐使用查询缓存，并且在8.0版本已经移除此功能。真实环境中也不会使用，因此不用详细了解。</p>
<h4 id="语法解析"><a href="#语法解析" class="headerlink" title="语法解析"></a>语法解析</h4><p>这一步主要做的事情是对语句基于<code>SQL语法</code>进行词法和语法分析和语义的解析，将要查询的表、各种查询条件都提取出来放到MySQL服务器内部使用的一些数据结构上来。</p>
<h4 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h4><p>因为我们写的MySQL语句执行起来效率可能并不是很高，MySQL的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接等等。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序等。我们可以使用<code>EXPLAIN</code>语句来查看某个语句的执行计划。</p>
<h3 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h3><p>mysql数据是保存在<code>数据表</code>里面，但表只是逻辑上的概念，数据真正是保存在物理磁盘上的。存储引擎负责的就是物理上数据的保存和提取。为了实现不同的功能，MySQL提供了各式各样的存储引擎，不同存储引擎在物理上的存储结构存在一些差异。但是不同的存储引擎提供了统一的调用接口（也就是存储引擎API）。</p>
<p>mysql支持多种存储引擎，可以通过如下命令查看：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span> ;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://chentianming11.github.io/images/mysql/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E.png" alt="mysql储存引擎"></p>
<p><strong>虽然支持的存储引擎很多，但是我们需要重点关注InnoDB以及适当了解MyISAM存储引擎即可！</strong></p>
<p>为了管理方便，人们把<code>连接管理</code>、<code>查询缓存</code>、<code>语法解析</code>、<code>查询优化</code>这些并不涉及真实数据存储的功能划分为<code>MySQL server</code>的功能，把真实存取数据的功能划分为<code>存储引擎</code>的功能。</p>
<h2 id="启动选项和系统变量"><a href="#启动选项和系统变量" class="headerlink" title="启动选项和系统变量"></a>启动选项和系统变量</h2><p>mysql程序(包括服务器相关程序和客户端相关程序)在启动的时候可以指定启动参数，来控制程序启动后的行为。这些启动参数可以放在命令行中指定，也可以把它们放在配置文件中指定。</p>
<h3 id="在命令行上使用启动选项"><a href="#在命令行上使用启动选项" class="headerlink" title="在命令行上使用启动选项"></a>在命令行上使用启动选项</h3><p>启动mysql程序的命令行后边指定启动选项的通用格式如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--启动选项1[=值1] --启动选项2[=值2] ... --启动选项n[=值n]</span><br></pre></td></tr></table></figure>

<p>各个启动选项之间使用空白字符隔开，在每一个启动选项名称前边添加<code>--</code>。对于不需要值的启动选项，比方说<code>skip-networking</code>，它们就不需要指定对应的值。对于需要指定值的启动选项，比如<code>default-storage-engine</code>我们在指定这个设置项的时候需要显式的指定它的值，比方说<code>InnoDB</code>、<code>MyISAM</code>。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysqld --default-storage-engine=MyISAM --skip-networking</span><br></pre></td></tr></table></figure>

<p>比如上面的启动项就表示默认存储引擎为<code>MyISAM</code>，并且禁止使用<code>TCP/IP</code>方式通信。</p>
<p>为了使用的方便，对于一些常用的选项提供了短形式，比如：</p>
<table>
<thead>
<tr>
<th>长形式</th>
<th>短形式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>–host</td>
<td>-h</td>
<td>主机名</td>
</tr>
<tr>
<td>–user</td>
<td>-u</td>
<td>用户名</td>
</tr>
<tr>
<td>–password</td>
<td>-p</td>
<td>密码</td>
</tr>
<tr>
<td>–port</td>
<td>-P</td>
<td>主机名</td>
</tr>
<tr>
<td>–host</td>
<td>-h</td>
<td>端口</td>
</tr>
</tbody></table>
<h3 id="配置文件中使用选项"><a href="#配置文件中使用选项" class="headerlink" title="配置文件中使用选项"></a>配置文件中使用选项</h3><p>相比于使用命令行的方式设置启动选项，mysql更推荐使用配置文件来设置启动选项。我们把需要设置的启动选项都写在这个配置文件中，每次启动服务器的时候都从这个文件里加载相应的启动选项。</p>
<p>MySQL程序在启动时会寻找多个路径下的配置文件，这些路径有的是固定的，有的是可以在命令行指定的。根据操作系统的不同，配置文件的路径也有所不同，并且越后面路径下的配置优先级越好。总之就是多个路径下都可以存在配置文件，并且有个优先级的关系。这里就不展开了。</p>
<h4 id="配置文件的内容"><a href="#配置文件的内容" class="headerlink" title="配置文件的内容"></a>配置文件的内容</h4><p>与在命令行中指定启动选项不同的是，配置文件中的启动选项被划分为若干个组，每个组有一个组名，用中括号<code>[]</code>扩起来，像这样：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[server]</span></span><br><span class="line"><span class="attr">(具体的启动选项...)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysqld]</span></span><br><span class="line"><span class="attr">(具体的启动选项...)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysqld_safe]</span></span><br><span class="line"><span class="attr">(具体的启动选项...)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[client]</span></span><br><span class="line"><span class="attr">(具体的启动选项...)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysql]</span></span><br><span class="line"><span class="attr">(具体的启动选项...)</span></span><br><span class="line"></span><br><span class="line"><span class="attr">[mysqladmin]</span></span><br><span class="line"><span class="attr">(具体的启动选项...)</span></span><br></pre></td></tr></table></figure>

<p>启动mysql程序时，会使用对应的一个或多个组下的启动选项。每个组下边可以定义若干个启动选项，我们以<code>[server]</code>组为例来看一下填写启动选项的形式（其他组中启动选项的形式是一样的）：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">[server]</span></span><br><span class="line"><span class="attr">option1</span>     <span class="string">#这是option1，该选项不需要选项值</span></span><br><span class="line"><span class="attr">option2</span> = <span class="string">value2      #这是option2，该选项需要选项值</span></span><br></pre></td></tr></table></figure>

<h3 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h3><p><strong>mysql系统变量是指能够影响服务器程序运行行为的变量</strong>。比如允许同时连入的客户端数量由系统变量<code>max_connections</code>控制，表的默认存储引擎由系统变量<code>default_storage_engine</code>控制。每个系统变量都有一个默认值，我们可以使用命令行或者配置文件中的选项在启动服务器时改变一些系统变量的值，或者在运行时动态修改(大多数系统变量支持动态修改)。</p>
<h4 id="作用范围"><a href="#作用范围" class="headerlink" title="作用范围"></a>作用范围</h4><p>多个客户端程序可以同时连接到一个服务器程序。对于同一个系统变量，我们有时想让不同的客户端有不同的值，mysql通过<strong>系统变量的作用范围</strong>来解决上述问题。具体来说作用范围分为下面两种：</p>
<ol>
<li><code>GLOBAL</code>：全局变量，影响服务器的整体操作。</li>
<li><code>SESSION</code>：会话变量，影响某个客户端连接的操作。（注：<code>SESSION</code>有个别名叫<code>LOCAL</code>）</li>
</ol>
<p>很显然，通过启动选项设置的系统变量的作用范围都是<code>GLOBAL</code>的，也就是对所有客户端都有效的。通过客户端动态修改系统变量语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> [<span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span>] 系统变量名 = 值;</span><br></pre></td></tr></table></figure>

<p><strong>如果在设置系统变量的语句中省略了作用范围，默认的作用范围就是SESSION。</strong>同理，我们可以使用下列命令查看MySQL服务器程序支持的系统变量以及它们的当前值：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span>] <span class="keyword">VARIABLES</span> [<span class="keyword">LIKE</span> 匹配的模式];</span><br></pre></td></tr></table></figure>

<h3 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h3><p><strong>mysql状态变量是指描述服务器运行状态的变量，</strong>比方说<code>Threads_connected</code>表示当前有多少客户端与服务器建立了连接。</p>
<p>由于状态变量是用来显示服务器程序运行状况的，所以<strong>它们的值只能由服务器程序自己来设置（对客户端而言是只读的）</strong>。与系统变量类似，状态变量也有<code>GLOBAL</code>和<code>SESSION</code>两个作用范围的，所以查看状态变量的语句可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> [<span class="keyword">GLOBAL</span>|<span class="keyword">SESSION</span>] <span class="keyword">STATUS</span> [<span class="keyword">LIKE</span> 匹配的模式];</span><br></pre></td></tr></table></figure>

<h2 id="mysql支持的字符集和比较规则"><a href="#mysql支持的字符集和比较规则" class="headerlink" title="mysql支持的字符集和比较规则"></a>mysql支持的字符集和比较规则</h2><p>在计算机中，数据最终都是以二进制的形式保存的。因此，如果我们要保存字符串，首先就先得确定字符串中的每个字符对应的二进制数据是什么，然后再将这些二进制数据保存到计算机中。将一个字符映射成一个二进制数据的过程也叫做<code>编码</code>，将一个二进制数据映射到一个字符的过程叫做<code>解码</code>。</p>
<p>使用字符集可以解决数据存储的问题，但是无法完全解决字符之间相互比较的问题。简单场景下，我们可以直接通过比较字符的二进制数据来判断大小，这种方式其实就是<code>二进制比较规则</code>。而有些场景下，<code>二进制比较规则</code>并不适用，比如忽略大小写的时候。因此<strong>为了应对不同的场景，同一种字符集可以有多种比较规则</strong>。</p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>mysql中支持很多种字符集，可以通过以下语句查看：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">CHARSET</span> [<span class="keyword">LIKE</span> 匹配的模式];</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW CHARSET;</span></span><br><span class="line">+----------+---------------------------------+---------------------+--------+</span><br><span class="line">| Charset  | Description                     | Default collation   | Maxlen |</span><br><span class="line">+----------+---------------------------------+---------------------+--------+</span><br><span class="line">| utf8     | UTF-8 Unicode                   | utf8_general_ci     |      3 |</span><br><span class="line">| ucs2     | UCS-2 Unicode                   | ucs2_general_ci     |      2 |</span><br><span class="line">...</span><br><span class="line">| latin7   | ISO 8859-13 Baltic              | latin7_general_ci   |      1 |</span><br><span class="line">| utf8mb4  | UTF-8 Unicode                   | utf8mb4_general_ci  |      4 |</span><br><span class="line">| utf16    | UTF-16 Unicode                  | utf16_general_ci    |      4 |</span><br><span class="line">| utf16le  | UTF-16LE Unicode                | utf16le_general_ci  |      4 |</span><br><span class="line">...</span><br><span class="line">+----------+---------------------------------+---------------------+--------+</span><br><span class="line">41 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Charset</code>: 字符集名称</li>
<li><code>Description</code>: 字符集描述</li>
<li><code>Default collation</code>: 默认的比较规则</li>
<li><code>Maxlen</code>: 一个字符最大占用的字节数。对于采用<code>变长编码方式</code>的字符集而言，一个字符占用的字节数不是固定的。比如在<code>GB2312字符集</code>中，一个字母只占用1个字节，而一个汉字占用了2个字节。</li>
</ol>
<p>在mysql中，<code>utf8</code>和<code>utf8mb4</code>的区别就在于1个字符占用的最大字节数不同。<code>utf8</code>一个字符占用1-3个字节，而<code>utf8mb4</code>一个字符占用1-4个字节。实际上，mysql的<code>utf8</code>是<code>utf8mb3</code>的别名。如果需要保存一些占用4个字节的特殊字符(比如emoji表情)，建议使用<code>utf8mb4</code>字符集。</p>
<h3 id="比较规则"><a href="#比较规则" class="headerlink" title="比较规则"></a>比较规则</h3><p>可以通过以下语句查看mysql中支持的比较规则：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLLATION</span> [<span class="keyword">LIKE</span> 匹配的模式];</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> SHOW COLLATION LIKE <span class="string">'utf8\_%'</span>;</span></span><br><span class="line">+--------------------------+---------+-----+---------+----------+---------+</span><br><span class="line">| Collation                | Charset | Id  | Default | Compiled | Sortlen |</span><br><span class="line">+--------------------------+---------+-----+---------+----------+---------+</span><br><span class="line">| utf8_general_ci          | utf8    |  33 | Yes     | Yes      |       1 |</span><br><span class="line">| utf8_bin                 | utf8    |  83 |         | Yes      |       1 |</span><br><span class="line">...</span><br><span class="line">+--------------------------+---------+-----+---------+----------+---------+</span><br><span class="line">27 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>

<ol>
<li><code>Collation</code>: 比较规则名称，基本符合<code>字符集名称_语言_后缀</code>模式。第一部分<code>字符集名称</code>就是与其关联的字符集的名称开头，第二部分表示该比较规则作用的语言，比如<code>utf8_spanish_ci</code>是以西班牙语的规则比较，<code>utf8_general_ci</code>是一种通用的比较规则。第三部分后缀主要用来表示要不要区分大小写和重音之类的。</li>
<li><code>Charset</code>: 关联的字符集的名称。</li>
<li><code>Default</code>: yes表示是字符集默认的比较规则。</li>
</ol>
<table>
<thead>
<tr>
<th>后缀</th>
<th>英文释义</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_ai</td>
<td>accent insensitive</td>
<td>不区分重音</td>
</tr>
<tr>
<td>_as</td>
<td>accent</td>
<td>sensitive</td>
</tr>
<tr>
<td>_ci</td>
<td>case insensitive</td>
<td>不区分大小写</td>
</tr>
<tr>
<td>_cs</td>
<td>case sensitive</td>
<td>区分大小写</td>
</tr>
<tr>
<td>_bin</td>
<td>binary</td>
<td>以二进制方式比较</td>
</tr>
</tbody></table>
<h3 id="字符集和比较规则作用域级别"><a href="#字符集和比较规则作用域级别" class="headerlink" title="字符集和比较规则作用域级别"></a>字符集和比较规则作用域级别</h3><p>mysql中字符集和比较规则有4种作用域级别：</p>
<ol>
<li>服务器级别</li>
<li>数据库级别</li>
<li>表级别</li>
<li>列级别</li>
</ol>
<p>实际上，<strong>字符集和比较较规则最后肯定是作用在<code>列级别</code>字段上的</strong>。可以简单的认为，如果<code>列级别</code>没有指定字符集和比较较规则，就使用<code>表级别</code>的；如果<code>表级别</code>没有指定字符集和比较较规则，就使用<code>数据库级别</code>的；以此类推。</p>
<h4 id="服务器级别"><a href="#服务器级别" class="headerlink" title="服务器级别"></a>服务器级别</h4><p>MySQL提供了两个系统变量来表示服务器级别的字符集和比较规则：</p>
<ul>
<li><code>character_set_server</code>: 服务器级别的字符集</li>
<li><code>collation_server</code>: 服务器级别的比较规则</li>
</ul>
<p>服务器级别默认的字符集是<code>utf8</code>，默认的比较规则是<code>utf8_general_ci</code>。</p>
<h4 id="数据库级别"><a href="#数据库级别" class="headerlink" title="数据库级别"></a>数据库级别</h4><p>我们在创建和修改数据库的时候可以指定该数据库的字符集和比较规则，具体语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> 数据库名</span><br><span class="line">     <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> 字符集名称</span><br><span class="line">     <span class="keyword">COLLATE</span> 比较规则名称;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">DATABASE</span> 数据库名</span><br><span class="line">    <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> 字符集名称</span><br><span class="line">    <span class="keyword">COLLATE</span> 比较规则名称;</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE DATABASE charset_demo_db</span><br><span class="line">    -&gt; CHARACTER SET gb2312</span><br><span class="line">    -&gt; COLLATE gb2312_chinese_ci;</span><br><span class="line">Query OK, 1 row affected (0.01 sec)</span><br></pre></td></tr></table></figure>

<p>如果想查看当前数据库使用的字符集和比较规则，可以查看下面两个系统变量的值:</p>
<ul>
<li><code>character_set_database</code>: 当前数据库的字符集</li>
<li><code>collation_database</code>: 当前数据库的比较规则</li>
</ul>
<h4 id="表级别"><a href="#表级别" class="headerlink" title="表级别"></a>表级别</h4><p>我们可以在创建和修改表的时候指定表的字符集和比较规则，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line">    (列的信息)</span><br><span class="line">    <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> 字符集名称</span><br><span class="line">    <span class="keyword">COLLATE</span> 比较规则名称</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名</span><br><span class="line">    <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> 字符集名称</span><br><span class="line">    <span class="keyword">COLLATE</span> 比较规则名称</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; CREATE TABLE t(</span><br><span class="line">    -&gt;     col VARCHAR(10)</span><br><span class="line">    -&gt; ) CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line">Query OK, 0 rows affected (0.03 sec)</span><br></pre></td></tr></table></figure>

<h4 id="列级别"><a href="#列级别" class="headerlink" title="列级别"></a>列级别</h4><p>需要注意的是，对于存储字符串的列，<strong>同一个表中的不同的列也可以有不同的字符集和比较规则</strong>。我们在创建和修改列定义的时候可以指定该列的字符集和比较规则，语法如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> 表名(</span><br><span class="line">    列名 字符串类型 <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> 字符集名称 <span class="keyword">COLLATE</span> 比较规则名称,</span><br><span class="line">    其他列...</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> 表名 <span class="keyword">MODIFY</span> 列名 字符串类型 <span class="built_in">CHARACTER</span> <span class="keyword">SET</span> 字符集名称 <span class="keyword">COLLATE</span> 比较规则名称;</span><br></pre></td></tr></table></figure>

<p>比如我们修改一下表t中列col的字符集和比较规则可以这么写：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; ALTER TABLE t MODIFY col VARCHAR(10) CHARACTER SET gbk COLLATE gbk_chinese_ci;</span><br><span class="line">Query OK, 0 rows affected (0.04 sec)</span><br><span class="line">Records: 0  Duplicates: 0  Warnings: 0</span><br></pre></td></tr></table></figure>

<p>还需要注意的一点是：<strong>由于字符集和比较规则是相互联系的，如果我们只修改了字符集和比较规则，都可能引起关联的字符集和比较规则发生变化</strong>。</p>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐一个适用于SpringBoot项目的轻量级HTTP客户端框架，快来试试它!</title>
    <url>/posts/3833574358/</url>
    <content><![CDATA[<p>在<code>SpringBoot</code>项目直接使用<code>okhttp</code>、<code>httpClient</code>或者<code>RestTemplate</code>发起<code>HTTP</code>请求，既繁琐又不方便统一管理。因此，在这里推荐一个适用于<code>SpringBoot</code>项目的轻量级HTTP客户端框架<a href="https://github.com/LianjiaTech/retrofit-spring-boot-starter" target="_blank" rel="noopener">retrofit-spring-boot-starter</a>，使用非常简单方便，同时又提供诸多功能增强。目前项目已经更新至<code>2.2.2</code>版本，并且会持续进行迭代优化。</p>
<p>项目地址：<a href="https://github.com/LianjiaTech/retrofit-spring-boot-starter" target="_blank" rel="noopener">https://github.com/LianjiaTech/retrofit-spring-boot-starter</a></p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>Retrofit</code>是适用于<code>Android</code>和<code>Java</code>且类型安全的HTTP客户端，其最大的特性的是<strong>支持通过<code>接口</code>的方式发起HTTP请求</strong>。而<code>spring-boot</code>是使用最广泛的Java开发框架，但是<code>Retrofit</code>官方没有支持与<code>spring-boot</code>框架快速整合，因此我们开发了<code>retrofit-spring-boot-starter</code>。</p>
<p><strong><code>retrofit-spring-boot-starter</code>实现了<code>Retrofit</code>与<code>spring-boot</code>框架快速整合，并且支持了诸多功能增强，极大简化开发</strong>。</p>
<p>🚀项目持续优化迭代，欢迎大家提ISSUE和PR！麻烦大家能给一颗star✨，您的star是我们持续更新的动力！</p>
<h2 id="功能特性"><a href="#功能特性" class="headerlink" title="功能特性"></a>功能特性</h2><ul>
<li><input checked="" disabled="" type="checkbox"> <a href="#自定义注入OkHttpClient">自定义注入OkHttpClient</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="#注解式拦截器">注解式拦截器</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="#连接池管理">连接池管理</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="#日志打印">日志打印</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="#请求重试">请求重试</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="#错误解码器">错误解码器</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="#全局拦截器">全局拦截器</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="#熔断降级">熔断降级</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="#微服务之间的HTTP调用">微服务之间的HTTP调用</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="#调用适配器">调用适配器</a></li>
<li><input checked="" disabled="" type="checkbox"> <a href="#数据转码器">数据转换器</a></li>
</ul>
<h2 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h2><h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.lianjiatech<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>retrofit-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="定义http接口"><a href="#定义http接口" class="headerlink" title="定义http接口"></a>定义http接口</h3><p><strong>接口必须使用<code>@RetrofitClient</code>注解标记</strong>！http相关注解可参考官方文档：<a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">retrofit官方文档</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitClient</span>(baseUrl = <span class="string">"$&#123;test.baseUrl&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注入使用"><a href="#注入使用" class="headerlink" title="注入使用"></a>注入使用</h3><p><strong>将接口注入到其它Service中即可使用！</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpApi httpApi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过httpApi发起http请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="HTTP请求相关注解"><a href="#HTTP请求相关注解" class="headerlink" title="HTTP请求相关注解"></a>HTTP请求相关注解</h2><p><code>HTTP</code>请求相关注解，全部使用了<code>retrofit</code>原生注解。<strong>详细信息可参考官方文档：<a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">retrofit官方文档</a></strong>，以下是一个简单说明。</p>
<table>
<thead>
<tr>
<th>注解分类</th>
<th>支持的注解</th>
</tr>
</thead>
<tbody><tr>
<td>请求方式</td>
<td><code>@GET</code> <code>@HEAD</code> <code>@POST</code> <code>@PUT</code> <code>@DELETE</code> <code>@OPTIONS</code></td>
</tr>
<tr>
<td>请求头</td>
<td><code>@Header</code> <code>@HeaderMap</code> <code>@Headers</code></td>
</tr>
<tr>
<td>Query参数</td>
<td><code>@Query</code> <code>@QueryMap</code> <code>@QueryName</code></td>
</tr>
<tr>
<td>path参数</td>
<td><code>@Path</code></td>
</tr>
<tr>
<td>form-encoded参数</td>
<td><code>@Field</code> <code>@FieldMap</code> <code>@FormUrlEncoded</code></td>
</tr>
<tr>
<td>文件上传</td>
<td><code>@Multipart</code> <code>@Part</code> <code>@PartMap</code></td>
</tr>
<tr>
<td>url参数</td>
<td><code>@Url</code></td>
</tr>
</tbody></table>
<h2 id="配置项说明"><a href="#配置项说明" class="headerlink" title="配置项说明"></a>配置项说明</h2><p><code>retrofit-spring-boot-starter</code>支持了多个可配置的属性，用来应对不同的业务场景。您可以视情况进行修改，具体说明如下：</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>enable-log</td>
<td>true</td>
<td>启用日志打印</td>
</tr>
<tr>
<td>logging-interceptor</td>
<td>DefaultLoggingInterceptor</td>
<td>日志打印拦截器</td>
</tr>
<tr>
<td>pool</td>
<td></td>
<td>连接池配置</td>
</tr>
<tr>
<td>disable-void-return-type</td>
<td>false</td>
<td>禁用java.lang.Void返回类型</td>
</tr>
<tr>
<td>retry-interceptor</td>
<td>DefaultRetryInterceptor</td>
<td>请求重试拦截器</td>
</tr>
<tr>
<td>global-converter-factories</td>
<td>JacksonConverterFactory</td>
<td>全局转换器工厂</td>
</tr>
<tr>
<td>global-call-adapter-factories</td>
<td>BodyCallAdapterFactory,ResponseCallAdapterFactory</td>
<td>全局调用适配器工厂</td>
</tr>
<tr>
<td>enable-degrade</td>
<td>false</td>
<td>是否启用熔断降级</td>
</tr>
<tr>
<td>degrade-type</td>
<td>sentinel</td>
<td>熔断降级实现方式(目前仅支持Sentinel)</td>
</tr>
<tr>
<td>resource-name-parser</td>
<td>DefaultResourceNameParser</td>
<td>熔断资源名称解析器，用于解析资源名称</td>
</tr>
</tbody></table>
<p><code>yml</code>配置方式：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retrofit:</span></span><br><span class="line">  <span class="attr">enable-response-call-adapter:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 启用日志打印</span></span><br><span class="line">  <span class="attr">enable-log:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 连接池配置</span></span><br><span class="line">  <span class="attr">pool:</span></span><br><span class="line">    <span class="attr">test1:</span></span><br><span class="line">      <span class="attr">max-idle-connections:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">keep-alive-second:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">test2:</span></span><br><span class="line">      <span class="attr">max-idle-connections:</span> <span class="number">5</span></span><br><span class="line">      <span class="attr">keep-alive-second:</span> <span class="number">50</span></span><br><span class="line">  <span class="comment"># 禁用void返回值类型</span></span><br><span class="line">  <span class="attr">disable-void-return-type:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># 日志打印拦截器</span></span><br><span class="line">  <span class="attr">logging-interceptor:</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.interceptor.DefaultLoggingInterceptor</span></span><br><span class="line">  <span class="comment"># 请求重试拦截器</span></span><br><span class="line">  <span class="attr">retry-interceptor:</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.retry.DefaultRetryInterceptor</span></span><br><span class="line">  <span class="comment"># 全局转换器工厂</span></span><br><span class="line">  <span class="attr">global-converter-factories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">retrofit2.converter.jackson.JacksonConverterFactory</span></span><br><span class="line">  <span class="comment"># 全局调用适配器工厂</span></span><br><span class="line">  <span class="attr">global-call-adapter-factories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.core.BodyCallAdapterFactory</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.core.ResponseCallAdapterFactory</span></span><br><span class="line">  <span class="comment"># 是否启用熔断降级</span></span><br><span class="line">  <span class="attr">enable-degrade:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 熔断降级实现方式</span></span><br><span class="line">  <span class="attr">degrade-type:</span> <span class="string">sentinel</span></span><br><span class="line">  <span class="comment"># 熔断资源名称解析器</span></span><br><span class="line">  <span class="attr">resource-name-parser:</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.degrade.DefaultResourceNameParser</span></span><br></pre></td></tr></table></figure>

<h2 id="高级功能"><a href="#高级功能" class="headerlink" title="高级功能"></a>高级功能</h2><h3 id="自定义注入OkHttpClient"><a href="#自定义注入OkHttpClient" class="headerlink" title="自定义注入OkHttpClient"></a>自定义注入OkHttpClient</h3><p>通常情况下，通过<code>@RetrofitClient</code>注解属性动态创建<code>OkHttpClient</code>对象能够满足大部分使用场景。但是在某些情况下，用户可能需要自定义<code>OkHttpClient</code>，这个时候，可以在接口上定义返回类型是<code>OkHttpClient.Builder</code>的静态方法来实现。代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitClient</span>(baseUrl = <span class="string">"http://ke.com"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApi3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OkHttpClientBuilder</span></span><br><span class="line">    <span class="keyword">static</span> OkHttpClient.<span class="function">Builder <span class="title">okhttpClientBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .connectTimeout(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                .readTimeout(<span class="number">1</span>, TimeUnit.SECONDS)</span><br><span class="line">                .writeTimeout(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span></span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Url String url, @Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法必须使用<code>@OkHttpClientBuilder</code>注解标记！</p>
</blockquote>
<h3 id="注解式拦截器"><a href="#注解式拦截器" class="headerlink" title="注解式拦截器"></a>注解式拦截器</h3><p>很多时候，我们希望某个接口下的某些http请求执行统一的拦截处理逻辑。为了支持这个功能，<code>retrofit-spring-boot-starter</code>提供了<strong>注解式拦截器</strong>，做到了<strong>基于url路径的匹配拦截</strong>。使用的步骤主要分为2步：</p>
<ol>
<li>继承<code>BasePathMatchInterceptor</code>编写拦截处理器；</li>
<li>接口上使用<code>@Intercept</code>进行标注。如需配置多个拦截器，在接口上标注多个<code>@Intercept</code>注解即可！</li>
</ol>
<p>下面以<em>给指定请求的url后面拼接timestamp时间戳</em>为例，介绍下如何使用注解式拦截器。</p>
<h4 id="继承BasePathMatchInterceptor编写拦截处理器"><a href="#继承BasePathMatchInterceptor编写拦截处理器" class="headerlink" title="继承BasePathMatchInterceptor编写拦截处理器"></a>继承<code>BasePathMatchInterceptor</code>编写拦截处理器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeStampInterceptor</span> <span class="keyword">extends</span> <span class="title">BasePathMatchInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">doIntercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        HttpUrl url = request.url();</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        HttpUrl newUrl = url.newBuilder()</span><br><span class="line">                .addQueryParameter(<span class="string">"timestamp"</span>, String.valueOf(timestamp))</span><br><span class="line">                .build();</span><br><span class="line">        Request newRequest = request.newBuilder()</span><br><span class="line">                .url(newUrl)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(newRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口上使用-Intercept进行标注"><a href="#接口上使用-Intercept进行标注" class="headerlink" title="接口上使用@Intercept进行标注"></a>接口上使用<code>@Intercept</code>进行标注</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitClient</span>(baseUrl = <span class="string">"$&#123;test.baseUrl&#125;"</span>)</span><br><span class="line"><span class="meta">@Intercept</span>(handler = TimeStampInterceptor<span class="class">.<span class="keyword">class</span>, <span class="title">include</span> </span>= &#123;<span class="string">"/api/**"</span>&#125;, exclude = <span class="string">"/api/test/savePerson"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"savePerson"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">savePerson</span><span class="params">(@Body Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>@Intercept</code>配置表示：拦截<code>HttpApi</code>接口下<code>/api/**</code>路径下（排除<code>/api/test/savePerson</code>）的请求，拦截处理器使用<code>TimeStampInterceptor</code>。</p>
<h3 id="扩展注解式拦截器"><a href="#扩展注解式拦截器" class="headerlink" title="扩展注解式拦截器"></a>扩展注解式拦截器</h3><p>有的时候，我们需要在<strong>拦截注解</strong>动态传入一些参数，然后再执行拦截的时候需要使用这个参数。这种时候，我们可以扩展实现<strong>自定义拦截注解</strong>。<code>自定义拦截注解</code>必须使用<code>@InterceptMark</code>标记，并且<strong>注解中必须包括<code>include()、exclude()、handler()</code>属性信息</strong>。使用的步骤主要分为3步：</p>
<ol>
<li>自定义拦截注解</li>
<li>继承<code>BasePathMatchInterceptor</code>编写拦截处理器</li>
<li>接口上使用自定义拦截注解；</li>
</ol>
<p>例如我们需要<strong>在请求头里面动态加入<code>accessKeyId</code>、<code>accessKeySecret</code>签名信息才能正常发起http请求</strong>，这个时候<strong>可以自定义一个加签拦截器注解<code>@Sign</code>来实现</strong>。下面以自定义<code>@Sign</code>拦截注解为例进行说明。</p>
<h4 id="自定义-Sign注解"><a href="#自定义-Sign注解" class="headerlink" title="自定义@Sign注解"></a>自定义<code>@Sign</code>注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@InterceptMark</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Sign &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥key</span></span><br><span class="line"><span class="comment">     * 支持占位符形式配置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">accessKeyId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥</span></span><br><span class="line"><span class="comment">     * 支持占位符形式配置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">accessKeySecret</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器匹配路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] include() <span class="keyword">default</span> &#123;<span class="string">"/**"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器排除匹配，排除指定路径拦截</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理该注解的拦截器类</span></span><br><span class="line"><span class="comment">     * 优先从spring容器获取对应的Bean，如果获取不到，则使用反射创建一个！</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends BasePathMatchInterceptor&gt; handler() <span class="keyword">default</span> SignInterceptor<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展<code>自定义拦截注解</code>有以下2点需要注意：</p>
<ol>
<li><code>自定义拦截注解</code>必须使用<code>@InterceptMark</code>标记。</li>
<li>注解中必须包括<code>include()、exclude()、handler()</code>属性信息。</li>
</ol>
<h4 id="实现SignInterceptor"><a href="#实现SignInterceptor" class="headerlink" title="实现SignInterceptor"></a>实现<code>SignInterceptor</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignInterceptor</span> <span class="keyword">extends</span> <span class="title">BasePathMatchInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessKeyId</span><span class="params">(String accessKeyId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accessKeyId = accessKeyId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessKeySecret</span><span class="params">(String accessKeySecret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accessKeySecret = accessKeySecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">doIntercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        Request newReq = request.newBuilder()</span><br><span class="line">                .addHeader(<span class="string">"accessKeyId"</span>, accessKeyId)</span><br><span class="line">                .addHeader(<span class="string">"accessKeySecret"</span>, accessKeySecret)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(newReq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述<code>accessKeyId</code>和<code>accessKeySecret</code>字段值会依据<code>@Sign</code>注解的<code>accessKeyId()</code>和<code>accessKeySecret()</code>值自动注入，如果<code>@Sign</code>指定的是占位符形式的字符串，则会取配置属性值进行注入</strong>。另外，<strong><code>accessKeyId</code>和<code>accessKeySecret</code>字段必须提供<code>setter</code>方法</strong>。</p>
<h4 id="接口上使用-Sign"><a href="#接口上使用-Sign" class="headerlink" title="接口上使用@Sign"></a>接口上使用<code>@Sign</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitClient</span>(baseUrl = <span class="string">"$&#123;test.baseUrl&#125;"</span>)</span><br><span class="line"><span class="meta">@Sign</span>(accessKeyId = <span class="string">"$&#123;test.accessKeyId&#125;"</span>, accessKeySecret = <span class="string">"$&#123;test.accessKeySecret&#125;"</span>, exclude = &#123;<span class="string">"/api/test/person"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"savePerson"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">savePerson</span><span class="params">(@Body Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能在指定url的请求上，自动加上签名信息了。</p>
<h3 id="连接池管理"><a href="#连接池管理" class="headerlink" title="连接池管理"></a>连接池管理</h3><p>默认情况下，所有通过<code>Retrofit</code>发送的http请求都会使用<code>max-idle-connections=5  keep-alive-second=300</code>的默认连接池。当然，我们也可以在配置文件中配置多个自定义的连接池，然后通过<code>@RetrofitClient</code>的<code>poolName</code>属性来指定使用。比如我们要让某个接口下的请求全部使用<code>poolName=test1</code>的连接池，代码实现如下：</p>
<ol>
<li><p>配置连接池。</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retrofit:</span></span><br><span class="line">    <span class="comment"># 连接池配置</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">test1:</span></span><br><span class="line">        <span class="attr">max-idle-connections:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">keep-alive-second:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">test2:</span></span><br><span class="line">        <span class="attr">max-idle-connections:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">keep-alive-second:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>@RetrofitClient</code>的<code>poolName</code>属性来指定使用的连接池。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitClient</span>(baseUrl = <span class="string">"$&#123;test.baseUrl&#125;"</span>, poolName=<span class="string">"test1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>很多情况下，我们希望将http请求日志记录下来。通过<code>retrofit.enableLog</code>配置可以全局控制日志是否开启。<br>针对每个接口，可以通过<code>@RetrofitClient</code>的<code>enableLog</code>控制是否开启，通过<code>logLevel</code>和<code>logStrategy</code>，可以指定每个接口的日志打印级别以及日志打印策略。<code>retrofit-spring-boot-starter</code>支持了5种日志打印级别(<code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code>, <code>TRACE</code>)，默认<code>INFO</code>；支持了4种日志打印策略（<code>NONE</code>, <code>BASIC</code>, <code>HEADERS</code>, <code>BODY</code>），默认<code>BASIC</code>。4种日志打印策略含义如下：</p>
<ol>
<li><code>NONE</code>：No logs.</li>
<li><code>BASIC</code>：Logs request and response lines.</li>
<li><code>HEADERS</code>：Logs request and response lines and their respective headers.</li>
<li><code>BODY</code>：Logs request and response lines and their respective headers and bodies (if present).</li>
</ol>
<p><code>retrofit-spring-boot-starter</code>默认使用了<code>DefaultLoggingInterceptor</code>执行真正的日志打印功能，其底层就是<code>okhttp</code>原生的<code>HttpLoggingInterceptor</code>。当然，你也可以自定义实现自己的日志打印拦截器，只需要继承<code>BaseLoggingInterceptor</code>（具体可以参考<code>DefaultLoggingInterceptor</code>的实现），然后在配置文件中进行相关配置即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retrofit:</span></span><br><span class="line">  <span class="comment"># 日志打印拦截器</span></span><br><span class="line">  <span class="attr">logging-interceptor:</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.interceptor.DefaultLoggingInterceptor</span></span><br></pre></td></tr></table></figure>

<h3 id="请求重试"><a href="#请求重试" class="headerlink" title="请求重试"></a>请求重试</h3><p><code>retrofit-spring-boot-starter</code>支持请求重试功能，只需要在接口或者方法上加上<code>@Retry</code>注解即可。<strong><code>@Retry</code>支持重试次数<code>maxRetries</code>、重试时间间隔<code>intervalMs</code>以及重试规则<code>retryRules</code>配置</strong>。重试规则支持三种配置：</p>
<ol>
<li><code>RESPONSE_STATUS_NOT_2XX</code>：响应状态码不是<code>2xx</code>时执行重试；</li>
<li><code>OCCUR_IO_EXCEPTION</code>：发生IO异常时执行重试；</li>
<li><code>OCCUR_EXCEPTION</code>：发生任意异常时执行重试；</li>
</ol>
<p>默认响应状态码不是<code>2xx</code>或者发生IO异常时自动进行重试。需要的话，你也可以继承<code>BaseRetryInterceptor</code>实现自己的请求重试拦截器，然后将其配置上去。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retrofit:</span></span><br><span class="line">  <span class="comment"># 请求重试拦截器</span></span><br><span class="line">  <span class="attr">retry-interceptor:</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.retry.DefaultRetryInterceptor</span></span><br></pre></td></tr></table></figure>

<h3 id="错误解码器"><a href="#错误解码器" class="headerlink" title="错误解码器"></a>错误解码器</h3><p>在<code>HTTP</code>发生请求错误(包括发生异常或者响应数据不符合预期)的时候，错误解码器可将<code>HTTP</code>相关信息解码到自定义异常中。你可以在<code>@RetrofitClient</code>注解的<code>errorDecoder()</code>指定当前接口的错误解码器，自定义错误解码器需要实现<code>ErrorDecoder</code>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误解码器。ErrorDecoder.</span></span><br><span class="line"><span class="comment"> * 当请求发生异常或者收到无效响应结果的时候，将HTTP相关信息解码到异常中，无效响应由业务自己判断</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * When an exception occurs in the request or an invalid response result is received, the HTTP related information is decoded into the exception,</span></span><br><span class="line"><span class="comment"> * and the invalid response is determined by the business itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorDecoder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当无效响应的时候，将HTTP信息解码到异常中，无效响应由业务自行判断。</span></span><br><span class="line"><span class="comment">     * When the response is invalid, decode the HTTP information into the exception, invalid response is determined by business.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request  request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response response</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> If it returns null, the processing is ignored and the processing continues with the original response.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> RuntimeException <span class="title">invalidRespDecode</span><span class="params">(Request request, Response response)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!response.isSuccessful()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> RetrofitException.errorStatus(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当请求发生IO异常时，将HTTP信息解码到异常中。</span></span><br><span class="line"><span class="comment">     * When an IO exception occurs in the request, the HTTP information is decoded into the exception.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause   IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RuntimeException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> RuntimeException <span class="title">ioExceptionDecode</span><span class="params">(Request request, IOException cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RetrofitException.errorExecuting(request, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当请求发生除IO异常之外的其它异常时，将HTTP信息解码到异常中。</span></span><br><span class="line"><span class="comment">     * When the request has an exception other than the IO exception, the HTTP information is decoded into the exception.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> request request</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause   Exception</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> RuntimeException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> RuntimeException <span class="title">exceptionDecode</span><span class="params">(Request request, Exception cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RetrofitException.errorUnknown(request, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="全局拦截器"><a href="#全局拦截器" class="headerlink" title="全局拦截器"></a>全局拦截器</h2><h3 id="全局应用拦截器"><a href="#全局应用拦截器" class="headerlink" title="全局应用拦截器"></a>全局应用拦截器</h3><p>如果我们需要对整个系统的的http请求执行统一的拦截处理，可以自定义实现全局拦截器<code>BaseGlobalInterceptor</code>, 并配置成<code>spring</code>容器中的<code>bean</code>！例如我们需要在整个系统发起的http请求，都带上来源信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceInterceptor</span> <span class="keyword">extends</span> <span class="title">BaseGlobalInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">doIntercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        Request newReq = request.newBuilder()</span><br><span class="line">                .addHeader(<span class="string">"source"</span>, <span class="string">"test"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(newReq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局网络拦截器"><a href="#全局网络拦截器" class="headerlink" title="全局网络拦截器"></a>全局网络拦截器</h3><p>只需要实现<code>NetworkInterceptor</code>接口 并配置成<code>spring</code>容器中的<code>bean</code>就支持自动织入全局网络拦截器。</p>
<h3 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h3><p>在分布式服务架构中，对不稳定的外部服务进行熔断降级是保证服务高可用的重要措施之一。由于外部服务的稳定性是不能保证的，当外部服务不稳定时，响应时间会变长。相应地，调用方的响应时间也会变长，线程会产生堆积，最终可能耗尽调用方的线程池，导致整个服务不可用。因此我们需要对不稳定的弱依赖服务调用进行熔断降级，暂时切断不稳定调用，避免局部不稳定导致整体服务雪崩。</p>
<p><code>retrofit-spring-boot-starter</code>支持熔断降级功能，底层基于<a href="https://sentinelguard.io/zh-cn/docs/introduction.html" target="_blank" rel="noopener">Sentinel</a>实现。具体来说，支持了<strong>熔断资源自发现</strong>和<strong>注解式降级规则配置</strong>。如需使用熔断降级，只需要进行以下操作即可：</p>
<h4 id="1-开启熔断降级功能"><a href="#1-开启熔断降级功能" class="headerlink" title="1. 开启熔断降级功能"></a>1. 开启熔断降级功能</h4><p><strong>默认情况下，熔断降级功能是关闭的，需要设置相应的配置项来开启熔断降级功能</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retrofit:</span></span><br><span class="line">  <span class="comment"># 是否启用熔断降级</span></span><br><span class="line">  <span class="attr">enable-degrade:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 熔断降级实现方式(目前仅支持Sentinel)</span></span><br><span class="line">  <span class="attr">degrade-type:</span> <span class="string">sentinel</span></span><br><span class="line">  <span class="comment"># 资源名称解析器</span></span><br><span class="line">  <span class="attr">resource-name-parser:</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.degrade.DefaultResourceNameParser</span></span><br></pre></td></tr></table></figure>

<p>资源名称解析器用于实现用户自定义资源名称，默认配置是<code>DefaultResourceNameParser</code>，对应的资源名称格式为<code>HTTP_OUT:GET:http://localhost:8080/api/degrade/test</code>。用户可以继承<code>BaseResourceNameParser</code>类实现自己的资源名称解析器。</p>
<p>另外，由于熔断降级功能是可选的，<strong>因此启用熔断降级需要用户自行引入Sentinel依赖</strong>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.csp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sentinel-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-配置降级规则（可选）"><a href="#2-配置降级规则（可选）" class="headerlink" title="2. 配置降级规则（可选）"></a>2. 配置降级规则（可选）</h4><p><strong><code>retrofit-spring-boot-starter</code>支持注解式配置降级规则，通过<code>@Degrade</code>注解来配置降级规则</strong>。<code>@Degrade</code>注解可以配置在接口或者方法上，配置在方法上的优先级更高。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Degrade &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * RT threshold or exception ratio threshold count.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Degrade recover timeout (in seconds) when degradation occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeWindow</span><span class="params">()</span> <span class="keyword">default</span> 5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Degrade strategy (0: average RT, 1: exception ratio).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">DegradeStrategy <span class="title">degradeStrategy</span><span class="params">()</span> <span class="keyword">default</span> DegradeStrategy.AVERAGE_RT</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如果应用项目已支持通过配置中心配置降级规则，可忽略注解式配置方式</strong>。</p>
</blockquote>
<h4 id="3-RetrofitClient设置fallback或者fallbackFactory-可选"><a href="#3-RetrofitClient设置fallback或者fallbackFactory-可选" class="headerlink" title="3. @RetrofitClient设置fallback或者fallbackFactory (可选)"></a>3. @RetrofitClient设置fallback或者fallbackFactory (可选)</h4><p>如果<code>@RetrofitClient</code>不设置<code>fallback</code>或者<code>fallbackFactory</code>，当触发熔断时，会直接抛出<code>RetrofitBlockException</code>异常。<strong>用户可以通过设置<code>fallback</code>或者<code>fallbackFactory</code>来定制熔断时的方法返回值</strong>。<code>fallback</code>类必须是当前接口的实现类，<code>fallbackFactory</code>必须是<code>FallbackFactory&lt;T&gt;</code>实现类，泛型参数类型为当前接口类型。另外，<code>fallback</code>和<code>fallbackFactory</code>实例必须配置成<code>Spring</code>容器的<code>Bean</code>。</p>
<p><strong><code>fallbackFactory</code>相对于<code>fallback</code>，主要差别在于能够感知每次熔断的异常原因(cause)</strong>。参考示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDegradeFallback</span> <span class="keyword">implements</span> <span class="title">HttpDegradeApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;Integer&gt; <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Result&lt;Integer&gt; fallback = <span class="keyword">new</span> Result&lt;&gt;();</span><br><span class="line">        fallback.setCode(<span class="number">100</span>)</span><br><span class="line">                .setMsg(<span class="string">"fallback"</span>)</span><br><span class="line">                .setBody(<span class="number">1000000</span>);</span><br><span class="line">        <span class="keyword">return</span> fallback;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDegradeFallbackFactory</span> <span class="keyword">implements</span> <span class="title">FallbackFactory</span>&lt;<span class="title">HttpDegradeApi</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns an instance of the fallback appropriate for the given cause</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause fallback cause</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 实现了retrofit接口的实例。an instance that implements the retrofit interface.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpDegradeApi <span class="title">create</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">"触发熔断了! "</span>, cause.getMessage(), cause);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpDegradeApi() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Result&lt;Integer&gt; <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Result&lt;Integer&gt; fallback = <span class="keyword">new</span> Result&lt;&gt;();</span><br><span class="line">                fallback.setCode(<span class="number">100</span>)</span><br><span class="line">                        .setMsg(<span class="string">"fallback"</span>)</span><br><span class="line">                        .setBody(<span class="number">1000000</span>);</span><br><span class="line">                <span class="keyword">return</span> fallback;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="微服务之间的HTTP调用"><a href="#微服务之间的HTTP调用" class="headerlink" title="微服务之间的HTTP调用"></a>微服务之间的HTTP调用</h3><p>为了能够使用微服务调用，需要进行如下配置：</p>
<h4 id="配置ServiceInstanceChooser为Spring容器Bean"><a href="#配置ServiceInstanceChooser为Spring容器Bean" class="headerlink" title="配置ServiceInstanceChooser为Spring容器Bean"></a>配置<code>ServiceInstanceChooser</code>为<code>Spring</code>容器<code>Bean</code></h4><p>用户可以自行实现<code>ServiceInstanceChooser</code>接口，完成服务实例的选取逻辑，并将其配置成<code>Spring</code>容器的<code>Bean</code>。对于<code>Spring Cloud</code>应用，<code>retrofit-spring-boot-starter</code>提供了<code>SpringCloudServiceInstanceChooser</code>实现，用户只需将其配置成<code>Spring</code>的<code>Bean</code>即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ServiceInstanceChooser <span class="title">serviceInstanceChooser</span><span class="params">(LoadBalancerClient loadBalancerClient)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> SpringCloudServiceInstanceChooser(loadBalancerClient);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-Retrofit的serviceId和path属性，可以实现微服务之间的HTTP调用"><a href="#使用-Retrofit的serviceId和path属性，可以实现微服务之间的HTTP调用" class="headerlink" title="使用@Retrofit的serviceId和path属性，可以实现微服务之间的HTTP调用"></a>使用<code>@Retrofit</code>的<code>serviceId</code>和<code>path</code>属性，可以实现微服务之间的HTTP调用</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitClient</span>(serviceId = <span class="string">"$&#123;jy-helicarrier-api.serviceId&#125;"</span>, path = <span class="string">"/m/count"</span>, errorDecoder = HelicarrierErrorDecoder<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Retry</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">interface</span> <span class="title">ApiCountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="调用适配器和数据转码器"><a href="#调用适配器和数据转码器" class="headerlink" title="调用适配器和数据转码器"></a>调用适配器和数据转码器</h2><h3 id="调用适配器"><a href="#调用适配器" class="headerlink" title="调用适配器"></a>调用适配器</h3><p><code>Retrofit</code>可以通过调用适配器<code>CallAdapterFactory</code>将<code>Call&lt;T&gt;</code>对象适配成接口方法的返回值类型。<code>retrofit-spring-boot-starter</code>扩展2种<code>CallAdapterFactory</code>实现：</p>
<ol>
<li><code>BodyCallAdapterFactory</code><ul>
<li>默认启用，可通过配置<code>retrofit.enable-body-call-adapter=false</code>关闭</li>
<li>同步执行http请求，将响应体内容适配成接口方法的返回值类型实例。</li>
<li>除了<code>Retrofit.Call&lt;T&gt;</code>、<code>Retrofit.Response&lt;T&gt;</code>、<code>java.util.concurrent.CompletableFuture&lt;T&gt;</code>之外，其它返回类型都可以使用该适配器。</li>
</ul>
</li>
<li><code>ResponseCallAdapterFactory</code><ul>
<li>默认启用，可通过配置<code>retrofit.enable-response-call-adapter=false</code>关闭</li>
<li>同步执行http请求，将响应体内容适配成<code>Retrofit.Response&lt;T&gt;</code>返回。</li>
<li>如果方法的返回值类型为<code>Retrofit.Response&lt;T&gt;</code>，则可以使用该适配器。</li>
</ul>
</li>
</ol>
<p><strong>Retrofit自动根据方法返回值类型选用对应的<code>CallAdapterFactory</code>执行适配处理！加上Retrofit默认的<code>CallAdapterFactory</code>，可支持多种形式的方法返回值类型：</strong></p>
<ul>
<li><code>Call&lt;T&gt;</code>: 不执行适配处理，直接返回<code>Call&lt;T&gt;</code>对象</li>
<li><code>CompletableFuture&lt;T&gt;</code>: 将响应体内容适配成<code>CompletableFuture&lt;T&gt;</code>对象返回</li>
<li><code>Void</code>: 不关注返回类型可以使用<code>Void</code>。如果http状态码不是2xx，直接抛错！</li>
<li><code>Response&lt;T&gt;</code>: 将响应内容适配成<code>Response&lt;T&gt;</code>对象返回</li>
<li>其他任意Java类型： 将响应体内容适配成一个对应的Java类型对象返回，如果http状态码不是2xx，直接抛错！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 不执行适配处理，直接返回Call&lt;T&gt;对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">Call&lt;Result&lt;Person&gt;&gt; getPersonCall(<span class="meta">@Query</span>(<span class="string">"id"</span>) Long id);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  CompletableFuture&lt;T&gt;</span></span><br><span class="line"><span class="comment"> *  将响应体内容适配成CompletableFuture&lt;T&gt;对象返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">CompletableFuture&lt;Result&lt;Person&gt;&gt; getPersonCompletableFuture(<span class="meta">@Query</span>(<span class="string">"id"</span>) Long id);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Void</span></span><br><span class="line"><span class="comment"> * 不关注返回类型可以使用Void。如果http状态码不是2xx，直接抛错！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="function">Void <span class="title">getPersonVoid</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Response&lt;T&gt;</span></span><br><span class="line"><span class="comment"> *  将响应内容适配成Response&lt;T&gt;对象返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">Response&lt;Result&lt;Person&gt;&gt; getPersonResponse(<span class="meta">@Query</span>(<span class="string">"id"</span>) Long id);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其他任意Java类型</span></span><br><span class="line"><span class="comment"> * 将响应体内容适配成一个对应的Java类型对象返回，如果http状态码不是2xx，直接抛错！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>我们也可以通过继承<code>CallAdapter.Factory</code>扩展实现自己的<code>CallAdapter</code></strong>！</p>
<p><code>retrofit-spring-boot-starter</code>支持通过<code>retrofit.global-call-adapter-factories</code>配置全局调用适配器工厂，工厂实例优先从Spring容器获取，如果没有获取到，则反射创建。默认的全局调用适配器工厂是<code>[BodyCallAdapterFactory, ResponseCallAdapterFactory]</code>！</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retrofit:</span></span><br><span class="line">  <span class="comment"># 全局调用适配器工厂</span></span><br><span class="line">  <span class="attr">global-call-adapter-factories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.core.BodyCallAdapterFactory</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.core.ResponseCallAdapterFactory</span></span><br></pre></td></tr></table></figure>

<p>针对每个Java接口，还可以通过<code>@RetrofitClient</code>注解的<code>callAdapterFactories()</code>指定当前接口采用的<code>CallAdapter.Factory</code>，指定的工厂实例依然优先从Spring容器获取。</p>
<p><strong>注意：如果<code>CallAdapter.Factory</code>没有<code>public</code>的无参构造器，请手动将其配置成<code>Spring</code>容器的<code>Bean</code>对象</strong>！</p>
<h3 id="数据转码器"><a href="#数据转码器" class="headerlink" title="数据转码器"></a>数据转码器</h3><p><code>Retrofit</code>使用<code>Converter</code>将<code>@Body</code>注解标注的对象转换成请求体，将响应体数据转换成一个<code>Java</code>对象，可以选用以下几种<code>Converter</code>：</p>
<ul>
<li><a href="https://github.com/google/gson" target="_blank" rel="noopener">Gson</a>: com.squareup.Retrofit:converter-gson</li>
<li><a href="https://github.com/FasterXML/jackson" target="_blank" rel="noopener">Jackson</a>: com.squareup.Retrofit:converter-jackson</li>
<li><a href="https://github.com/square/moshi/" target="_blank" rel="noopener">Moshi</a>: com.squareup.Retrofit:converter-moshi</li>
<li><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="noopener">Protobuf</a>: com.squareup.Retrofit:converter-protobuf</li>
<li><a href="https://github.com/square/wire" target="_blank" rel="noopener">Wire</a>: com.squareup.Retrofit:converter-wire</li>
<li><a href="http://simple.sourceforge.net/" target="_blank" rel="noopener">Simple XML</a>: com.squareup.Retrofit:converter-simplexml</li>
<li><a href="https://docs.oracle.com/javase/tutorial/jaxb/intro/index.html" target="_blank" rel="noopener">JAXB</a>: com.squareup.retrofit2:converter-jaxb</li>
</ul>
<p><code>retrofit-spring-boot-starter</code>支持通过<code>retrofit.global-converter-factories</code>配置全局数据转换器工厂，转换器工厂实例优先从Spring容器获取，如果没有获取到，则反射创建。默认的全局数据转换器工厂是<code>retrofit2.converter.jackson.JacksonConverterFactory</code>，你可以直接通过<code>spring.jackson.*</code>配置<code>jackson</code>序列化规则，配置可参考<a href="https://docs.spring.io/spring-boot/docs/2.1.5.RELEASE/reference/htmlsingle/#howto-customize-the-jackson-objectmapper" target="_blank" rel="noopener">Customize the Jackson ObjectMapper</a>！</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retrofit:</span></span><br><span class="line">  <span class="comment"># 全局转换器工厂</span></span><br><span class="line">  <span class="attr">global-converter-factories:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">retrofit2.converter.jackson.JacksonConverterFactory</span></span><br></pre></td></tr></table></figure>

<p>针对每个Java接口，还可以通过<code>@RetrofitClient</code>注解的<code>converterFactories()</code>指定当前接口采用的<code>Converter.Factory</code>，指定的转换器工厂实例依然优先从Spring容器获取。</p>
<p><strong>注意：如果<code>Converter.Factory</code>没有<code>public</code>的无参构造器，请手动将其配置成<code>Spring</code>容器的<code>Bean</code>对象</strong>！</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>retrofit-spring-boot-starter</code>一个适用于<code>SpringBoot</code>项目的轻量级<code>HTTP</code>客户端框架，已在线上稳定运行一年多，并且已经有多个外部公司也接入使用。有兴趣的朋友可以尝试一下，如有任何问题，欢迎提issue或者加QQ群（806714302）反馈，极速响应支持。</p>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用Redis实现页面UV统计-HyperLogLog实现详解</title>
    <url>/posts/1507822429/</url>
    <content><![CDATA[<p>如果要我们设计一个基于<code>Redis</code>统计页面<code>UV</code>的实现方案，可能的实现方案有什么？<br>大家可能很容易想到的一个方案就是使用<code>Set</code>对象保存每一个访问页面的<code>用户id</code>，因为<code>Set</code>结构天然就支持去重功能，因此使用<code>scard</code>取出的<code>Set</code>集合大小即为页面<code>UV</code>。但是，如果页面<code>UV</code>非常巨大时，使用<code>Set</code>结构存储就会非常浪费空间。<br><strong><code>Redis</code>提供了<code>HyperLogLog</code>数据结构来解决这类统计问题，既节省内存占用，又能保证统计结果在可接受的误差之内</strong>。</p>
<a id="more"></a>

<h2 id="Redis中的HyperLogLog使用"><a href="#Redis中的HyperLogLog使用" class="headerlink" title="Redis中的HyperLogLog使用"></a>Redis中的HyperLogLog使用</h2><p><code>Redis</code>中的<code>HyperLogLog</code>提供了两个指令<code>pfadd</code>和<code>pfcount</code>。<code>pfadd</code>用于增加计数，<code>pfcount</code>用于获取计数。针对上面的统计页面<code>UV</code>的场景，当用户访问页面时，就使用<code>pfadd</code>指令将<code>用户id</code>添加到<code>HyperLogLog</code>中，最后执行<code>pfcount</code>就能获取到页面<code>UV</code>。</p>
<h2 id="HyperLogLog算法介绍"><a href="#HyperLogLog算法介绍" class="headerlink" title="HyperLogLog算法介绍"></a>HyperLogLog算法介绍</h2><p>实际上，<strong><code>HyperLogLog</code>是一种够提供不精确的去重计的算法</strong>。存在以下的特点：</p>
<ol>
<li>能够使用极少的内存来统计巨量的数据，在<code>Redis</code>中实现的<code>HyperLogLog</code>，只需要12K内存就能统计<code>2^64</code>个数据。</li>
<li>计数存在一定的误差，误差率整体较低。标准误差为<code>0.81%</code>。</li>
<li>误差可以被设置辅助计算因子进行降低。</li>
</ol>
<h3 id="伯努利试验"><a href="#伯努利试验" class="headerlink" title="伯努利试验"></a>伯努利试验</h3><blockquote>
<p>伯努利试验是数学概率论中的一部分内容，它的典故来源于抛硬币。</p>
</blockquote>
<p>硬币拥有正反两面，每次的上抛至落下，出现正反面的概率都是<code>1/2</code>。第一次出现正面的概率是<code>1/2</code>，连续2次出现正面的概率就是<code>1/4</code>, 连续出现<code>K</code>次正面的概率就是<code>2^(-k)</code>。假设一直抛硬币，直到它出现正面为止，我们记录为一次完整的试验，中间可能抛了一次就出现了正面，也可能抛了4次才出现正面。无论抛了多少次，只要出现了正面，就记录为一次试验。这个试验就是伯努利试验。</p>
<p>那么对于<code>n</code>次的伯努利试验，假设每次伯努利试验所经历了的抛掷次数为<code>k</code>。那么第一次伯努利试验，次数设为<code>k1</code>，以此类推，第<code>n</code>次对应的是<code>kn</code>。其中，对于这<code>n</code>次伯努利试验中，必然会有一个最大的抛掷次数<code>k_max</code>。</p>
<p>最终结合极大似然估算的方法，发现在<code>n</code>和<code>k_max</code>中存在估算关联：<code>n * 2^(-k_max)=1</code>，即<code>n = 2^(k_max)</code>。</p>
<h3 id="估算优化"><a href="#估算优化" class="headerlink" title="估算优化"></a>估算优化</h3><p>我们只进行<code>n</code>次伯努利试验称为一轮实验。当<code>n</code>足够大的时候，估算的误差率会相对减少，但仍然不够小。<br>但是如果我们进行更多轮次实验，然后再取每轮的 <code>k_max</code>的平均数。最终再估算出 <code>n</code>，这样子的误差就会相对减少很多。下面是LogLog的估算公式：<br><img data-src="https://chentianming11.github.io/images/redis/loglog.webp" alt="loglog"></p>
<p>上面公式的<code>DVLL</code>对应的就是<code>n</code>，<code>constant</code>是修正因子，它的具体值是不定的，可以根据实际情况而分支设置。<code>m</code>代表的是试验的轮数。头上有一横的<code>R</code>就是平均数：<code>(k_max_1 + ... + k_max_m)/m</code>。</p>
<p>这种通过增加试验轮次，再取<code>k_max</code>平均数的算法优化就是LogLog的做法。而 <code>HyperLogLog</code>和<code>LogLog</code>的区别就是，它采用的不是平均数，而是调和平均数。<em>调和平均数比平均数的好处就是不容易受到大的数值的影响</em>。下面举个例子：<br><img data-src="https://chentianming11.github.io/images/redis/hyperloglog.webp" alt="hyperloglog"></p>
<h3 id="程序实现"><a href="#程序实现" class="headerlink" title="程序实现"></a>程序实现</h3><p>通过上面的内容我们已经知道，在抛硬币的例子中，<strong>可以通过一次伯努利试验中出现的<code>k_max</code>来估算<code>n</code></strong>。</p>
<h4 id="将数据转换为比特串"><a href="#将数据转换为比特串" class="headerlink" title="将数据转换为比特串"></a>将数据转换为比特串</h4><p>通过<code>hash</code>函数，将数据转换为<strong>比特串</strong>，例如输入<code>5</code>，可以转换为为：<code>101</code>。这么做的目的是和抛硬币对上，在比特串中，<code>0</code>代表反面，<code>1</code>代表正面。如果一个数据最终被转化了<code>10010000</code>，那么从右往左看，我们可以认为，首次出现<code>1</code>的时候，就是正面。基于上面的估算结论，我们可以根据存入数据中，转化后的出现了<code>1</code>的最大的位置<code>k_max</code>来估算存入了多少数据，即<code>n = 2^(k_max)</code>。</p>
<h4 id="分桶"><a href="#分桶" class="headerlink" title="分桶"></a>分桶</h4><p>分桶就是分多少轮。具体到程序实现上，就是将输入数据<code>hash</code>转换为<strong>比特串</strong>的时候，先确定桶号，然后再将第一个出现<code>1</code>的个位数值设置到该桶中。</p>
<h2 id="Redis中的HyperLogLog实现"><a href="#Redis中的HyperLogLog实现" class="headerlink" title="Redis中的HyperLogLog实现"></a>Redis中的HyperLogLog实现</h2><p>在<code>Redis</code>中的<code>HyperLogLog</code>中，共分为<code>2^14</code>个桶，每个桶有<code>6</code>个<code>bit</code>，占用内存为=<code>2^14*6/8/1024=12K</code>。<br><img data-src="https://chentianming11.github.io/images/redis/redis-hyperloglog.webp" alt="redis-hyperloglog"></p>
<p>当我们执行命令<code>pfadd key value</code>时，首先会通过<code>hash</code>函数将<code>value</code>转换为<code>64</code>位比特串。其中，前14位用来确定分桶(刚好有<code>2^14</code>个桶)，后<code>50</code>位用来获取第一个出现<code>1</code>的位数(从右向左)，因为最大为<code>50</code>，因此使用<code>6</code>个<code>bit</code>完全可以表示。<br><img data-src="https://chentianming11.github.io/images/redis/pfadd.webp" alt="pfadd"></p>
<p>不同的<code>value</code>，会被设置到不同桶中去，如果出现了在同一个桶的，但是后面第一个出现<code>1</code>的位数不同。那么比较这个桶新的值是否比原来的值大，如果大于，则替换。否则，保持不变。</p>
<p>最终，<code>2^14</code>个桶都保存了出现<code>1</code>的最大值<code>k_max</code>，此时调用<code>pfcount</code>时，按照前面介绍的估算方式，便可以计算出<code>key</code>的设置了多少次<code>valu</code>，也就是统计值，即<code>2^14*2^(k_max平均)</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://juejin.im/post/6844903785744056333" target="_blank" rel="noopener">https://juejin.im/post/6844903785744056333</a></li>
<li><a href="https://juejin.im/post/6844903667712294919" target="_blank" rel="noopener">https://juejin.im/post/6844903667712294919</a></li>
</ol>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解Redis持久化机制-RDB、AOF实现详解</title>
    <url>/posts/4169530895/</url>
    <content><![CDATA[<p><code>Redis</code>是一个基于内存中的数据结构存储系统，它所有的数据都存储在内存中。如果发生断电或者宕机，内存中的数据就会丢失。为了防止数据丢失，<code>Redis</code>提供了两种持久化的方案，一种是<code>RDB(Redis DataBase)</code>，另一种是<code>AOF(Append Only File)</code>。</p>
<a id="more"></a>

<blockquote>
<p>本文主要内容参考自《Redis设计与实现》</p>
</blockquote>
<h2 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h2><p><strong><code>RDB</code>持久化指的是将某个时间点上的数据库状态保存到一个<code>RDB</code>文件中，在启动的时候，可以通过<code>RDB</code>文件将数据库状态还原回来</strong>。<br><img data-src="https://chentianming11.github.io/images/redis/rdb.png" alt="rdb"></p>
<h3 id="RDB文件的创建和载入"><a href="#RDB文件的创建和载入" class="headerlink" title="RDB文件的创建和载入"></a>RDB文件的创建和载入</h3><p>有2个<code>Redis</code>命令可以生成<code>RDB</code>文件，一个是<code>SAVE</code>，另一个是<code>BGSAVE</code>。<code>SAVE</code>命令会阻塞<code>Redis</code>服务进程，直到<code>RDB</code>文件创建完成为止，在此期间，客户端所有命令请求都会被阻塞。而<code>BGSAVE</code>命令会派生出一个子进程，由子进程负责创建<code>RDB</code>文件，服务器进程继续处理命令请求。当然，在<code>BGSAVE</code>期间，服务器处理<code>SAVE</code>、<code>BGSAVE</code>和<code>BGREWRITEAOP</code>三个命令的方式会有所不同。具体来说就是，在<code>BGSAVE</code>期间，服务器会拒绝执行<code>SAVE</code>、<code>BGSAVE</code>命令（防止产出竞争）；对于<code>BGREWRITEAOP</code>命令，服务器会延迟到<code>BGSAVE</code>执行完成才真正开始执行。</p>
<p>创建<code>RDB</code>文件实际上由<code>rdb.c/rdbSave</code>函数完成，<code>SAVE</code>和<code>BGSAVE</code>命令会以不同的方式调用该函数，伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SAVE</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建RDB文件</span></span><br><span class="line">    rdbSave()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BGSAVE</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建子进程</span></span><br><span class="line">    pid = fork()</span><br><span class="line">    <span class="keyword">if</span> pid == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 子进程负责创建RDB文件</span></span><br><span class="line">        rdbSave()</span><br><span class="line">        <span class="comment"># 完成之后向父进程发送信号</span></span><br><span class="line">        signal_parent()</span><br><span class="line">    <span class="keyword">elif</span> pid &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 父进程继续处理命令请求，并通过轮询等待子进程信号</span></span><br><span class="line">        handle_request_and_wait_sifnal()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 处理出错</span></span><br><span class="line">        handle_fork_error()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>由<code>fork</code>创建的新进程被称为子进程（<code>child process</code>）。<strong>该函数被调用一次，但返回两次</strong>。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新进程（子进程）的进程id。<code>fork</code>之后，操作系统会复制一个与父进程完全相同的子进程，虽说是父子关系，但是在操作系统看来，他们更像兄弟关系，这2个进程共享代码空间，但是数据空间是互相独立的，子进程数据空间中的内容是父进程的完整拷贝，指令指针也完全相同，子进程拥有父进程当前运行到的位置。具体可参考<a href="https://blog.csdn.net/koudaidai/article/details/8014782" target="_blank" rel="noopener">fork出的子进程和父进程</a>。</p>
</blockquote>
<p><code>RDB</code>文件载入是在<code>Redis</code>启动的时候自动执行的。在服务只开启<code>RDB</code>持久化时，只要在启动的时候检测到<code>RDB</code>文件，就会执行自动载入。在<code>RDB</code>文件载入期间，服务器会一直处理阻塞状态，直到载入完成为止。</p>
<h3 id="自动间隔保存"><a href="#自动间隔保存" class="headerlink" title="自动间隔保存"></a>自动间隔保存</h3><p>除了手动执行<code>SAVE</code>或者<code>BGSAVE</code>命令来创建<code>RDB</code>文件，<code>Redis</code>还支持通过设置服务器配置的<code>save</code>选项，让服务器每隔一段时间自动执行<code>BGSAVE</code>命令。</p>
<p>用户可以设置多个保存条件，只要其中一个条件被满足，服务器就会执行<code>BGSAVE</code>命令。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>那么满足以下任意一个条件，<code>BGSAVE</code>命令就会被执行：</p>
<ol>
<li>服务器在900秒之内，对数据库进行了至少1次修改。</li>
<li>服务器在300秒之内，对数据库进行了至少10次修改。</li>
<li>服务器在60秒之内，对数据库进行了至少10000次修改。</li>
</ol>
<h3 id="RDB文件结构"><a href="#RDB文件结构" class="headerlink" title="RDB文件结构"></a>RDB文件结构</h3><p>一个完整<code>RDB</code>文件包含的各个部分如下图所示：<br><img data-src="https://chentianming11.github.io/images/redis/rdbfile.png" alt="rdbfile"></p>
<blockquote>
<p>为了方便区分变量、数据和常量，本文用全大写单词表示常量，用全小写单词表示变量和数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th>数据部分</th>
<th>数据类型</th>
<th>长度</th>
<th>数据含义</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS</td>
<td>常量</td>
<td>5字节</td>
<td><code>RDB</code>文件标识，用来快速检查载入的文件是否是<code>RDB</code>文件</td>
</tr>
<tr>
<td>db_version</td>
<td>变量</td>
<td>4字节</td>
<td><code>RDB</code>文件版本号</td>
</tr>
<tr>
<td>database</td>
<td>数据</td>
<td>不定</td>
<td><code>Redis</code>各个非空数据库状态</td>
</tr>
<tr>
<td>EOF</td>
<td>常量</td>
<td>1字节</td>
<td>标志着<code>RDB</code>文件正文内容结束</td>
</tr>
<tr>
<td>check_sum</td>
<td>变量</td>
<td>8字节</td>
<td>校验和，根据前面4部分计算而来，用来检查<code>RDB</code>文件完整性</td>
</tr>
</tbody></table>
<h4 id="database部分"><a href="#database部分" class="headerlink" title="database部分"></a>database部分</h4><p><code>database</code>部分保存了任意多个非空数据库状态，对于每一个非空数据库，<code>database</code>结构如下：<br><img data-src="https://chentianming11.github.io/images/redis/rdb-database.png" alt="rdb-database"></p>
<table>
<thead>
<tr>
<th>数据部分</th>
<th>数据类型</th>
<th>长度</th>
<th>数据含义</th>
</tr>
</thead>
<tbody><tr>
<td>SELECT_DB</td>
<td>常量</td>
<td>1字节</td>
<td>数据库开头标识</td>
</tr>
<tr>
<td>db_number</td>
<td>变量</td>
<td>1-5个字节</td>
<td>数据库开头号码</td>
</tr>
<tr>
<td>key_value_pairs</td>
<td>数据</td>
<td>不定</td>
<td>数据库所有键值对数据</td>
</tr>
</tbody></table>
<h4 id="key-value-pairs部分"><a href="#key-value-pairs部分" class="headerlink" title="key_value_pairs部分"></a>key_value_pairs部分</h4><p><code>key_value_pairs</code>部分保存了一个数据所有的键值对数据，其中不带过期时间的键值对有<code>TYPE</code>、<code>key</code>、<code>value</code>三部分组成，带过期时间的话，会在前面多出<code>EXPIRETIME_MS</code>和<code>ms</code>两部分。<br><img data-src="https://chentianming11.github.io/images/redis/rdb-kv.png" alt="rdb-kv"></p>
<table>
<thead>
<tr>
<th>数据部分</th>
<th>数据类型</th>
<th>长度</th>
<th>数据含义</th>
</tr>
</thead>
<tbody><tr>
<td>EXPIRETIME_MS</td>
<td>常量</td>
<td>1字节</td>
<td>键值对过期时间标识</td>
</tr>
<tr>
<td>ms</td>
<td>变量</td>
<td>8字节</td>
<td>键值对的过期时间（毫秒）</td>
</tr>
<tr>
<td>TYPE</td>
<td>常量</td>
<td>1字节</td>
<td>数据库值的类型</td>
</tr>
<tr>
<td>key</td>
<td>变量</td>
<td>不定</td>
<td>数据库键，永远是字符串对象</td>
</tr>
<tr>
<td>value</td>
<td>变量</td>
<td>不定</td>
<td>数据库值，根据<code>TYPE</code>不用，<code>value</code>保存结构也不同</td>
</tr>
</tbody></table>
<blockquote>
<p>每个<code>value</code>都保存着一个值对象，每个值对象的类型由<code>TYPE</code>字段记录。根据<code>TYPE</code>类型不同，<code>value</code>部分的结构、长度也会有所不同。这块思想上跟内存中底层数据结构类似，这里就不展开细讲了。</p>
</blockquote>
<p>至此，一个<code>RDB</code>文件完整的部分就出来了，如下所示：<br><img data-src="https://chentianming11.github.io/images/redis/rdb-all.png" alt="rdb-all"></p>
<h2 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h2><p>除了<code>RDB</code>持久化之外，<code>Redis</code>还支持<code>AOF</code>持久化功能。<strong><code>AOF</code>持久化是通过保存<code>Redis</code>服务器执行的写命令来记录数据库状态的</strong>。<br><img data-src="https://chentianming11.github.io/images/redis/aof.png" alt="aof"></p>
<p>被写入<code>AOF</code>文件的所有命令都是以<code>Redis</code>的命令请求协议格式保存的，因为<code>Redis</code>的命令请求协议格式是纯文本格式。服务器在启动的时候，可以通过载入并重放<code>AOF</code>文件的命令来还原数据库状态。</p>
<h3 id="AOF持久化的实现"><a href="#AOF持久化的实现" class="headerlink" title="AOF持久化的实现"></a>AOF持久化的实现</h3><p><code>AOF</code>持久化实现可以分为以下三个步骤：</p>
<ol>
<li>命令追加</li>
<li>文件写入</li>
<li>文件同步（刷盘）</li>
</ol>
<h4 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h4><p>当启用<code>AOF</code>持久化的时候，服务器在执行完一个写命令之后，会将该命令追加到<code>aof_buf</code>缓存区的末尾。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// AOF缓冲区</span></span><br><span class="line">    sds aof_buf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h4><p><code>Redis</code>服务器进程是一个事件循环，循环中的文件事件负责接收客户端的命令请求和发送命令回复，而时间事件则负责执行像<code>serverCorn</code>函数这样需要定时运行的函数。因为处理文件事件会包含写命令，使得一些内容追加到<code>aof_buf</code>缓冲区中，所以在事件循环结束前还需要调用<code>flushAppendOnlyFile</code>函数，决定是否需要将<code>aof_buf</code>缓冲区的内容写入并同步到<code>AOF</code>文件中。伪代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventLoop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理文件事件，接收命令请求和发送命令回复</span></span><br><span class="line">        <span class="comment"># 将写命令追加到aof_buf缓存区中</span></span><br><span class="line">        processFileEvents()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理时间事件</span></span><br><span class="line">        processTimeEvents()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将aof_buf缓存区写入并同步在AOF文件中</span></span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure>

<p><code>flushAppendOnlyFile</code>函数由配置项<code>appendfsync</code>决定：</p>
<table>
<thead>
<tr>
<th><code>appendfsync</code>的值</th>
<th><code>flushAppendOnlyFile</code>函数行为</th>
</tr>
</thead>
<tbody><tr>
<td>always</td>
<td>每次都将<code>aof_buf</code>缓冲区数据写入并同步到<code>AOF</code>文件中</td>
</tr>
<tr>
<td>everysec（默认）</td>
<td>每次都将<code>aof_buf</code>缓冲区数据写入<code>AOF</code>文件中，但是每隔1秒进行进行AOF文件同步</td>
</tr>
<tr>
<td>no</td>
<td>每次都将<code>aof_buf</code>缓冲区数据写入<code>AOF</code>文件中，文件同步完全由操作系统控制</td>
</tr>
</tbody></table>
<h3 id="AOF文件载入与数据还原"><a href="#AOF文件载入与数据还原" class="headerlink" title="AOF文件载入与数据还原"></a>AOF文件载入与数据还原</h3><p>因为<code>AOF</code>文件中包含了所有的写命令，所以在服务器启动的时候，只需要载入并重放<code>AOF</code>文件的命令就能够恢复到数据库原来的状态。具体步骤如下：</p>
<ol>
<li>创建一个不带网络连接的伪客户端(fake client)。</li>
<li>从<code>AOF</code>文件中读出一条写命令。</li>
<li>使用伪客户端执行命令。</li>
<li>一直执行步骤二和三，直到<code>AOF</code>文件中的所有命令都执行完。</li>
</ol>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h3><p>因为<code>AOF</code>持久化是通过追加命令的方式实现的，所以随着服务器运行，<code>AOF</code>文件体积也会越来越大。如果不加以控制，不仅会对整个<code>Redis</code>服务器造成不好的影响，而且还会导致<code>AOF</code>命令重放时间过长。<strong>为了解决<code>AOF</code>文件体积膨胀的问题，<code>Redis</code>支持了<code>AOF</code>文件重写功能</strong>。通过该功能，可以实现创建一个体积小的多的<code>AOF</code>文件来代替现有的<code>AOF</code>文件。</p>
<h4 id="AOF重写的实现"><a href="#AOF重写的实现" class="headerlink" title="AOF重写的实现"></a>AOF重写的实现</h4><p>虽然叫<code>AOF</code>重写，但实际上并不是对现有的<code>AOF</code>文件进行读取、分析和重新写入。实际上，<strong><code>AOF</code>重写是通过读取服务器当前数据库状态来实现的</strong>。<strong>首先从数据库中读取现有的键值，然后用一条命令去记录键值对，代替之前记录的针对该键的多条命令，这就是<code>AOF</code>重写的原理</strong>。</p>
<h4 id="AOF后台重写"><a href="#AOF后台重写" class="headerlink" title="AOF后台重写"></a>AOF后台重写</h4><p>AOF重写需要遍历整个数据库并把所有键值对都以命令的形式记录下来，很明显，这是一个非常耗费时间的事情。如果有服务器进程直接执行<code>AOF</code>重写，那么整个服务器将会被阻塞，这对于<code>Redis</code>来说显然是不能接受的。因此，<code>Redis</code>支持<code>AOF</code>后台重写功能，具体来讲就是由子进程处理<code>AOF</code>重写。</p>
<p>不过，<code>AOF</code>后台重写也有一个问题需要解决。因为在<code>AOF</code>后台重写期间，主进程仍然可以处理写命令，新的命令仍然会改变现有的数据库状态，最终就会导致<code>AOF</code>后台重写的文件保存的数据库状态和当前的数据库状态不一致。</p>
<p><strong>为了解决上述的数据不一致的问题，<code>Redis</code>服务器设置了一个<code>AOF</code>重写缓存区</strong>。这个缓存区在创建子进程之后开始使用，此时<code>Redis</code>服务器执行完写命令之后，会同时将这个命令发送到<code>AOF</code>缓冲区和<code>AOF</code>重写缓存区。<br><img data-src="https://chentianming11.github.io/images/redis/aof-rewrite.png" alt="aof-rewrite"></p>
<p>这么做就能保证：</p>
<ol>
<li><code>AOF</code>缓冲区的内容会正常写入和同步到现有<code>AOF</code>文件中，现有<code>AOF</code>文件依然可以正常处理。</li>
<li><code>AOF</code>后台重写期间，所有新加入的写命令都会保存在<code>AOF</code>重写缓存区中。再<code>AOF</code>后台重写完成之后，再将<code>AOF</code>重写缓存区的内容追加到新的<code>AOF</code>文件中即可，最后再用新的<code>AOF</code>文件替换之前的<code>AOF</code>文件。</li>
</ol>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis分布式-集群详解</title>
    <url>/posts/2663121991/</url>
    <content><![CDATA[<p><strong>Redis集群通过分片来进行数据共享，并提供复制和故障转移功能</strong>。本文将对集群的节点、槽指派、命令执行、重新分片、转向、故障转移等各个方面进行介绍。</p>
<a id="more"></a>

<blockquote>
<p>本文主要内容参考自《Redis设计与实现》</p>
</blockquote>
<h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p><strong>一个Redis集群通常由多个节点(node)组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中</strong>。可以通过<code>CLUSTER MEET</code>命令来连接各个节点，从而构建一个包含多节点集群。命令格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure>

<p><strong>当一个节点执行<code>CLUSTER MEET</code>命令，就可以将对应<code>ip</code>和<code>port</code>的节点加入到自己当前所在的集群中</strong>（首先会进行握手，握手成功后才添加进来）。假设现在有三个节点，ip都是<code>127.0.0.1</code>，端口分别是<code>7000</code>、<code>7001</code>、<code>7002</code>。当在<code>7000</code>端口上的节点执行<code>CLUSTER MEET 127.0.0.1 7001</code>，就会将<code>7001</code>节点加入到<code>7000</code>节点所在的集群中。在<code>7000</code>端口上的节点再执行<code>CLUSTER MEET 127.0.0.1 7002</code>时，就会将<code>7002</code>节点也加入到<code>7000</code>节点所在的集群中。至此，这三个节点就组成了一个集群。<br><img data-src="https://chentianming11.github.io/images/redis/cluster-node.png" alt="cluster-node"></p>
<h3 id="启动节点"><a href="#启动节点" class="headerlink" title="启动节点"></a>启动节点</h3><p><strong>一个节点就是一个运行在集群模式下的Redis服务器，Redis服务器在启动的时候根据<code>cluster-enabled</code>配置项的值来决定是否开启集群模式</strong>。如果是<code>yes</code>，开启集群模式成为一个节点；否则，开启单机模式成为一个普通服务器。</p>
<p>节点会继续使用<code>redisServer</code>结构保存服务器状态，使用<code>redisClient</code>结构保存客户端状态，至于那些只在集群模式下才会用到的数据，节点将它们保存在<code>cluster.h/clusterNode</code>结构，<code>cluster.h/clusterLink</code>结构和<code>cluster.h/clusterState</code>结构里面。</p>
<h3 id="集群数据结构"><a href="#集群数据结构" class="headerlink" title="集群数据结构"></a>集群数据结构</h3><p><code>clusterNode</code>结构保存了节点的当前状态，比如节点的创建时间、节点的名字、节点当前的配置纪元、节点的IP和端口等等。<strong>每个节点都会使用一个<code>clusterNode</code>结构记录自己的状态，并且会为集群中所有其他节点都创建一个相应的<code>clusterNode</code>结构</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的名字，由40个十六进制字符组成</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点标识</span></span><br><span class="line">    <span class="comment">// 使用不同的标识值记录节点的角色（比如主节点或者从节点）</span></span><br><span class="line">    <span class="comment">// 以及节点目前所处的状态（比如在线或者下线）</span></span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的IP地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的端口号</span></span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>clusterNode结构的link属性是一个clusterLink结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输入缓存区和输出缓存区：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    <span class="comment">// 连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出缓存区，保存着等待发送给其它节点的消息</span></span><br><span class="line">    sds sndbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入缓存区，保存着从其他节点接收到的消息</span></span><br><span class="line">    sds rcvbuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与这个连接相关联的节点，如果没有的话为NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure>

<p>最后，每个节点都保存着一个<code>RedisState</code>结构，记录了在当前节点视角下，集群目前所处的状态。例如集群是在线还是下线，集群中包含多少个节点，集群当前的配置纪元等。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 指向当前节点的指针</span></span><br><span class="line">    clusterNode *myself;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">unit64_t</span> currentEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群当前的状态：是在线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群中至少处理着一个槽的节点数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 集群节点名单</span></span><br><span class="line">    dict *nodes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>

<p>以前面介绍的7000、7001和7002为例，下图展示了节点7000创建的<code>clusterState</code>结构，这个结构从7000这个节点角度记录了集群以及集群包含的三个节点的当前状态。<br><img data-src="https://chentianming11.github.io/images/redis/cluster-state.png" alt="cluster-state"></p>
<ul>
<li><code>currentEpoch</code>的属性值为0，表示集群当前的配置纪元为0</li>
<li><code>size</code>属性值为0，表示集群目前没有任何节点在处理槽，因此<code>state</code>为<code>REDIS_CLUSTER_FAIL</code>，表示节点处于下线状态。</li>
<li><code>nodes</code>属性记录了集群目前包含的三个节点</li>
<li>三个节点的<code>flags</code>属性都是<code>REDIS_NODE_MASTER</code>，表示三个节点都是主节点。</li>
</ul>
<h2 id="槽指派"><a href="#槽指派" class="headerlink" title="槽指派"></a>槽指派</h2><p><strong>Redis集群通过分片的方式来保存数据库中的键值对：集群的数据库被分为16384个槽(slot)，数据库中的每个键都属于这16384个槽中的一个，集群中的每个节点可以处理0个或者最多16384个槽</strong>。</p>
<p><strong>当数据库中的16384个槽都有节点在处理时，集群处于上线状态(ok)，否则处理下线状态(fail)</strong>。</p>
<p>在上一节中，我们将7000、7001和7002三个节点连接到同一集群，不过此时，这个集群仍然处于下线状态，因为集群中的三个节点都没有在处理任何槽。通过向节点发送<code>CLUSTER ADDSLOTS</code>命令，可以将一个或者多个槽指派(assgin)给节点负责。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CLUSTER ADDSLOTS &lt;slot&gt; [slot ...]</span><br></pre></td></tr></table></figure>

<p>比如，我们可以将<code>0-5000</code>指派给7000负责，<code>5001-100000</code>指派给7002负责，<code>10001-16383</code>指派给7002负责。当完成指派之后，整个集群就会处于上线状态。</p>
<h3 id="记录节点的槽指派信息"><a href="#记录节点的槽指派信息" class="headerlink" title="记录节点的槽指派信息"></a>记录节点的槽指派信息</h3><p><code>clusterNode</code>结构的<code>slots</code>属性和<code>numslot</code>属性记录了节点负责处理的哪些槽：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>slots</code>属性是一个二进制数组，长度为<code>16384/8=2048</code>个字节，共<code>16384</code>位，刚好对应<code>16384</code>个槽。如果二进制位是1，那么该位置的槽就由当前节点处理。<code>numslot</code>属性记录了<code>slots</code>二进制数组中值为1的个数，也就是当前节点处理的槽的数量。</p>
<h3 id="传播节点的槽指派信息"><a href="#传播节点的槽指派信息" class="headerlink" title="传播节点的槽指派信息"></a>传播节点的槽指派信息</h3><p>一个节点除了会将自己负责处理的槽记录在<code>clusterNode</code>结构的<code>slots</code>属性和<code>numslot</code>属性中，还会将其发送给集群中的其它节点。这样的话，<strong>集群中的每个节点都会知道数据库中的16384个槽被指派给了哪些节点</strong>。</p>
<h3 id="记录集群所有的槽指派信息"><a href="#记录集群所有的槽指派信息" class="headerlink" title="记录集群所有的槽指派信息"></a>记录集群所有的槽指派信息</h3><p>通过前面的记录节点的槽指派信息和传播节点的槽指派信息，实际上集群中的每个节点都会知道数据库中的16384个槽被指派给了哪些节点。但是具体要知道某个槽对应的节点，上述的数据结构的时间复杂度是<code>O(N)</code>。为了提高效率，<code>clusterState</code>结构中的<code>slots</code>数组记录了所有16384个槽的指派信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    clusterNode *slots[<span class="number">16384</span>];</span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>

<p><code>slots</code>数组包含16384个项，每个项是指向<code>clusterNode</code>的指针。这样的话，要知道某个槽对应的节点，时间复杂度就是<code>O(1)</code>。如果<code>slots[i]</code>指向<code>NULL</code>，就表示这个槽位没有被指派。</p>
<h2 id="在集群中执行命令"><a href="#在集群中执行命令" class="headerlink" title="在集群中执行命令"></a>在集群中执行命令</h2><p>在对数据16384个槽进行指派之后，集群就会进入上线状态。这时客户端节能向集群发送命令了。当客户端向节点发送与数据库键有关命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，然后检查这个槽是否指派给了自己：</p>
<ul>
<li>如果指派给了自己，那么当前节点直接执行这个命令。</li>
<li>如果指派给了其它节点，那么当前节点会向客户端返回<code>MOVED</code>错误(包含这个键所属的节点)，客户端再转向正确的节点发送数据命令。</li>
</ul>
<p><img data-src="https://chentianming11.github.io/images/redis/cluster-command.png" alt="cluster-command"></p>
<h3 id="计算键属于哪个槽"><a href="#计算键属于哪个槽" class="headerlink" title="计算键属于哪个槽"></a>计算键属于哪个槽</h3><p>节点使用一下算法来计算给定键key属于哪个槽：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">def <span class="title">slot_number</span><span class="params">(key)</span>:</span></span><br><span class="line"><span class="function">    <span class="keyword">return</span> <span class="title">CRC16</span><span class="params">(key)</span> &amp; 16383</span></span><br></pre></td></tr></table></figure>

<p>使用<code>CLUSTER KEYSLOT &lt;key&gt;</code>命令可以查看给定键属于哪个槽。</p>
<h3 id="命令处理"><a href="#命令处理" class="headerlink" title="命令处理"></a>命令处理</h3><p>当计算出键所属的槽i之后，接下来就会到<code>clusterState.slots[i]</code>找到这个槽对应的节点。如果该节点就是当前节点，那么直接执行命令，否则，返回<code>MOVED</code>错误，<code>MOVED</code>错误格式为<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code>。这样，客户端在收到<code>MOVED</code>错误之后，就能将命令转向给正确的节点执行了。</p>
<h3 id="节点数据库实现"><a href="#节点数据库实现" class="headerlink" title="节点数据库实现"></a>节点数据库实现</h3><p>节点和单机服务器在数据库方面有一个区别，<strong>节点只能使用0号数据库</strong>。另外，除了将键值对保存在数据库之外，节点还会用<code>clusterState</code>结构中的<code>slots_to_keys</code>跳跃表来保存槽和键的关系。跳跃表的<code>score</code>是槽号，<code>value</code>是数据库键。<strong>通过<code>slots_to_keys</code>跳跃表，节点可以很方便的对某个或者某些槽的数据库键进行批量操作</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    zskiplist *slots_to_keys;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>

<h2 id="重新分片"><a href="#重新分片" class="headerlink" title="重新分片"></a>重新分片</h2><p><strong><code>Redis</code>集群的重新分片操作可以将任意数量的已经指派给某个节点（源节点）的槽改为指派给另一个节点（目标节点），并且相关槽所属的键值对也会从源节点移动到目标节点</strong>。</p>
<p>重新分片操作可以在线（online）进行，在重新分片的过程中，集群不需要下线，并且源节点和目标节点都可以继续处理请求。</p>
<p>比如，我们新启动一个端口为7003的服务器，将原本指派给7002的<code>15001-16383</code>的槽改指派给节点7003。</p>
<h3 id="重新分片实现原理"><a href="#重新分片实现原理" class="headerlink" title="重新分片实现原理"></a>重新分片实现原理</h3><p>Redis集群的重新分片操作是由Redis的集群管理软件<code>redis-trib</code>负责执行的。<code>redis-trib</code>对集群单个槽slot重新分片步骤如下：</p>
<ol>
<li><code>redis-trib</code>对目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，让目标节点准备好从源节点导入槽slot的键值对。</li>
<li><code>redis-trib</code>对源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code>命令，让源节点准备好将属于槽slot的键值对迁移(migrate)至目标节点。</li>
<li><code>redis-trib</code>向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;slot&gt; &lt;count&gt;</code>命令，获取最多count个属于槽slot的键名。</li>
<li>对于步骤三的每个键名，<code>redis-trib</code>都向源节点发送一个<code>MIGRATE &lt;target_id&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;time_out&gt;</code>命令，将该键原子地从源节点迁移到目标节点。</li>
<li>重新执行步骤三和四，直到槽slot的键值对全部迁移至目标节点。</li>
<li><code>redis-trib</code>向集群任意一个节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code>命令，将槽slot指派给目标节点。并且指派信息会通过消息发送到整个集群。<br><img data-src="https://chentianming11.github.io/images/redis/cluster-migrate.png" alt="cluster-migrate"></li>
</ol>
<p>如果重新分片涉及多个槽，就对每个槽执行上述步骤。对slot槽进行重新分片过程如下：<br><img data-src="https://chentianming11.github.io/images/redis/cluster-sharding.png" alt="cluster-sharding"></p>
<h3 id="ASK错误"><a href="#ASK错误" class="headerlink" title="ASK错误"></a>ASK错误</h3><p>在重新分片期间，源节点向目标节点迁移一个槽的过程中，可能出现属于被迁移槽的一部分键值对保存在源节点里面，而另一部分键值对则保存在目标节点里面。当客户端向源节点发送数据库键相关的命令，并且数据库键恰好就属于正在被迁移的槽时。<strong>源节点首先会在自己的数据库里面查找该数据库键，如果找到则直接在源节点执行命令，否则，源节点返回一个<code>ASK</code>错误，指引客户端转向目标节点</strong>。<br><img data-src="https://chentianming11.github.io/images/redis/cluster-ask.png" alt="cluster-ask"></p>
<h2 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h2><p><strong><code>Redis</code>集群中的节点分为主节点和从节点，主节点用于处理槽，从节点用于复制某个主节点，并且在主节点下线时代替主节点继续进行客户端命令</strong>。举个栗子，假设有7000、7001、7002、7003四个主节点，其中还有7004和7005作为70000的从节点。当7000节点下线时，会从7004和7005中选举出一个（假设选中了7004）作为代替7000的主节点。当7000重新上线时，7000会作为7004的从节点。<br><img data-src="https://chentianming11.github.io/images/redis/cluster-failover.png" alt="cluster-failover"></p>
<blockquote>
<p>主节点用双圆环表示。</p>
</blockquote>
<h3 id="设置从节点"><a href="#设置从节点" class="headerlink" title="设置从节点"></a>设置从节点</h3><p>向节点发送<code>CLUSTER REPLICATE &lt;node_id&gt;</code>命令，可以让该节点成为<code>node_id</code>的从节点。</p>
<h3 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h3><p>集群中每个节点都会定期向其他节点发送<code>PING</code>消息，以此来检测对方是否在线。如果对方节点在规定时间内没有返回<code>PONG</code>消息，那么发送方节点就会将对应的节点标记为疑似下线状态(PFIAL)。<strong>如果一个集群内，半数以上主节点都将某个主节点x标记为疑似下线状态，那么这个节点x就会被标记为已下线状态(FAIL)</strong>。</p>
<blockquote>
<p>关键词：心跳检测+过半原则</p>
</blockquote>
<h3 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h3><p>当从节点发现自己复制的主节点进入已下线状态时，从节点就开始对下线主节点进行故障转移，以下是故障转移的执行步骤。</p>
<ol>
<li>基于<code>Raft</code>算法，选举出一个从节点。</li>
<li>被选中的从节点执行<code>SLAVEOF no one</code>，成为主节点。</li>
<li>新的主节点会撤销已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>新的主节点向集群广播一条<code>PONG</code>消息，让集群中其它节点知道新的主节点已经代替了已下线主节点。</li>
<li>新的主节点开始接收和处理自己负责的槽有关的命令请求，故障转移完成。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ol>
<li>无中心架构。</li>
<li>数据按照 slot 存储分布在多个节点，节点间数据共享，可动态调整数据分布。</li>
<li>可扩展性，可线性扩展到 1000 个节点(官方推荐不超过 1000 个)，节点可动态添加或删除。</li>
<li>高可用性，部分节点不可用时，集群仍可用。通过增加 Slave 做 standby 数据副本，能够实现故障自动<code>failover</code>，节点之间通过 <code>gossip</code>协议交换状态信息，用<code>Raft</code>投票机制完成<code>Slave</code>到<code>Master</code>的角色提升。</li>
<li>降低运维成本，提高系统的扩展性和可用性。</li>
</ol>
<h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ol>
<li><code>Client</code>实现复杂，驱动要求实现<code>Smart Client</code>，缓存<code>slots mapping</code>信息并及时更新，提高了开发难度，客户端的不成熟影响业务的稳定性。</li>
<li><strong>节点会因为某些原因发生阻塞(阻塞时间大于 clutser-node-timeout)，被判断下线，这种 failover 是没有必要的。</strong></li>
<li>数据通过异步复制，不保证数据的强一致性。</li>
</ol>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis分布式-主从复制详解</title>
    <url>/posts/3441087838/</url>
    <content><![CDATA[<p>在实际生产环境中，为了避免单点故障，<code>Redis</code>肯定不会以单机的形式部署，而是会同时部署多个实例。<strong><code>Redis</code>多机数据库的实现主要有三种方式，分别是主从复制、Sentinel和集群，本文主要会详细阐述主从复制的实现原理</strong>。</p>
<a id="more"></a>

<blockquote>
<p>本文主要内容参考自《Redis设计与实现》</p>
</blockquote>
<h2 id="如何使用主从复制"><a href="#如何使用主从复制" class="headerlink" title="如何使用主从复制"></a>如何使用主从复制</h2><p>在<code>Redis</code>中，可以通过<code>SLAVEOF</code>命令或者设置<code>slaveof</code>选项，可以让一个服务器去复制另一个服务器。被复制的服务器称为主服务器(master)，进行复制的服务器称为从服务器。</p>
<h2 id="旧版复制功能实现"><a href="#旧版复制功能实现" class="headerlink" title="旧版复制功能实现"></a>旧版复制功能实现</h2><p>在2.8版本之前，<code>Redis</code>的复制主要分为<strong>同步(sync)</strong>和<strong>命令传播(command propagate)</strong>两个操作：</p>
<ol>
<li>同步：将从服务器的数据库状态更新成主服务器的数据库状态。</li>
<li>命令传播：将作用于主服务器的写命令，传播给从服务器进行执行，从而保证主从数据库状态一致。</li>
</ol>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>当从服务器刚执行<code>SLAVEOF</code>命令时，首先做的就是同步操作，将从服务器的数据库状态更新成主服务器的数据库状态。</p>
<p>从服务器通过向主服务器发送<code>SYNC</code>命令来完成同步操作，<code>SYNC</code>命令的执行步骤如下：</p>
<ol>
<li>从服务器向主服务器发送<code>SYNC</code>命令。</li>
<li>主服务器收到<code>SYNC</code>命令之后，开始执行<code>BGSAVE</code>命令生成<code>RDB</code>文件。在生成<code>RDB</code>文件期间，将写命令记录在一个缓冲区中。</li>
<li>主服务器发送<code>RDB</code>文件文件给从服务器，从服务器载入该<code>RDB</code>文件。</li>
<li>主服务器发送生成<code>RDB</code>文件期间的写命令给从服务器，从服务器重放这些命令。此时从服务器状态和主服务器状态一致，同步操作完成。</li>
</ol>
<p><img data-src="https://chentianming11.github.io/images/redis/sync.png" alt="sync"></p>
<h3 id="命令传播"><a href="#命令传播" class="headerlink" title="命令传播"></a>命令传播</h3><p>在同步操作完成之后，后续主服务器执行的写命令会以命令传播的方式发送给从服务器，从而保证主从数据库状态一致。</p>
<h3 id="旧版复制功能的缺陷"><a href="#旧版复制功能的缺陷" class="headerlink" title="旧版复制功能的缺陷"></a>旧版复制功能的缺陷</h3><p>当初次复制时，旧版复制功能没有任何问题。但是当因为网络问题，主从服务器短暂掉线重连之后，此时依然会触发复制。<strong>虽然这种方式可以让主从数据库状态重新一致，但是性能和效率都会很低</strong>。因为重连之后的复制，仍然要执行同步操作，生成完整的<code>RDB</code>文件，从服务器依然要载入该<code>RDB</code>文件。实际上，在掉线期间，只是丢失了少量写命令，此时执行完整的复制操作，显然效率太低了。</p>
<h2 id="新版复制功能实现"><a href="#新版复制功能实现" class="headerlink" title="新版复制功能实现"></a>新版复制功能实现</h2><p>为了解决旧版复制功能在掉线重复制的低效问题，在2.8版本之后，<code>Redis</code>使用<code>PSYNC</code>命令代替原来的<code>SYNC</code>命令来执行同步操作。</p>
<p><strong><code>PSYNC</code>命令具有完整重同步(full resynchronization)和部分重同步(patial resynchronization)两种模式</strong>：</p>
<ul>
<li>完整重同步：用于处理初次复制的情况。跟旧版的<code>SYNC</code>命令基本一致，都是让主服务器生成并发送<code>RDB</code>文件和在此期间的写命令给从服务器来完成同步操作的。</li>
<li>部分重同步：用于处理掉线后的重复制情况。当从服务器掉线后重新连接主服务器，如果条件允许，可以让主服务器只将掉线期间执行的写命令发送给从服务器，从而达到主从数据库状态重新一致。</li>
</ul>
<p><img data-src="https://chentianming11.github.io/images/redis/psync.png" alt="psync"></p>
<h2 id="部分重同步实现"><a href="#部分重同步实现" class="headerlink" title="部分重同步实现"></a>部分重同步实现</h2><p>部分重同步功能主要由以下三个部分构成：</p>
<ul>
<li>主服务器的复制偏移量(replication offset)和从服务器的复制偏移量</li>
<li>主服务器的复制积压缓冲区(replication backlog)</li>
<li>服务器运行ID</li>
</ul>
<h3 id="复制偏移量"><a href="#复制偏移量" class="headerlink" title="复制偏移量"></a>复制偏移量</h3><p>执行复制的双方-主服务器和从服务器会分别维护一个复制偏移量：</p>
<ul>
<li>主服务器每次向从服务器传播N个字节的数据时，就会将自己的复制偏移量加N。</li>
<li>从服务器每次收到主服务器传播来的N个字节数据时，也会将自己的复制偏移量加N。</li>
</ul>
<p><strong>如果主从数据库状态一致，那么它们的复制偏移量一定是相等的，反之，则表示数据库状态不一致</strong>。因此当发生掉线重连时，主从服务器的复制偏移量一定不相等。</p>
<h3 id="复制积压缓存区"><a href="#复制积压缓存区" class="headerlink" title="复制积压缓存区"></a>复制积压缓存区</h3><p><strong>复制积压缓存区是由主服务器维护的固定长度的先进先出(FIFO)队列，默认大小为<code>1MB</code>。当主服务器进行命令传播时，不仅会将写命令发送给所有的从服务器，还会将写命令写入复制积压缓冲区中</strong>。因此，复制积压缓冲区会保存最近传播的写命令，并且复制积压缓冲区为每个字节记录了相应的复制偏移量。</p>
<p>当从服务器重连之后，从服务器会通过<code>PSYNC</code>命令将自己的复制偏移量发送给主服务器，主服务器会根据这个偏移量来决定采用哪种同步操作。</p>
<ul>
<li>如果<code>offset</code>偏移量之后的数据仍然存在复制积压缓冲区中，那么采用部分重同步。</li>
<li>如果<code>offset</code>偏移量之后的数据不在复制积压缓冲区中，那么采用完整重同步。</li>
</ul>
<h3 id="服务器运行ID"><a href="#服务器运行ID" class="headerlink" title="服务器运行ID"></a>服务器运行ID</h3><p><strong>每个<code>Redis</code>服务器，不论是主服务器还是从服务器，都会有自己的运行ID。运行ID在服务器启动的时候生成，由40位随机字符组成。当从服务器进行初次复制时，会将对应的主服务器运行ID也保存下来</strong>。通过这个运行ID，就能确定重连上的主服务器是不是掉线之前的主服务器，如果是的话，则尝试之前的部分重同步，反之，则执行完整重同步。</p>
<h3 id="PSYNC命令的实现"><a href="#PSYNC命令的实现" class="headerlink" title="PSYNC命令的实现"></a>PSYNC命令的实现</h3><p>PSYNC命令调用方式有两种：</p>
<ol>
<li>如果从服务器之前没有复制过任何主服务器，那么从服务器在开始一次新的复制时，会发送<code>PSYNC ? -1</code>命令，主动请求完整重同步。</li>
<li>如果从服务器已经复制过主服务器，那么开始一次新的复制时，会发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>命令，主服务根据<code>runid</code>和<code>offset</code>参数决定使用何时复制方式。</li>
</ol>
<p>接收到<code>PSYNC</code>命令的主服务器，可能会返回以下三种结果中的一种给从服务器：</p>
<ol>
<li><code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>：执行完整重同步。其中<code>runid</code>表示主服务器的运行ID，从服务器会将其保存下来；<code>offset</code>是主服务器的复制偏移量，从服务器会将其作为自己的初始偏移量。</li>
<li><code>+CONTINUE</code>：执行部分重同步。主服务器会将缺少的那部分数据发送给从服务器。</li>
<li><code>-ERR</code>：复制错误。表示主服务器版本低于2.8，不能识别<code>PSYNC</code>命令。</li>
</ol>
<p><img data-src="https://chentianming11.github.io/images/redis/psyncshixian.png" alt="psyncshixian"></p>
<h2 id="主从复制的不足"><a href="#主从复制的不足" class="headerlink" title="主从复制的不足"></a>主从复制的不足</h2><p>主从复制解决了数据备份和性能(通过读写分离)的问题，但是还是存在一些不足:</p>
<ol>
<li>RDB 文件过大的情况下，同步非常耗时。</li>
<li>在一主一从或者一主多从的情况下，如果主服务器挂了，对外提供的服务就不可用了，单点问题没有得到解决。如果每次都是手动把之前的从服务器切换成主服务器，这个比较费时费力，还会造成一定时间的服务不可用。</li>
</ol>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>一文读懂Redis常见对象类型的底层数据结构</title>
    <url>/posts/2583560655/</url>
    <content><![CDATA[<p><code>Redis</code>是一个基于内存中的数据结构存储系统，可以用作数据库、缓存和消息中间件。<code>Redis</code>支持五种常见对象类型：字符串(<code>String</code>)、哈希(<code>Hash</code>）、列表(<code>List</code>)、集合(<code>Set</code>)以及有序集合(<code>Zset</code>)，我们在日常工作中也会经常使用它们。知其然，更要知其所以然，本文将会带你读懂这五种常见对象类型的底层数据结构。</p>
<a id="more"></a>

<blockquote>
<p>本文主要内容参考自《Redis设计与实现》</p>
</blockquote>
<h2 id="对象类型和编码"><a href="#对象类型和编码" class="headerlink" title="对象类型和编码"></a>对象类型和编码</h2><p><strong><code>Redis</code>使用对象来存储键和值的，在<code>Redis</code>中，每个对象都由<code>redisObject</code>结构表示</strong>。<code>redisObject</code>结构主要包含三个属性：<code>type</code>、<code>encoding</code>和<code>ptr</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="comment">// 底层数据结构的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><strong>其中<code>type</code>属性记录了对象的类型，对于<code>Redis</code>来说，键对象总是字符串类型，值对象可以是任意支持的类型</strong>。因此，当我们说<code>Redis</code>键采用哪种对象类型的时候，指的是对应的值采用哪种对象类型。</p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象类型名称</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
</tr>
</tbody></table>
<p><strong><code>*ptr</code>属性指向了对象的底层数据结构，而这些数据结构由<code>encoding</code>属性决定</strong>。</p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码对应的底层数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_ENCODING_INT</td>
<td>long类型的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>emstr编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody></table>
<p><strong>之所以由<code>encoding</code>属性来决定对象的底层数据结构，是为了实现同一对象类型，支持不同的底层实现</strong>。这样就能在不同场景下，使用不同的底层数据结构，进而极大提升<code>Redis</code>的灵活性和效率。</p>
<blockquote>
<p>底层数据结构后面会详细讲解，这里简单看一下即可。</p>
</blockquote>
<h2 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h2><p>字符串是我们日常工作中用得最多的对象类型，它对应的编码可以是<code>int</code>、<code>raw</code>和<code>embstr</code>。<strong>字符串对象相关命令可参考：<a href="http://www.redis.cn/commands.html#string" target="_blank" rel="noopener">Redis命令-Strings</a></strong>。</p>
<p>如果一个字符串对象保存的是不超过<code>long</code>类型的整数值，此时编码类型即为<code>int</code>，其底层数据结构直接就是<code>long</code>类型。例如执行<code>set number 10086</code>，就会创建<code>int</code>编码的字符串对象作为<code>number</code>键的值。<br><img data-src="https://chentianming11.github.io/images/redis/redis-encoding-int.png" alt="redis-encoding-int"></p>
<p>如果字符串对象保存的是一个长度大于39字节的字符串，此时编码类型即为<code>raw</code>，其底层数据结构是简单动态字符串(<code>SDS</code>)；如果长度小于等于39个字节，编码类型则为<code>embstr</code>，底层数据结构就是<code>embstr</code>编码<code>SDS</code>。下面，我们详细理解下什么是简单动态字符串。</p>
<h3 id="简单动态字符串"><a href="#简单动态字符串" class="headerlink" title="简单动态字符串"></a>简单动态字符串</h3><h4 id="SDS定义"><a href="#SDS定义" class="headerlink" title="SDS定义"></a>SDS定义</h4><p>在<code>Redis</code>中，使用<code>sdshdr</code>数据结构表示<code>SDS</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 字符串长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="comment">// buf数组中未使用的字节数</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong><code>SDS</code>遵循了C字符串以空字符结尾的惯例，保存空字符的1字节不会计算在<code>len</code>属性里面</strong>。例如，<code>Redis</code>这个字符串在<code>SDS</code>里面的数据可能是如下形式：<br><img data-src="https://chentianming11.github.io/images/redis/sdshdr.png" alt="sdshdr"></p>
<h4 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h4><p>C语言使用长度为<code>N+1</code>的字符数组来表示长度为<code>N</code>的字符串，并且字符串的最后一个元素是空字符<code>\0</code>。<code>Redis</code>采用<code>SDS</code>相对于C字符串有如下几个优势：</p>
<ol>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串时带来的内存重分配次数</li>
<li>二进制安全</li>
</ol>
<h5 id="常数复杂度获取字符串长度"><a href="#常数复杂度获取字符串长度" class="headerlink" title="常数复杂度获取字符串长度"></a>常数复杂度获取字符串长度</h5><p>因为C字符串并不记录自身的长度信息，所以为了获取字符串的长度，必须遍历整个字符串，时间复杂度是<code>O(N)</code>；而<code>SDS</code>使用<code>len</code>属性记录了字符串的长度，因此获取<code>SDS</code>字符串长度的时间复杂度是<code>O(1)</code>。</p>
<h5 id="杜绝缓冲区溢出"><a href="#杜绝缓冲区溢出" class="headerlink" title="杜绝缓冲区溢出"></a>杜绝缓冲区溢出</h5><p><strong>C字符串不记录自身长度带来的另一个问题是很容易造成缓存区溢出</strong>。比如使用字符串拼接函数(<code>stract</code>)的时候，很容易覆盖掉字符数组原有的数据。与C字符串不同，<strong><code>SDS</code>的空间分配策略完全杜绝了发生缓存区溢出的可能性</strong>。当<code>SDS</code>进行字符串扩充时，首先会检查当前的字节数组的长度是否足够，如果不够的话，会先进行自动扩容，然后再进行字符串操作。</p>
<h5 id="减少修改字符串时带来的内存重分配次数"><a href="#减少修改字符串时带来的内存重分配次数" class="headerlink" title="减少修改字符串时带来的内存重分配次数"></a>减少修改字符串时带来的内存重分配次数</h5><p>因为C字符串的长度和底层数据是紧密关联的，所以每次增长或者缩短一个字符串，程序都要对这个数组进行一次内存重分配：</p>
<ul>
<li>如果是增长字符串操作，需要先通过内存重分配来扩展底层数组空间大小，不这么做就导致缓存区溢出。</li>
<li>如果是缩短字符串操作，需要先通过内存重分配来来回收不再使用的空间，不这么做就导致内存泄漏。</li>
</ul>
<p>因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以通常是个比较耗时的操作。<strong>对于<code>Redis</code>来说，字符串修改是一个十分频繁的操作，如果每次都像C字符串那样进行内存重分配，对性能影响太大了，显然是无法接受的</strong>。</p>
<p><code>SDS</code>通过空闲空间解除了字符串长度和底层数据之间的关联。在<code>SDS</code>中，数组中可以包含未使用的字节，这些字节数量由<code>free</code>属性记录。<strong>通过空闲空间，<code>SDS</code>实现了空间预分配和惰性空间释放两种优化策略</strong>。</p>
<ol>
<li><strong>空间预分配</strong><br><strong>空间预分配是用于优化<code>SDS</code>字符串增长操作的，简单来说就是当字节数组空间不足触发重分配的时候，总是会预留一部分空闲空间</strong>。这样的话，就能减少连续执行字符串增长操作时的内存重分配次数。有两种预分配的策略：<ol>
<li><code>len</code>小于<code>1MB</code>时：每次重分配时会多分配同样大小的空闲空间；</li>
<li><code>len</code>大于等于<code>1MB</code>时：每次重分配时会多分配1MB大小的空闲空间。</li>
</ol>
</li>
<li><strong>惰性空间释放</strong><br>惰性空间释放是用于优化<code>SDS</code>字符串缩短操作的，简单来说就是当字符串缩短时，并不立即使用内存重分配来回收多出来的字节，而是用free属性记录，等待将来使用。<code>SDS</code>也提供直接释放未使用空间的<code>API</code>，在需要的时候，也能真正的释放掉多余的空间。</li>
</ol>
<h5 id="二进制安全"><a href="#二进制安全" class="headerlink" title="二进制安全"></a>二进制安全</h5><p>C字符串中的字符必须符合某种编码，并且除了字符串末尾之外，其它位置不允许出现空字符，这些限制使得C字符串只能保存文本数据。但是对于<code>Redis</code>来说，不仅仅需要保存文本，还要支持保存二进制数据。为了实现这一目标，<code>SDS</code>的<code>API</code>全部做到了二进制安全(<code>binary-safe</code>)。</p>
<h3 id="raw和embstr编码的SDS区别"><a href="#raw和embstr编码的SDS区别" class="headerlink" title="raw和embstr编码的SDS区别"></a>raw和embstr编码的SDS区别</h3><p>我们在前面讲过，长度大于39字节的字符串，编码类型为<code>raw</code>，底层数据结构是简单动态字符串(<code>SDS</code>)。这个很好理解，比如当我们执行<code>set story &quot;Long, long, long ago there lived a king ...&quot;</code>(长度大于39)之后，<code>Redis</code>就会创建一个<code>raw</code>编码的<code>String</code>对象。数据结构如下：<br><img data-src="https://chentianming11.github.io/images/redis/string-raw.png" alt="string-raw"></p>
<p>长度小于等于39个字节的字符串，编码类型为<code>embstr</code>，底层数据结构则是<code>embstr</code>编码<code>SDS</code>。<code>embstr</code>编码是专门用来保存短字符串的，它和<code>raw</code>编码最大的不同在于：<strong><code>raw</code>编码会调用两次内存分配分别创建<code>redisObject</code>结构和<code>sdshdr</code>结构，而<code>embstr</code>编码则是只调用一次内存分配，在一块连续的空间上同时包含<code>redisObject</code>结构和<code>sdshdr</code>结构</strong>。<br><img data-src="https://chentianming11.github.io/images/redis/embstr.png" alt="embstr"></p>
<h3 id="编码转换"><a href="#编码转换" class="headerlink" title="编码转换"></a>编码转换</h3><p><code>int</code>编码和<code>embstr</code>编码的字符串对象在条件满足的情况下会自动转换为<code>raw</code>编码的字符串对象。<br>对于<code>int</code>编码来说，当我们修改这个字符串为不再是整数值的时候，此时字符串对象的编码就会从<code>int</code>变为<code>raw</code>；对于<code>embstr</code>编码来说，只要我们修改了字符串的值，此时字符串对象的编码就会从<code>embstr</code>变为<code>raw</code>。</p>
<blockquote>
<p><code>embstr</code>编码的字符串对象可以认为是只读的，因为<code>Redis</code>为其编写任何修改程序。当我们要修改<code>embstr</code>编码字符串时，都是先将转换为<code>raw</code>编码，然后再进行修改。</p>
</blockquote>
<h2 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h2><p><strong>列表对象的编码可以是<code>linkedlist</code>或者<code>ziplist</code>，对应的底层数据结构是链表和压缩列表</strong>。列表对象相关命令可参考：<a href="http://www.redis.cn/commands.html#list" target="_blank" rel="noopener">Redis命令-List</a>。<br>默认情况下，当列表对象保存的所有字符串元素的长度都小于64字节，且元素个数小于512个时，列表对象采用的是<code>ziplist</code>编码，否则使用<code>linkedlist</code>编码。</p>
<blockquote>
<p>可以通过配置文件修改该上限值。</p>
</blockquote>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是一种非常常见的数据结构，提供了高效的节点重排能力以及顺序性的节点访问方式。在<code>Redis</code>中，每个链表节点使用<code>listNode</code>结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 后置节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">// 节点值</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode</span><br></pre></td></tr></table></figure>

<p>多个<code>listNode</code>通过<code>prev</code>和<code>next</code>指针组成双端链表，如下图所示：<br><img data-src="https://chentianming11.github.io/images/redis/listnode.png" alt="listnode"></p>
<p>为了操作起来比较方便，<code>Redis</code>使用了<code>list</code>结构持有链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    <span class="comment">// 表头节点</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    <span class="comment">// 表尾节点</span></span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="comment">// 链表包含的节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// 节点复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点释放函数</span></span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="comment">// 节点对比函数</span></span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure>

<p>list结构为链表提供了表头指针<code>head</code>、表尾指针<code>tail</code>，以及链表长度计数器<code>len</code>，而<code>dup</code>、<code>free</code>和<code>match</code>成员则是实现多态链表所需类型的特定函数。<br><img data-src="https://chentianming11.github.io/images/redis/list.png" alt="list"></p>
<p><code>Redis</code>链表实现的特征总结如下：</p>
<ol>
<li><strong>双端</strong>：链表节点带有<code>prev</code>和<code>next</code>指针，获取某个节点的前置节点和后置节点的复杂度都是<code>O(n)</code>。</li>
<li><strong>无环</strong>：表头节点的<code>prev</code>指针和表尾节点的<code>next</code>指针都指向<code>NULL</code>，对链表的访问以<code>NULL</code>为终点。</li>
<li><strong>带表头指针和表尾指针</strong>：通过<code>list</code>结构的<code>head</code>指针和<code>tail</code>指针，程序获取链表的表头节点和表尾节点的复杂度为<code>O(1)</code>。</li>
<li><strong>带链表长度计数器</strong>：程序使用<code>list</code>结构的<code>len</code>属性来对<code>list</code>持有的节点进行计数，程序获取链表中节点数量的复杂度为<code>O(1)</code>。</li>
<li><strong>多态</strong>：链表节点使用<code>void*</code>指针来保存节点值，可以保存各种不同类型的值。</li>
</ol>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表(<code>ziplist</code>)是列表键和哈希键的底层实现之一。压缩列表主要目的是为了节约内存，是由一系列特殊编码的连续内存块组成的顺序型数据结构。一个压缩列表可以包含任意多个节点，每个节点可以保存一个字节数组或者一个整数值。<br><img data-src="https://chentianming11.github.io/images/redis/ziplist.png" alt="ziplist"><br>如上图所示，压缩列表记录了各组成部分的类型、长度以及用途。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>长度</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>zlbytes</td>
<td>uint_32_t</td>
<td>4字节</td>
<td>记录整个压缩列表占用的内存字节数</td>
</tr>
<tr>
<td>zltail</td>
<td>uint_32_t</td>
<td>4字节</td>
<td>记录压缩列表表尾节点距离起始地址有多少字节，通过这个偏移量，程序无需遍历整个压缩列表就能确定表尾节点地址</td>
</tr>
<tr>
<td>zlen</td>
<td>uint_16_t</td>
<td>2字节</td>
<td>记录压缩列表包含的节点数量</td>
</tr>
<tr>
<td>entryX</td>
<td>列表节点</td>
<td>不定</td>
<td>压缩列表的各个节点，节点长度由保存的内容决定</td>
</tr>
<tr>
<td>zlend</td>
<td>uint_8_t</td>
<td>1字节</td>
<td>特殊值(<code>0xFFF</code>)，用于标记压缩列表末端</td>
</tr>
</tbody></table>
<h2 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h2><p>哈希对象的编码可以是<code>ziplist</code>或者<code>hashtable</code>。</p>
<h3 id="hash-ziplist"><a href="#hash-ziplist" class="headerlink" title="hash-ziplist"></a>hash-ziplist</h3><p><code>ziplist</code>底层使用的是压缩列表实现，上文已经详细介绍了压缩列表的实现原理。每当有新的键值对要加入哈希对象时，先把保存了键的节点推入压缩列表表尾，然后再将保存了值的节点推入压缩列表表尾。比如，我们执行如下三条<code>HSET</code>命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HSET profile name "tom"</span><br><span class="line">HSET profile age 25</span><br><span class="line">HSET profile career "Programmer"</span><br></pre></td></tr></table></figure>

<p>如果此时使用<code>ziplist</code>编码，那么该<code>Hash</code>对象在内存中的结构如下：<br><img data-src="https://chentianming11.github.io/images/redis/hash_ziplist.png" alt="hash_ziplist"></p>
<h3 id="hash-hashtable"><a href="#hash-hashtable" class="headerlink" title="hash-hashtable"></a>hash-hashtable</h3><p><code>hashtable</code>编码的哈希对象使用字典作为底层实现。字典是一种用于保存键值对的数据结构，<code>Redis</code>的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，每个哈希表节点保存的就是一个键值对。</p>
<h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><p><code>Redis</code>使用的哈希表由<code>dictht</code>结构定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span>&#123;</span></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="built_in">size</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">// 总是等于 size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该哈希表已有节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht</span><br></pre></td></tr></table></figure>

<p><code>table</code>属性是一个数组，数组中的每个元素都是一个指向<code>dictEntry</code>结构的指针，每个<code>dictEntry</code>结构保存着一个键值对。<code>size</code>属性记录了哈希表的大小，即<code>table</code>数组的大小。<code>used</code>属性记录了哈希表目前已有节点数量。<code>sizemask</code>总是等于<code>size-1</code>，这个值主要用于数组索引。比如下图展示了一个大小为4的空哈希表。<br><img data-src="https://chentianming11.github.io/images/redis/dictht.png" alt="dictht"></p>
<h4 id="哈希表节点"><a href="#哈希表节点" class="headerlink" title="哈希表节点"></a>哈希表节点</h4><p>哈希表节点使用<code>dictEntry</code>结构表示，每个<code>dictEntry</code>结构都保存着一个键值对：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">unit64_t</span> u64;</span><br><span class="line">        <span class="keyword">nit64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下一个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>

<p><code>key</code>属性保存着键值对中的键，而<code>v</code>属性则保存了键值对中的值。值可以是一个指针，一个<code>uint64_t</code>整数或者是<code>int64_t</code>整数。<code>next</code>属性指向了另一个<code>dictEntry</code>节点，在数组桶位相同的情况下，将多个<code>dictEntry</code>节点串联成一个链表，以此来解决键冲突问题。(链地址法)</p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p><code>Redis</code>字典由<code>dict</code>结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rehash索引</span></span><br><span class="line">    <span class="comment">// 当rehash不在进行时，值为-1</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ht</code>是大小为2，且每个元素都指向<code>dictht</code>哈希表。一般情况下，字典只会使用<code>ht[0]</code>哈希表，<code>ht[1]</code>哈希表只会在对<code>ht[0]</code>哈希表进行<code>rehash</code>时使用。<code>rehashidx</code>记录了<code>rehash</code>的进度，如果目前没有进行rehash，值为-1。<br><img data-src="https://chentianming11.github.io/images/redis/dict.png" alt="dict"></p>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>为了使hash表的负载因子(<code>ht[0]).used</code>/<code>ht[0]).size</code>)维持在一个合理范围，当哈希表保存的元素过多或者过少时，程序需要对hash表进行相应的扩展和收缩。<code>rehash</code>（重新散列）操作就是用来完成hash表的扩展和收缩的。rehash的步骤如下：</p>
<ol>
<li>为<code>ht[1]</code>哈希表分配空间<ol>
<li>如果是扩展操作，那么<code>ht[1]</code>的大小为第一个大于<code>ht[0].used*2</code>的2^n。比如<code>ht[0].used=5</code>，那么此时<code>ht[1]</code>的大小就为16。(大于10的第一个2^n的值是16)</li>
<li>如果是收缩操作，那么<code>ht[1]</code>的大小为第一个大于<code>ht[0].used</code>的2^n。比如<code>ht[0].used=5</code>，那么此时<code>ht[1]</code>的大小就为8。(大于5的第一个2^n的值是8)</li>
</ol>
</li>
<li>将保存在<code>ht[0]</code>中的所有键值对rehash到<code>ht[1]</code>中。</li>
<li>迁移完成之后，释放掉<code>ht[0]</code>，并将现在的<code>ht[1]</code>设置为<code>ht[0]</code>，在<code>ht[1]</code>新创建一个空白哈希表，为下一次rehash做准备。</li>
</ol>
<p><strong>哈希表的扩展和收缩时机</strong>：</p>
<ol>
<li>当服务器没有执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令时，负载因子大于等于1触发哈希表的扩展操作。</li>
<li>当服务器在执行<code>BGSAVE</code>或者<code>BGREWRITEAOF</code>命令，负载因子大于等于5触发哈希表的扩展操作。</li>
<li>当哈希表负载因子小于0.1，触发哈希表的收缩操作。</li>
</ol>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>前面讲过，扩展或者收缩需要将<code>ht[0]</code>里面的元素全部rehash到<code>ht[1]</code>中，如果<code>ht[0]</code>元素很多，显然一次性rehash成本会很大，从影响到<code>Redis</code>性能。为了解决上述问题，<code>Redis</code>使用了<strong>渐进式rehash</strong>技术，具体来说就是<strong>分多次，渐进式地将<code>ht[0]</code>里面的元素慢慢地rehash到<code>ht[1]</code>中</strong>。下面是<strong>渐进式rehash</strong>的详细步骤：</p>
<ol>
<li>为<code>ht[1]</code>分配空间。</li>
<li>在字典中维持一个索引计数器变量<code>rehashidx</code>，并将它的值设置为0，表示rehash正式开始。</li>
<li>在rehash进行期间，每次对字典执行添加、删除、查找或者更新时，除了会执行相应的操作之外，还会顺带将<code>ht[0]</code>在<code>rehashidx</code>索引位上的所有键值对rehash到<code>ht[1]</code>中，rehash完成之后，<code>rehashidx</code>值加1。</li>
<li>随着字典操作的不断进行，最终会在啊某个时刻迁移完成，此时将<code>rehashidx</code>值置为-1，表示rehash结束。</li>
</ol>
<p><strong>渐进式rehash一次迁移一个桶上所有的数据，设计上采用分而治之的思想，将原本集中式的操作分散到每个添加、删除、查找和更新操作上</strong>，从而避免集中式rehash带来的庞大计算。</p>
<p>因为在渐进式rehash时，字典会同时使用<code>ht[0]</code>和<code>ht[1]</code>两张表，所以此时对字典的删除、查找和更新操作都可能会在两个哈希表进行。比如，如果要查找某个键时，先在<code>ht[0]</code>中查找，如果没找到，则继续到<code>ht[1]</code>中查找。</p>
<h4 id="hash对象中的hashtable"><a href="#hash对象中的hashtable" class="headerlink" title="hash对象中的hashtable"></a>hash对象中的hashtable</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">HSET profile name "tom"</span><br><span class="line">HSET profile age 25</span><br><span class="line">HSET profile career "Programmer"</span><br></pre></td></tr></table></figure>

<p>还是上述三条命令，保存数据到<code>Redis</code>的哈希对象中，如果采用<code>hashtable</code>编码保存的话，那么该<code>Hash</code>对象在内存中的结构如下：<br><img data-src="https://chentianming11.github.io/images/redis/hash-ht.png" alt="hash-ht"></p>
<p>当哈希对象保存的所有键值对的键和值的字符串长度都小于64个字节，并且数量小于512个时，使用<code>ziplist</code>编码，否则使用<code>hashtable</code>编码。</p>
<blockquote>
<p>可以通过配置文件修改该上限值。</p>
</blockquote>
<h2 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h2><p>集合对象的编码可以是<code>intset</code>或者<code>hashtable</code>。当集合对象保存的元素都是整数，并且个数不超过512个时，使用<code>intset</code>编码，否则使用<code>hashtable</code>编码。</p>
<h3 id="set-intset"><a href="#set-intset" class="headerlink" title="set-intset"></a>set-intset</h3><p><code>intset</code>编码的集合对象底层使用整数集合实现。</p>
<p>整数集合(intset)是<code>Redis</code>用于保存整数值的集合抽象数据结构，它可以保存类型为<code>int16_t</code>、<code>int32_t</code>或者<code>int64_t</code>的整数值，并且保证集合中的数据不会重复。<code>Redis</code>使用<code>intset</code>结构表示一个整数集合。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 编码方式</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="comment">// 集合包含的元素数量</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="comment">// 保存元素的数组</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p><code>contents</code>数组是整数集合的底层实现：整数集合的每个元素都是contents数组的一个数组项，各个项在数组中按值大小从小到大有序排列，并且数组中不包含重复项。虽然<code>contents</code>属性声明为<code>int8_t</code>类型的数组，但实际上，<code>contents</code>数组不保存任何<code>int8_t</code>类型的值，数组中真正保存的值类型取决于<code>encoding</code>。如果<code>encoding</code>属性值为<code>INTSET_ENC_INT16</code>，那么<code>contents</code>数组就是<code>int16_t</code>类型的数组，以此类推。</p>
<p>当新插入元素的类型比整数集合现有类型元素的类型大时，整数集合必须先升级，然后才能将新元素添加进来。这个过程分以下三步进行。</p>
<ol>
<li>根据新元素类型，扩展整数集合底层数组空间大小。</li>
<li>将底层数组现有所有元素都转换为与新元素相同的类型，并且维持底层数组的有序性。</li>
<li>将新元素添加到底层数组里面。</li>
</ol>
<p>还有一点需要注意的是，整数集合不支持降级，一旦对数组进行了升级，编码就会一直保持升级后的状态。</p>
<p>举个栗子，当我们执行<code>SADD numbers 1 3 5</code>向集合对象插入数据时，该集合对象在内存的结构如下：<br><img data-src="https://chentianming11.github.io/images/redis/set-intset.png" alt="set-intset"></p>
<h3 id="set-hashtable"><a href="#set-hashtable" class="headerlink" title="set-hashtable"></a>set-hashtable</h3><p><code>hashtable</code>编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象对应一个集合元素，字典的值都是<code>NULL</code>。当我们执行<code>SADD fruits &quot;apple&quot; &quot;banana&quot; &quot;cherry&quot;</code>向集合对象插入数据时，该集合对象在内存的结构如下：<br><img data-src="https://chentianming11.github.io/images/redis/set-hash.png" alt="set-hash"></p>
<h2 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h2><p>有序集合的编码可以是<code>ziplist</code>或者<code>skiplist</code>。当有序集合保存的元素个数小于128个，且所有元素成员长度都小于64字节时，使用<code>ziplist</code>编码，否则，使用<code>skiplist</code>编码。</p>
<h3 id="zset-ziplist"><a href="#zset-ziplist" class="headerlink" title="zset-ziplist"></a>zset-ziplist</h3><p><strong><code>ziplist</code>编码的有序集合使用压缩列表作为底层实现，每个集合元素使用两个紧挨着一起的两个压缩列表节点表示，第一个节点保存元素的成员(member)，第二个节点保存元素的分值(score)</strong>。</p>
<p><strong>压缩列表内的集合元素按照分值从小到大排列</strong>。如果我们执行<code>ZADD price 8.5 apple 5.0 banana 6.0 cherry</code>命令，向有序集合插入元素，该有序集合在内存中的结构如下：<br><img data-src="https://chentianming11.github.io/images/redis/zset-ziplist.png" alt="zset-ziplist"></p>
<h3 id="zset-skiplist"><a href="#zset-skiplist" class="headerlink" title="zset-skiplist"></a>zset-skiplist</h3><p><code>skiplist</code>编码的有序集合对象使用<code>zset</code>结构作为底层实现，一个<code>zset</code>结构同时包含一个字典和一个跳跃表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    zskiplist *zs1;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续介绍之前，我们先了解一下什么是跳跃表。</p>
<h4 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h4><p>跳跃表(skiplist)是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。<code>Redis</code>的跳跃表由<code>zskiplistNode</code>和<code>zskiplist</code>两个结构定义，<code>zskiplistNode</code>结构表示跳跃表节点，<code>zskiplist</code>保存跳跃表节点相关信息，比如节点的数量，以及指向表头和表尾节点的指针等。</p>
<h5 id="跳跃表节点-zskiplistNode"><a href="#跳跃表节点-zskiplistNode" class="headerlink" title="跳跃表节点 zskiplistNode"></a>跳跃表节点 zskiplistNode</h5><p>跳跃表节点<code>zskiplistNode</code>结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>下图是一个层高为5，包含4个跳跃表节点(1个表头节点和3个数据节点)组成的跳跃表：<br><img data-src="https://chentianming11.github.io/images/redis/zskiplistNode.png" alt="zskiplistNode"></p>
<ol>
<li>层<br><strong>每次创建一个新的跳跃表节点的时候，会根据幂次定律(越大的数出现的概率越低)随机生成一个<code>1-32</code>之间的值作为当前节点的”层高”</strong>。每层元素都包含2个数据，前进指针和跨度。<ol>
<li>前进指针<br>每层都有一个指向表尾方向的前进指针，用于从表头向表尾方向访问节点。</li>
<li>跨度<br>层的跨度用于记录两个节点之间的距离。</li>
</ol>
</li>
<li>后退指针(BW)<br>节点的后退指针用于从表尾向表头方向访问节点，每个节点只有一个后退指针，所以每次只能后退一个节点。</li>
<li>分值和成员<br>节点的分值(score)是一个<code>double</code>类型的浮点数，跳跃表中所有节点都按分值从小到大排列。节点的成员(obj)是一个指针，指向一个字符串对象。在跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点的分值确实可以相同。</li>
</ol>
<p><strong>需要注意的是，表头节点不存储真实数据，并且层高固定为32，从表头节点第一个不为<code>NULL</code>最高层开始，就能实现快速查找</strong>。</p>
<h5 id="跳跃表-zskiplist"><a href="#跳跃表-zskiplist" class="headerlink" title="跳跃表 zskiplist"></a>跳跃表 zskiplist</h5><p>实际上，仅靠多个跳跃表节点就可以组成一个跳跃表，但是<code>Redis</code>使用了<code>zskiplist</code>结构来持有这些节点，这样就能够更方便地对整个跳跃表进行操作。比如快速访问表头和表尾节点，获得跳跃表节点数量等等。<code>zskiplist</code>结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">skiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="comment">// 节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="comment">// 最大层数</span></span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br></pre></td></tr></table></figure>

<p>下图是一个完整的跳跃表结构示例：<br><img data-src="https://chentianming11.github.io/images/redis/zskiplist.png" alt="zskiplist"></p>
<h4 id="有序集合对象的skiplist实现"><a href="#有序集合对象的skiplist实现" class="headerlink" title="有序集合对象的skiplist实现"></a>有序集合对象的<code>skiplist</code>实现</h4><p><strong>前面讲过，<code>skiplist</code>编码的有序集合对象使用<code>zset</code>结构作为底层实现，一个<code>zset</code>结构同时包含一个字典和一个跳跃表</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    zskiplist *zs1;</span><br><span class="line">    dict *dict;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>zset</code>结构中的<code>zs1</code>跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素。通过跳跃表，可以对有序集合进行基于<code>score</code>的快速范围查找。<code>zset</code>结构中的<code>dict</code>字典为有序集合创建了从成员到分值的映射，字典的键保存了成员，字典的值保存了分值。通过字典，可以用<code>O(1)</code>复杂度查找给定成员的分值。</p>
<p>假如还是执行<code>ZADD price 8.5 apple 5.0 banana 6.0 cherry</code>命令向<code>zset</code>保存数据，如果采用<code>skiplist</code>编码方式的话，该有序集合在内存中的结构如下：<br><img data-src="https://chentianming11.github.io/images/redis/zset-skiplist.png" alt="zset-skiplist"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>总的来说，<code>Redis</code>底层数据结构主要包括简单动态字符串(SDS)、链表、字典、跳跃表、整数集合和压缩列表六种类型，并且基于这些基础数据结构实现了字符串对象、列表对象、哈希对象、集合对象以及有序集合对象五种常见的对象类型</strong>。每一种对象类型都至少采用了2种数据编码，不同的编码使用的底层数据结构也不同。</p>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>手把手教你基于Retrofit实现自己的轻量级http调用工具</title>
    <url>/posts/1979374763/</url>
    <content><![CDATA[<p>在《<a href="https://juejin.im/post/5f14d81cf265da22ee7fbff0" target="_blank" rel="noopener">spring-boot项目整合Retrofit最佳实践，最优雅的HTTP客户端工具！</a>》这篇文章中，我们知道了<code>retrofit-spring-boot-starter</code>的使用方式。本篇文章继续继续介绍<code>retrofit-spring-boot-starter</code>的实现原理，从零开始介绍<strong>如何在spring-boot项目中基于Retrofit实现自己的轻量级http调用工具</strong>。</p>
<blockquote>
<p>项目源码：<a href="https://github.com/LianjiaTech/retrofit-spring-boot-starter" target="_blank" rel="noopener">retrofit-spring-boot-starter</a></p>
</blockquote>
<a id="more"></a>

<h2 id="确定实现思路"><a href="#确定实现思路" class="headerlink" title="确定实现思路"></a>确定实现思路</h2><p>我们首先直接看一下使用<code>retrofit</code>原始API是如何发起一个http请求的。</p>
<ol>
<li><p>定义接口</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="meta">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建接口代理对象</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实际业务场景构建Retrofit比这复杂多了，这里最简单化处理</span></span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发起请求</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>可以看到，<code>Retrofit</code>本身已经很好的支持了通过接口发起<code>htp</code>请求。但是如果我们项目每一个业务代码都要写上面的样板代码，会非常的繁琐。有没有一种方式<strong>让用户只关注接口定义，其它事情全部交给框架自动处理</strong>？这个时候我们可能会联想到<code>spring-boot</code>项目下使用<code>Mybatis</code>，用户只需要定义<code>Mapper</code>接口和书写<code>sql</code>即可，完全不用管与<code>JDBC</code>的交互细节。与之类似，<strong>我们最终也要实现让用户只需要定义<code>HttpService</code>接口，不用管其他底层实现细节</strong>。</p>
<h2 id="相关知识介绍"><a href="#相关知识介绍" class="headerlink" title="相关知识介绍"></a>相关知识介绍</h2><p>为了方便后面的介绍，我们先得了解一下几个相关知识点。</p>
<h3 id="spring容器初始化"><a href="#spring容器初始化" class="headerlink" title="spring容器初始化"></a>spring容器初始化</h3><p>我们首先要简单了解一下<code>spring</code>容器初始化。简单来讲，<code>spring</code>容器初始化主要包含以下2个步骤：</p>
<ol>
<li><strong>注册Bean定义</strong>：扫描并解析<strong>配置文件</strong>或者<strong>某些注解</strong>得到Bean属性(包括<code>beanName</code>、<code>beanClassName</code>、<code>scope</code>、<code>isSingleton</code>等等)，然后基于这个<code>bean</code>属性创建<code>BeanDefinition</code>对象，最后将其注册到<code>BeanDefinitionRegistry</code>中。</li>
<li><strong>创建Bean实例</strong>：根据<code>BeanDefinitionRegistry</code>里面的<code>BeanDefinition</code>信息，创建Bean实例，并将实例对象保存到<code>spring</code>容器中，创建的方式包括反射创建、工厂方法创建和工厂Bean(<code>FactoryBean</code>)创建等等。</li>
</ol>
<p>当然，实际的<code>spring</code>容器初始化比这复杂的多，考虑到这块不是本文的重点，暂时这么理解就行。</p>
<h3 id="Retrofit对象简介"><a href="#Retrofit对象简介" class="headerlink" title="Retrofit对象简介"></a><code>Retrofit</code>对象简介</h3><p>我们已经知道使用<code>Retrofit</code>对象可以创建接口代理对象，接下来看一下<code>Retrofit</code>的UML类图(只列出了我们关注的依赖)：</p>
<p><img data-src="https://chentianming11.github.io/images/retrofit/retrofit-uml.png" alt="retrofit-uml"></p>
<p>通过分析UML类图，我们可以发现，构建<code>Retrofit</code>对象的时候，可以注入以下4个属性：</p>
<ol>
<li><code>HttpUrl</code>：<code>http</code>请求的<code>baseUrl</code>。</li>
<li><code>CallAdapter</code>：将<code>Call&lt;T&gt;</code>适配为接口方法返回值类型。</li>
<li><code>Converter</code>：将<code>@Body</code>标记的方法参数序列化为请求体数据；将响应体数据反序列化为响应对象。</li>
<li><code>OkHttpClient</code>：底层发送<code>http</code>请求的客户端对象。</li>
</ol>
<p>而构建<code>OkHttpClient</code>对象的时候，可以注入<code>Interceptor</code>(请求拦截器)和<code>ConnectionPool</code>(连接池)属性。</p>
<p>因此<strong>为了构建<code>Retrofit</code>对象，我们要先创建<code>HttpUrl</code>、<code>CallAdapter</code>、<code>Converter</code>和<code>OkHttpClient</code>；而要构建<code>OkHttpClient</code>对象就得先创建<code>Interceptor</code>和<code>ConnectionPool</code></strong>。</p>
<h2 id="实现详解"><a href="#实现详解" class="headerlink" title="实现详解"></a>实现详解</h2><h3 id="注册Bean定义"><a href="#注册Bean定义" class="headerlink" title="注册Bean定义"></a>注册Bean定义</h3><p>为了实现将<code>HttpService</code>接口代理对象完全交由<code>spring</code>容器管理，首先就得将<code>HttpService</code>接口扫描并注册到<code>BeanDefinitionRegistry</code>中。<code>spring</code>提供了<code>ImportBeanDefinitionRegistrar</code>接口，支持了自定义注册<code>BeanDefinition</code>的功能。因此我们先定义<code>RetrofitClientRegistrar</code>类用来实现上述功能。具体实现如下：</p>
<ol>
<li><p><code>RetrofitClientRegistrar</code></p>
<p> <code>RetrofitClientRegistrar</code>从<code>@RetrofitScan</code>注解中提取出要扫描的基础包路径之后，将具体的扫描注册逻辑交给了<code>ClassPathRetrofitClientScanner</code>处理。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrofitClientRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">ResourceLoaderAware</span>, <span class="title">BeanClassLoaderAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        AnnotationAttributes attributes = AnnotationAttributes</span><br><span class="line">                .fromMap(metadata.getAnnotationAttributes(RetrofitScan<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">        <span class="comment">// 扫描指定路径下@RetrofitClient注解的接口，并注册到BeanDefinitionRegistry</span></span><br><span class="line">        <span class="comment">// 真正的扫描注册逻辑交给了ClassPathRetrofitClientScanner执行</span></span><br><span class="line">        ClassPathRetrofitClientScanner scanner = <span class="keyword">new</span> ClassPathRetrofitClientScanner(registry, classLoader);</span><br><span class="line">        <span class="keyword">if</span> (resourceLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">            scanner.setResourceLoader(resourceLoader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指定扫描的基础包</span></span><br><span class="line">        String[] basePackages = getPackagesToScan(attributes);</span><br><span class="line">        scanner.registerFilters();</span><br><span class="line">        <span class="comment">// 扫描并注册到BeanDefinition</span></span><br><span class="line">        scanner.doScan(basePackages);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ClassPathRetrofitClientScanner</code></p>
<p> <code>ClassPathRetrofitClientScanner</code>继承了<code>ClassPathBeanDefinitionScanner</code>，这是Spring提供的类路径下<code>BeanDefinition</code>的扫描器。需要注意的一点是：<strong><code>BeanDefinition</code>的<code>beanClass</code>属性全部设置为了<code>RetrofitFactoryBean.class</code>，同时将接口自身的类型传递到了<code>RetrofitFactoryBean</code>的<code>retrofitInterface</code>属性中</strong>。这说明，最终创建Bean实例是通过<code>RetrofitFactoryBean</code>来完成的。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathRetrofitClientScanner</span> <span class="keyword">extends</span> <span class="title">ClassPathBeanDefinitionScanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processBeanDefinitions</span><span class="params">(Set&lt;BeanDefinitionHolder&gt; beanDefinitions)</span> </span>&#123;</span><br><span class="line">        GenericBeanDefinition definition;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinitionHolder holder : beanDefinitions) &#123;</span><br><span class="line">            definition = (GenericBeanDefinition) holder.getBeanDefinition();</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">"Creating RetrofitClientBean with name '"</span> + holder.getBeanName()</span><br><span class="line">                        + <span class="string">"' and '"</span> + definition.getBeanClassName() + <span class="string">"' Interface"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            definition.getConstructorArgumentValues().addGenericArgumentValue(Objects.requireNonNull(definition.getBeanClassName()));</span><br><span class="line">            <span class="comment">// beanClass全部设置为RetrofitFactoryBean</span></span><br><span class="line">            definition.setBeanClass(RetrofitFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>这样，我们就完成了<strong>扫描指定路径下带有<code>@RetrofitClient</code>注解的接口，并将其注册到<code>BeanDefinitionRegistry</code>的功能了</strong>。</p>
<blockquote>
<p><code>@RetrofitClient</code>注解要标识在<code>HttpService</code>的接口上！<code>@RetrofitScan</code>指定了要扫描的包路径。具体可看考源码。</p>
</blockquote>
<h3 id="创建Bean实例"><a href="#创建Bean实例" class="headerlink" title="创建Bean实例"></a>创建Bean实例</h3><p>上面已经说了创建Bean实例实际上是通过<code>RetrofitFactoryBean</code>实现的。具体就是实现<code>FactoryBean&lt;T&gt;</code>接口，然后重写<code>getObject()</code>方法来完成<strong>创建接口Bean实例</strong>的逻辑。并且，我们也已经知道通过<code>Retrofit</code>对象能够生成接口代理对象。因此<code>getObject()</code>方法的核心就是构建<code>Retrofit</code>对象，并基于此生成<code>http</code>接口代理对象。</p>
<ol>
<li><p>配置项和<code>@RetrofitClient</code><br>为了更加灵活的构建<code>Retrofit</code>对象，我们可以通过配置项以及<code>@RetrofitClient</code>注解属性传递一些动态参数信息。<code>@RetrofitClient</code>包含的属性如下：</p>
<ol>
<li><code>baseUrl</code>：用来创建<code>Retrofit</code>的<code>HttpUrl</code>，表示该接口下所有请求都适用的<code>基础url</code>。</li>
<li><code>poolName</code>：该接口下请求使用的连接池的名称，决定了<code>ConnectionPool</code>对象的取值。</li>
<li><code>connectTimeoutMs/readTimeoutMs/writeTimeoutMs</code>：用于构建<code>OkHttpClien</code>t对象的超时时间设置。</li>
<li><code>logLevel/logStrategy</code>：配置该接口下请求的日志打印级别和日志打印策略，可用来创建日志打印拦截器<code>Interceptor</code>。</li>
</ol>
</li>
<li><p><code>RetrofitFactoryBean</code><br> <code>RetrofitFactoryBean</code>实现逻辑非常复杂，概括起来主要包含以下几点：</p>
<ol>
<li><p>通过配置项数据以及<code>@RetrofitClient</code>注解数据完成了<code>Retrofit</code>对象的构建。</p>
</li>
<li><p>每一个<code>HttpService</code>接口就会构建一个<code>Retrofit</code>对象，每一个<code>Retrofit</code>对象就会构建对应的<code>OkHttpClient</code>对象。</p>
</li>
<li><p>可扩展的注解式拦截器是通过<code>InterceptMark</code>注解标记实现的，路径拦截匹配是通过<code>BasePathMatchInterceptor</code>实现的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrofitFactoryBean</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;, <span class="title">EnvironmentAware</span>, <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略其它代码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RetrofitFactoryBean</span><span class="params">(Class&lt;T&gt; retrofitInterface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.retrofitInterface = retrofitInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 接口校验</span></span><br><span class="line">        checkRetrofitInterface(retrofitInterface);</span><br><span class="line">        <span class="comment">// 构建Retrofit对象</span></span><br><span class="line">        Retrofit retrofit = getRetrofit(retrofitInterface);</span><br><span class="line">        <span class="comment">// 基于Retrofit创建接口代理对象</span></span><br><span class="line">        <span class="keyword">return</span> retrofit.create(retrofitInterface);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取OkHttpClient实例，一个接口接口对应一个OkHttpClient</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> retrofitClientInterfaceClass retrofitClient接口类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> OkHttpClient实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> OkHttpClient <span class="title">getOkHttpClient</span><span class="params">(Class&lt;?&gt; retrofitClientInterfaceClass)</span> <span class="keyword">throws</span> IllegalAccessException, InstantiationException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">// 基于各种条件构建OkHttpClient</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取Retrofit实例，一个retrofitClient接口对应一个Retrofit实例</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> retrofitClientInterfaceClass retrofitClient接口类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> Retrofit实例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Retrofit <span class="title">getRetrofit</span><span class="params">(Class&lt;?&gt; retrofitClientInterfaceClass)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException </span>&#123;</span><br><span class="line">        <span class="comment">// 构建retrofit</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
<p>这样，我们就完成了创建<code>HttpService</code>Bean实例的功能了。在使用的时候直接注入<code>HttpService</code>，然后调用其方法就能发送对应的<code>http</code>请求。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>总的来说，在spring-boot项目中基于Retrofit实现自己的轻量级http调用工具的核心只有两点：第一是注册<code>HttpService</code>接口的<code>BeanDefinition</code>，第二就是构建<code>Retrofit</code>来创建<code>HttpService</code>的代理对象。如需了解更多细节，建议直接查看<a href="https://github.com/LianjiaTech/retrofit-spring-boot-starter" target="_blank" rel="noopener">retrofit-spring-boot-starter源码</a>。</p>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>spring-boot项目整合Retrofit最佳实践，最优雅的HTTP客户端工具！</title>
    <url>/posts/2257172027/</url>
    <content><![CDATA[<p>大家都知道<code>okhttp</code>是一款由<a href="https://square.github.io/" target="_blank" rel="noopener">square</a>公司开源的<code>java</code>版本<code>http</code>客户端工具。实际上，<a href="https://square.github.io/" target="_blank" rel="noopener">square</a>公司还开源了基于<code>okhttp</code>进一步封装的<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">retrofit</a>工具，用来<strong>支持通过<code>接口</code>的方式发起<code>http</code>请求</strong>。<strong>如果你的项目中还在直接使用<code>RestTemplate</code>或者<code>okhttp</code>，或者基于它们封装的<code>HttpUtils</code>，那么你可以尝试使用<code>Retrofit</code></strong>。</p>
<p><strong><code>retrofit-spring-boot-starter</code>实现了<code>Retrofit</code>与<code>spring-boot</code>框架快速整合，并且支持了部分功能增强，从而极大的简化<code>spring-boot</code>项目下<code>http</code>接口调用开发</strong>。接下来我们直接通过<code>retrofit-spring-boot-starter</code>，来看看<code>spring-boot</code>项目发送<code>http</code>请求有多简单。</p>
<a id="more"></a>

<blockquote>
<p><code>retrofit</code>官方并没有提供与<code>spring-boot</code>快速整合的<code>starter</code>。<code>retrofit-spring-boot-starter</code>是笔者封装的，已在生产环境使用，非常稳定。<strong>造轮子不易，跪求各位大佬star</strong>。</p>
</blockquote>
<p>项目源码：<a href="https://github.com/LianjiaTech/retrofit-spring-boot-starter" target="_blank" rel="noopener">retrofit-spring-boot-starter</a></p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.lianjiatech<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>retrofit-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="配置-RetrofitScan注解"><a href="#配置-RetrofitScan注解" class="headerlink" title="配置@RetrofitScan注解"></a>配置<code>@RetrofitScan</code>注解</h3><p>你可以给带有 <code>@Configuration</code> 的类配置<code>@RetrofitScan</code>，或者直接配置到<code>spring-boot</code>的启动类上，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@RetrofitScan</span>(<span class="string">"com.github.lianjiatech.retrofit.spring.boot.test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RetrofitTestApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(RetrofitTestApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义http接口"><a href="#定义http接口" class="headerlink" title="定义http接口"></a>定义http接口</h3><p><strong>接口必须使用<code>@RetrofitClient</code>注解标记</strong>！http相关注解可参考官方文档：<a href="https://square.github.io/retrofit/" target="_blank" rel="noopener">retrofit官方文档</a>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitClient</span>(baseUrl = <span class="string">"$&#123;test.baseUrl&#125;"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="注入使用"><a href="#注入使用" class="headerlink" title="注入使用"></a>注入使用</h3><p><strong>将接口注入到其它Service中即可使用</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> HttpApi httpApi;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过httpApi发起http请求</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要通过上述几个步骤，就能实现通过接口发送<code>http</code>请求了，真的很简单。如果你在<code>spring-boot</code>项目里面使用过<code>mybatis</code>，相信你对这种使用方式会更加熟悉。接下来我们继续介绍一下<code>retrofit-spring-boot-starter</code>更高级一点的功能。</p>
<h3 id="注解式拦截器"><a href="#注解式拦截器" class="headerlink" title="注解式拦截器"></a>注解式拦截器</h3><p>很多时候，我们希望某个接口下的某些http请求执行统一的拦截处理逻辑。这个时候可以使用<strong>注解式拦截器</strong>。使用的步骤主要分为2步：</p>
<ol>
<li>继承<code>BasePathMatchInterceptor</code>编写拦截处理器；</li>
<li>接口上使用<code>@Intercept</code>进行标注。</li>
</ol>
<p>下面以<em>给指定请求的url后面拼接timestamp时间戳</em>为例，介绍下如何使用注解式拦截器。</p>
<h4 id="继承BasePathMatchInterceptor编写拦截处理器"><a href="#继承BasePathMatchInterceptor编写拦截处理器" class="headerlink" title="继承BasePathMatchInterceptor编写拦截处理器"></a>继承<code>BasePathMatchInterceptor</code>编写拦截处理器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeStampInterceptor</span> <span class="keyword">extends</span> <span class="title">BasePathMatchInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">doIntercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        HttpUrl url = request.url();</span><br><span class="line">        <span class="keyword">long</span> timestamp = System.currentTimeMillis();</span><br><span class="line">        HttpUrl newUrl = url.newBuilder()</span><br><span class="line">                .addQueryParameter(<span class="string">"timestamp"</span>, String.valueOf(timestamp))</span><br><span class="line">                .build();</span><br><span class="line">        Request newRequest = request.newBuilder()</span><br><span class="line">                .url(newUrl)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(newRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="接口上使用-Intercept进行标注"><a href="#接口上使用-Intercept进行标注" class="headerlink" title="接口上使用@Intercept进行标注"></a>接口上使用<code>@Intercept</code>进行标注</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitClient</span>(baseUrl = <span class="string">"$&#123;test.baseUrl&#125;"</span>)</span><br><span class="line"><span class="meta">@Intercept</span>(handler = TimeStampInterceptor<span class="class">.<span class="keyword">class</span>, <span class="title">include</span> </span>= &#123;<span class="string">"/api/**"</span>&#125;, exclude = <span class="string">"/api/test/savePerson"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"savePerson"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">savePerson</span><span class="params">(@Body Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的<code>@Intercept</code>配置表示：拦截<code>HttpApi</code>接口下<code>/api/**</code>路径下（排除<code>/api/test/savePerson</code>）的请求，拦截处理器使用<code>TimeStampInterceptor</code>。</p>
<h3 id="扩展注解式拦截器"><a href="#扩展注解式拦截器" class="headerlink" title="扩展注解式拦截器"></a>扩展注解式拦截器</h3><p>有的时候，我们需要在<strong>拦截注解</strong>动态传入一些参数，然后再执行拦截的时候需要使用这个参数。这种时候，我们可以扩展实现<strong>自定义拦截注解</strong>。<code>自定义拦截注解</code>必须使用<code>@InterceptMark</code>标记，并且<strong>注解中必须包括<code>include()、exclude()、handler()</code>属性信息</strong>。使用的步骤主要分为3步：</p>
<ol>
<li>自定义拦截注解</li>
<li>继承<code>BasePathMatchInterceptor</code>编写拦截处理器</li>
<li>接口上使用自定义拦截注解；</li>
</ol>
<p>例如我们需要<strong>在请求头里面动态加入<code>accessKeyId</code>、<code>accessKeySecret</code>签名信息才能正常发起http请求</strong>，这个时候可以<strong>自定义一个加签拦截器注解<code>@Sign</code></strong>来实现。下面以自定义<code>@Sign</code>拦截注解为例进行说明。</p>
<h4 id="自定义-Sign注解"><a href="#自定义-Sign注解" class="headerlink" title="自定义@Sign注解"></a>自定义<code>@Sign</code>注解</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@InterceptMark</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Sign &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥key</span></span><br><span class="line"><span class="comment">     * 支持占位符形式配置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">accessKeyId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密钥</span></span><br><span class="line"><span class="comment">     * 支持占位符形式配置。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">accessKeySecret</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器匹配路径</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] include() <span class="keyword">default</span> &#123;<span class="string">"/**"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 拦截器排除匹配，排除指定路径拦截</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理该注解的拦截器类</span></span><br><span class="line"><span class="comment">     * 优先从spring容器获取对应的Bean，如果获取不到，则使用反射创建一个！</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;? extends BasePathMatchInterceptor&gt; handler() <span class="keyword">default</span> SignInterceptor<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展<code>自定义拦截注解</code>有以下2点需要注意：</p>
<ol>
<li><code>自定义拦截注解</code>必须使用<code>@InterceptMark</code>标记。</li>
<li>注解中必须包括<code>include()、exclude()、handler()</code>属性信息。</li>
</ol>
<h4 id="实现SignInterceptor"><a href="#实现SignInterceptor" class="headerlink" title="实现SignInterceptor"></a>实现<code>SignInterceptor</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignInterceptor</span> <span class="keyword">extends</span> <span class="title">BasePathMatchInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKeyId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String accessKeySecret;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessKeyId</span><span class="params">(String accessKeyId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accessKeyId = accessKeyId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAccessKeySecret</span><span class="params">(String accessKeySecret)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.accessKeySecret = accessKeySecret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">doIntercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        Request newReq = request.newBuilder()</span><br><span class="line">                .addHeader(<span class="string">"accessKeyId"</span>, accessKeyId)</span><br><span class="line">                .addHeader(<span class="string">"accessKeySecret"</span>, accessKeySecret)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(newReq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上述<code>accessKeyId</code>和<code>accessKeySecret</code>字段值会依据<code>@Sign</code>注解的<code>accessKeyId()</code>和<code>accessKeySecret()</code>值自动注入，如果<code>@Sign</code>指定的是占位符形式的字符串，则会取配置属性值进行注入</strong>。另外，<strong><code>accessKeyId</code>和<code>accessKeySecret</code>字段必须提供<code>setter</code>方法</strong>。</p>
<h4 id="接口上使用-Sign"><a href="#接口上使用-Sign" class="headerlink" title="接口上使用@Sign"></a>接口上使用<code>@Sign</code></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitClient</span>(baseUrl = <span class="string">"$&#123;test.baseUrl&#125;"</span>)</span><br><span class="line"><span class="meta">@Sign</span>(accessKeyId = <span class="string">"$&#123;test.accessKeyId&#125;"</span>, accessKeySecret = <span class="string">"$&#123;test.accessKeySecret&#125;"</span>, exclude = &#123;<span class="string">"/api/test/person"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@POST</span>(<span class="string">"savePerson"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">savePerson</span><span class="params">(@Body Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就能在指定url的请求上，自动加上签名信息了。</p>
<h3 id="连接池管理"><a href="#连接池管理" class="headerlink" title="连接池管理"></a>连接池管理</h3><p>默认情况下，所有通过<code>Retrofit</code>发送的http请求都会使用<code>max-idle-connections=5  keep-alive-second=300</code>的默认连接池。当然，我们也可以在配置文件中配置多个自定义的连接池，然后通过<code>@RetrofitClient</code>的<code>poolName</code>属性来指定使用。比如我们要让某个接口下的请求全部使用<code>poolName=test1</code>的连接池，代码实现如下：</p>
<ol>
<li><p>配置连接池。</p>
 <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retrofit:</span></span><br><span class="line">    <span class="comment"># 连接池配置</span></span><br><span class="line">    <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">test1:</span></span><br><span class="line">        <span class="attr">max-idle-connections:</span> <span class="number">3</span></span><br><span class="line">        <span class="attr">keep-alive-second:</span> <span class="number">100</span></span><br><span class="line">        <span class="attr">test2:</span></span><br><span class="line">        <span class="attr">max-idle-connections:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">keep-alive-second:</span> <span class="number">50</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过<code>@RetrofitClient</code>的<code>poolName</code>属性来指定使用的连接池。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RetrofitClient</span>(baseUrl = <span class="string">"$&#123;test.baseUrl&#125;"</span>, poolName=<span class="string">"test1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpApi</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">    <span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h3><p>很多情况下，我们希望将http请求日志记录下来。通过<code>@RetrofitClient</code>的<code>logLevel</code>和<code>logStrategy</code>属性，您可以指定每个接口的日志打印级别以及日志打印策略。<code>retrofit-spring-boot-starter</code>支持了5种日志打印级别(<code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code>, <code>TRACE</code>)，默认<code>INFO</code>；支持了4种日志打印策略（<code>NONE</code>, <code>BASIC</code>, <code>HEADERS</code>, <code>BODY</code>），默认<code>BASIC</code>。4种日志打印策略含义如下：</p>
<ol>
<li><code>NONE</code>：No logs.</li>
<li><code>BASIC</code>：Logs request and response lines.</li>
<li><code>HEADERS</code>：Logs request and response lines and their respective headers.</li>
<li><code>BODY</code>：Logs request and response lines and their respective headers and bodies (if present).</li>
</ol>
<p><code>retrofit-spring-boot-starter</code>默认使用了<code>DefaultLoggingInterceptor</code>执行真正的日志打印功能，其底层就是<code>okhttp</code>原生的<code>HttpLoggingInterceptor</code>。当然，你也可以自定义实现自己的日志打印拦截器，只需要继承<code>BaseLoggingInterceptor</code>（具体可以参考<code>DefaultLoggingInterceptor</code>的实现），然后在配置文件中进行相关配置即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retrofit:</span></span><br><span class="line">  <span class="comment"># 日志打印拦截器</span></span><br><span class="line">  <span class="attr">logging-interceptor:</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.interceptor.DefaultLoggingInterceptor</span></span><br></pre></td></tr></table></figure>

<h3 id="Http异常信息格式化器"><a href="#Http异常信息格式化器" class="headerlink" title="Http异常信息格式化器"></a>Http异常信息格式化器</h3><p>当出现http请求异常时，原始的异常信息可能阅读起来并不友好，因此<code>retrofit-spring-boot-starter</code>提供了<code>Http异常信息格式化器</code>，用来美化输出http请求参数，默认使用<code>DefaultHttpExceptionMessageFormatter</code>进行请求数据格式化。你也可以进行自定义，只需要继承<code>BaseHttpExceptionMessageFormatter</code>，再进行相关配置即可。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">retrofit:</span></span><br><span class="line">  <span class="comment"># Http异常信息格式化器</span></span><br><span class="line">  <span class="attr">http-exception-message-formatter:</span> <span class="string">com.github.lianjiatech.retrofit.spring.boot.interceptor.DefaultHttpExceptionMessageFormatter</span></span><br></pre></td></tr></table></figure>

<h3 id="调用适配器-CallAdapter"><a href="#调用适配器-CallAdapter" class="headerlink" title="调用适配器 CallAdapter"></a>调用适配器 CallAdapter</h3><p><code>Retrofit</code>可以通过调用适配器<code>CallAdapterFactory</code>将<code>Call&lt;T&gt;</code>对象适配成接口方法的返回值类型。<code>retrofit-spring-boot-starter</code>扩展2种<code>CallAdapterFactory</code>实现：</p>
<ol>
<li><code>BodyCallAdapterFactory</code><ul>
<li>默认启用，可通过配置<code>retrofit.enable-body-call-adapter=false</code>关闭</li>
<li>同步执行http请求，将响应体内容适配成接口方法的返回值类型实例。</li>
<li>除了<code>Retrofit.Call&lt;T&gt;</code>、<code>Retrofit.Response&lt;T&gt;</code>、<code>java.util.concurrent.CompletableFuture&lt;T&gt;</code>之外，其它返回类型都可以使用该适配器。</li>
</ul>
</li>
<li><code>ResponseCallAdapterFactory</code><ul>
<li>默认启用，可通过配置<code>retrofit.enable-response-call-adapter=false</code>关闭</li>
<li>同步执行http请求，将响应体内容适配成<code>Retrofit.Response&lt;T&gt;</code>返回。</li>
<li>如果方法的返回值类型为<code>Retrofit.Response&lt;T&gt;</code>，则可以使用该适配器。</li>
</ul>
</li>
</ol>
<p><strong>Retrofit自动根据方法返回值类型选用对应的<code>CallAdapterFactory</code>执行适配处理！加上Retrofit默认的<code>CallAdapterFactory</code>，可支持多种形式的方法返回值类型：</strong></p>
<ul>
<li><code>Call&lt;T&gt;</code>: 不执行适配处理，直接返回<code>Call&lt;T&gt;</code>对象</li>
<li><code>CompletableFuture&lt;T&gt;</code>: 将响应体内容适配成<code>CompletableFuture&lt;T&gt;</code>对象返回</li>
<li><code>Void</code>: 不关注返回类型可以使用<code>Void</code>。如果http状态码不是2xx，直接抛错！</li>
<li><code>Response&lt;T&gt;</code>: 将响应内容适配成<code>Response&lt;T&gt;</code>对象返回</li>
<li>其他任意Java类型： 将响应体内容适配成一个对应的Java类型对象返回，如果http状态码不是2xx，直接抛错！</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Call&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 不执行适配处理，直接返回Call&lt;T&gt;对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">Call&lt;Result&lt;Person&gt;&gt; getPersonCall(<span class="meta">@Query</span>(<span class="string">"id"</span>) Long id);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  CompletableFuture&lt;T&gt;</span></span><br><span class="line"><span class="comment"> *  将响应体内容适配成CompletableFuture&lt;T&gt;对象返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">CompletableFuture&lt;Result&lt;Person&gt;&gt; getPersonCompletableFuture(<span class="meta">@Query</span>(<span class="string">"id"</span>) Long id);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Void</span></span><br><span class="line"><span class="comment"> * 不关注返回类型可以使用Void。如果http状态码不是2xx，直接抛错！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="function">Void <span class="title">getPersonVoid</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  Response&lt;T&gt;</span></span><br><span class="line"><span class="comment"> *  将响应内容适配成Response&lt;T&gt;对象返回</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line">Response&lt;Result&lt;Person&gt;&gt; getPersonResponse(<span class="meta">@Query</span>(<span class="string">"id"</span>) Long id);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 其他任意Java类型</span></span><br><span class="line"><span class="comment"> * 将响应体内容适配成一个对应的Java类型对象返回，如果http状态码不是2xx，直接抛错！</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GET</span>(<span class="string">"person"</span>)</span><br><span class="line"><span class="function">Result&lt;Person&gt; <span class="title">getPerson</span><span class="params">(@Query(<span class="string">"id"</span>)</span> Long id)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>我们也可以通过继承<code>CallAdapter.Factory</code>扩展实现自己的<code>CallAdapter</code></strong>；然后将自定义的<code>CallAdapterFactory</code>配置成<code>spring</code>的<code>bean</code>！</p>
<blockquote>
<p>自定义配置的<code>CallAdapter.Factory</code>优先级更高！</p>
</blockquote>
<h3 id="数据转码器-Converter"><a href="#数据转码器-Converter" class="headerlink" title="数据转码器 Converter"></a>数据转码器 Converter</h3><p><code>Retrofi</code>使用<code>Converter</code>将<code>@Body</code>注解标注的对象转换成请求体，将响应体数据转换成一个<code>Java</code>对象，可以选用以下几种<code>Converter</code>：</p>
<ul>
<li>Gson: com.squareup.Retrofit:converter-gson</li>
<li>Jackson: com.squareup.Retrofit:converter-jackson</li>
<li>Moshi: com.squareup.Retrofit:converter-moshi</li>
<li>Protobuf: com.squareup.Retrofit:converter-protobuf</li>
<li>Wire: com.squareup.Retrofit:converter-wire</li>
<li>Simple XML: com.squareup.Retrofit:converter-simplexml</li>
</ul>
<p><code>retrofit-spring-boot-starter</code>默认使用的是jackson进行序列化转换！<strong>如果需要使用其它序列化方式，在项目中引入对应的依赖，再把对应的<code>ConverterFactory</code>配置成spring的bean即可</strong>。</p>
<p><strong>我们也可以通过继承<code>Converter.Factory</code>扩展实现自己的<code>Converter</code></strong>；然后将自定义的<code>Converter.Factory</code>配置成<code>spring</code>的<code>bean</code>！</p>
<blockquote>
<p>自定义配置的<code>Converter.Factory</code>优先级更高！</p>
</blockquote>
<h3 id="全局拦截器-BaseGlobalInterceptor"><a href="#全局拦截器-BaseGlobalInterceptor" class="headerlink" title="全局拦截器 BaseGlobalInterceptor"></a>全局拦截器 BaseGlobalInterceptor</h3><p>如果我们需要对整个系统的的http请求执行统一的拦截处理，可以自定义实现全局拦截器<code>BaseGlobalInterceptor</code>, 并配置成<code>spring</code>中的<code>bean</code>！例如我们需要在整个系统发起的http请求，都带上来源信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SourceInterceptor</span> <span class="keyword">extends</span> <span class="title">BaseGlobalInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">doIntercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        Request newReq = request.newBuilder()</span><br><span class="line">                .addHeader(<span class="string">"source"</span>, <span class="string">"test"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(newReq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>至此，spring-boot项目下最优雅的http客户端工具介绍就结束了，更多详细信息可以参考官方文档：<a href="http://square.github.io/retrofit/" target="_blank" rel="noopener">retrofit</a>以及<a href="https://github.com/LianjiaTech/retrofit-spring-boot-starter" target="_blank" rel="noopener">retrofit-spring-boot-starter</a>。</p>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>数据量大了一定要分表，分库分表组件Sharding-JDBC入门与项目实战</title>
    <url>/posts/2363983740/</url>
    <content><![CDATA[<p>最近项目中不少表的数据量越来越大，并且导致了一些数据库的性能问题。因此想借助一些分库分表的中间件，实现自动化分库分表实现。调研下来，发现<code>Sharding-JDBC</code>目前成熟度最高并且应用最广的<code>Java分库分表的客户端组件</code>。本文主要介绍一些Sharding-JDBC核心概念以及生产环境下的实战指南，旨在帮助组内成员快速了解Sharding-JDBC并且能够快速将其使用起来。<a href="https://shardingsphere.apache.org/document/current/cn/overview/" target="_blank" rel="noopener">Sharding-JDBC官方文档</a></p>
<a id="more"></a>

<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>在使用<code>Sharding-JDBC</code>之前，一定是先理解清楚下面几个核心概念。</p>
<h3 id="逻辑表"><a href="#逻辑表" class="headerlink" title="逻辑表"></a>逻辑表</h3><p>水平拆分的数据库（表）的相同逻辑和数据结构表的总称。例：订单数据根据主键尾数拆分为10张表，分别是<code>t_order_0</code>到<code>t_order_9</code>，他们的逻辑表名为<code>t_order</code>。</p>
<h3 id="真实表"><a href="#真实表" class="headerlink" title="真实表"></a>真实表</h3><p>在分片的数据库中真实存在的物理表。即上个示例中的<code>t_order_0</code>到<code>t_order_9</code>。</p>
<h3 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h3><p>数据分片的最小单元。由数据源名称和数据表组成，例：<code>ds_0.t_order_0</code>。</p>
<h3 id="绑定表"><a href="#绑定表" class="headerlink" title="绑定表"></a>绑定表</h3><p>指分片规则一致的主表和子表。例如：<code>t_order</code>表和<code>t_order_item</code>表，均按照<code>order_id</code>分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。举例说明,如果SQL为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>

<p>假设<code>t_order</code>和<code>t_order_item</code>对应的真实表各有2个，那么真实表就有<code>t_order_0</code>、<code>t_order_1</code>、<code>t_order_item_0</code>、<code>t_order_item_1</code>。在不配置绑定表关系时，假设分片键<code>order_id</code>将数值10路由至第0片，将数值11路由至第1片，那么路由后的SQL应该为4条，它们呈现为笛卡尔积：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>

<p>在配置绑定表关系后，路由的SQL应该为2条：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">SELECT</span> i.* <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id=i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>

<h3 id="广播表"><a href="#广播表" class="headerlink" title="广播表"></a>广播表</h3><p>指所有的分片数据源中都存在的表，表结构和表中的数据在每个数据库中均完全一致。适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。</p>
<h2 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h2><h3 id="分片键"><a href="#分片键" class="headerlink" title="分片键"></a>分片键</h3><p>用于分片的数据库字段，是将数据库(表)水平拆分的关键字段。例：将订单表中的订单主键的尾数取模分片，则订单主键为分片字段。 SQL 中如果无分片字段，将执行全路由，性能较差。 除了对单分片字段的支持，Sharding-JDBC 也支持根据多个字段进行分片。</p>
<h3 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a>分片算法</h3><p>通过分片算法将数据分片，支持通过<code>=、&gt;=、&lt;=、&gt;、&lt;、BETWEEN和IN</code>分片。 分片算法需要应用方开发者自行实现，可实现的灵活度非常高。</p>
<p>目前提供4种分片算法。 由于分片算法和业务实现紧密相关，因此并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。</p>
<h4 id="精确分片算法"><a href="#精确分片算法" class="headerlink" title="精确分片算法"></a>精确分片算法</h4><p>对应 <code>PreciseShardingAlgorithm</code>，<strong>用于处理使用单一键作为分片键的 = 与 IN 进行分片的场景</strong>。需要配合 <code>StandardShardingStrategy</code> 使用。</p>
<h4 id="范围分片算法"><a href="#范围分片算法" class="headerlink" title="范围分片算法"></a>范围分片算法</h4><p>对应 <code>RangeShardingAlgorithm</code>，<strong>用于处理使用单一键作为分片键的 BETWEEN AND、&gt;、&lt;、&gt;=、&lt;=进行分片的场景</strong>。需要配合 StandardShardingStrategy 使用。</p>
<h4 id="复合分片算法"><a href="#复合分片算法" class="headerlink" title="复合分片算法"></a>复合分片算法</h4><p>对应 <code>ComplexKeysShardingAlgorithm</code>，用于处理使用多键作为分片键进行分片的场景，包含多个分片键的逻辑较复杂，需要应用开发者自行处理其中的复杂度。需要配合 <code>ComplexShardingStrategy</code> 使用。</p>
<h4 id="Hint分片算法"><a href="#Hint分片算法" class="headerlink" title="Hint分片算法"></a>Hint分片算法</h4><p>对应 <code>HintShardingAlgorithm</code>，<strong>用于处理通过Hint指定分片值而非从SQL中提取分片值的场景</strong>。需要配合 <code>HintShardingStrategy</code> 使用。</p>
<h3 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h3><p>包含分片键和分片算法，由于分片算法的独立性，将其独立抽离。真正可用于分片操作的是分片键 + 分片算法，也就是分片策略。目前提供 5 种分片策略。</p>
<h3 id="标准分片策略"><a href="#标准分片策略" class="headerlink" title="标准分片策略"></a>标准分片策略</h3><p>对应 <code>StandardShardingStrategy</code>。提供对 SQ L语句中的 <code>=, &gt;, &lt;, &gt;=, &lt;=, IN 和 BETWEEN AND</code> 的分片操作支持。 <code>StandardShardingStrategy</code> 只支持单分片键，提供 <code>PreciseShardingAlgorithm</code> 和 <code>RangeShardingAlgorithm</code> 两个分片算法。 <strong><code>PreciseShardingAlgorithm</code> 是必选的</strong>，用于处理 = 和 IN 的分片。 <code>RangeShardingAlgorithm</code> 是可选的，用于处理 <code>BETWEEN AND, &gt;, &lt;, &gt;=, &lt;=</code>分片，如果不配置 RangeShardingAlgorithm，SQL 中的 BETWEEN AND 将按照全库路由处理。</p>
<h3 id="复合分片策略"><a href="#复合分片策略" class="headerlink" title="复合分片策略"></a>复合分片策略</h3><p>对应 <code>ComplexShardingStrategy</code>。复合分片策略。提供对 SQL 语句中的 <code>=, &gt;, &lt;, &gt;=, &lt;=, IN 和 BETWEEN AND</code> 的分片操作支持。 <strong><code>ComplexShardingStrategy</code> 支持多分片键</strong>，由于多分片键之间的关系复杂，因此并未进行过多的封装，而是直接将分片键值组合以及分片操作符透传至分片算法，完全由应用开发者实现，提供最大的灵活度。</p>
<h3 id="行表达式分片策略"><a href="#行表达式分片策略" class="headerlink" title="行表达式分片策略"></a>行表达式分片策略</h3><p>对应 <code>InlineShardingStrategy</code>。使用 Groovy 的表达式，提供对 SQL 语句中的 <code>= 和 IN</code>的分片操作支持，只支持单分片键。 对于简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发，如: <code>t_user_$-&gt;{u_id % 8}</code> 表示 t_user 表根据 u_id 模 8，而分成 8 张表，表名称为 <code>t_user_0</code> 到 <code>t_user_7</code>。 <strong>可以认为是精确分片算法的简易实现</strong></p>
<h3 id="Hint分片策略"><a href="#Hint分片策略" class="headerlink" title="Hint分片策略"></a>Hint分片策略</h3><p>对应 HintShardingStrategy。通过 Hint 指定分片值而非从 SQL 中提取分片值的方式进行分片的策略。</p>
<h3 id="分布式主键"><a href="#分布式主键" class="headerlink" title="分布式主键"></a>分布式主键</h3><p>用于在分布式环境下，生成全局唯一的id。Sharding-JDBC 提供了内置的分布式主键生成器，例如 <code>UUID</code>、<code>SNOWFLAKE</code>。还抽离出分布式主键生成器的接口，方便用户自行实现自定义的自增主键生成器。<strong>为了保证数据库性能，主键id还必须趋势递增，避免造成频繁的数据页面分裂。</strong></p>
<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>提供一主多从的读写分离配置，可独立使用，也可配合分库分表使用。</p>
<ul>
<li>同一线程且同一数据库连接内，如有写入操作，以后的读操作均从主库读取，用于保证数据一致性</li>
<li>基于Hint的强制主库路由。</li>
<li>主从模型中，事务中读写均用主库。</li>
</ul>
<h2 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h2><p>Sharding-JDBC 的原理总结起来很简单: 核心由 <code>SQL解析 =&gt; 执行器优化 =&gt; SQL路由 =&gt; SQL改写 =&gt; SQL执行 =&gt; 结果归并</code>的流程组成。<br><img data-src="https://shardingsphere.apache.org/document/current/img/sharding/sharding_architecture_cn.png" alt="Sharding-JDBC执行流程"></p>
<h2 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h2><p>spring-boot项目实战</p>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding-jdbc-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h3><p>如果使用<code>sharding-jdbc-spring-boot-starter</code>, 并且数据源以及数据分片都使用shardingsphere进行配置，对应的数据源会自动创建并注入到spring容器中。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">spring.shardingsphere.datasource.names</span>=<span class="string">ds0,ds1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.type</span>=<span class="string">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.url</span>=<span class="string">jdbc:mysql://localhost:3306/ds0</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds0.password</span>=<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.type</span>=<span class="string">org.apache.commons.dbcp.BasicDataSource</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.driver-class-name</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.url</span>=<span class="string">jdbc:mysql://localhost:3306/ds1</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">spring.shardingsphere.datasource.ds1.password</span>=<span class="string"></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 其它分片配置</span></span><br></pre></td></tr></table></figure>

<p>但是在我们已有的项目中，数据源配置是单独的。<strong>因此要禁用<code>sharding-jdbc-spring-boot-starter</code>里面的自动装配，而是参考源码自己重写数据源配置</strong>。需要在启动类上加上<code>@SpringBootApplication(exclude = {org.apache.shardingsphere.shardingjdbc.spring.boot.SpringBootConfiguration.class})</code>来排除。然后自定义配置类来装配<code>DataSource</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(&#123;</span><br><span class="line">        SpringBootShardingRuleConfigurationProperties<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">        <span class="title">SpringBootMasterSlaveRuleConfigurationProperties</span>.<span class="title">class</span>, <span class="title">SpringBootEncryptRuleConfigurationProperties</span>.<span class="title">class</span>, <span class="title">SpringBootPropertiesConfigurationProperties</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">@<span class="title">AutoConfigureBefore</span>(<span class="title">DataSourceConfiguration</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">DataSourceConfig</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SpringBootShardingRuleConfigurationProperties shardingRule;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> SpringBootPropertiesConfigurationProperties props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"shardingDataSource"</span>)</span><br><span class="line">    <span class="meta">@Conditional</span>(ShardingRuleCondition<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">DataSource</span> <span class="title">shardingDataSource</span>() <span class="title">throws</span> <span class="title">SQLException</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取其它方式配置的数据源</span></span><br><span class="line">        Map&lt;String, DruidDataSourceWrapper&gt; beans = applicationContext.getBeansOfType(DruidDataSourceWrapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Map&lt;String, DataSource&gt; dataSourceMap = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        beans.forEach(dataSourceMap::put);</span><br><span class="line">        <span class="comment">// 创建shardingDataSource</span></span><br><span class="line">        <span class="keyword">return</span> ShardingDataSourceFactory.createDataSource(dataSourceMap, <span class="keyword">new</span> ShardingRuleConfigurationYamlSwapper().swap(shardingRule), props.getProps());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">sqlSessionFactory</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        SqlSessionFactoryBean sqlSessionFactoryBean = <span class="keyword">new</span> SqlSessionFactoryBean();</span><br><span class="line">        <span class="comment">// 将shardingDataSource设置到SqlSessionFactory中</span></span><br><span class="line">        sqlSessionFactoryBean.setDataSource(shardingDataSource());</span><br><span class="line">        <span class="comment">// 其它设置</span></span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactoryBean.getObject();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式id生成器配置"><a href="#分布式id生成器配置" class="headerlink" title="分布式id生成器配置"></a>分布式id生成器配置</h3><p>Sharding-JDBC提供了<code>UUID</code>、<code>SNOWFLAKE</code>生成器，还支持用户实现自定义id生成器。比如可以实现了type为<code>SEQ</code>的分布式id生成器，调用统一的<code>分布式id服务</code>获取id。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeqShardingKeyGenerator</span> <span class="keyword">implements</span> <span class="title">ShardingKeyGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"SEQ"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> Comparable&lt;?&gt; generateKey() &#123;</span><br><span class="line">       <span class="comment">// 获取分布式id逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>由于扩展<code>ShardingKeyGenerator</code>是通过JDK的<code>serviceloader</code>的SPI机制实现的，因此还需要在<code>resources/META-INF/services</code>目录下配置<code>org.apache.shardingsphere.spi.keygen.ShardingKeyGenerator</code>文件。</strong> 文件内容就是<code>SeqShardingKeyGenerator</code>类的全路径名。这样使用的时候，指定分布式主键生成器的type为<code>SEQ</code>就好了。</p>
<p>至此，Sharding-JDBC就整合进spring-boot项目中了，后面就可以进行数据分片相关的配置了。</p>
<h3 id="数据分片实战"><a href="#数据分片实战" class="headerlink" title="数据分片实战"></a>数据分片实战</h3><p>如果项目初期就能预估出表的数据量级，当然可以一开始就按照这个预估值进行分库分表处理。但是大多数情况下，我们一开始并不能准备预估出数量级。这时候通常的做法是：</p>
<ol>
<li>线上数据某张表查询性能开始下降，排查下来是因为数据量过大导致的。</li>
<li>根据历史数据量预估出未来的数据量级，并结合具体业务场景确定分库分表策略。</li>
<li>自动分库分表代码实现。</li>
</ol>
<p>下面就以一个具体事例，阐述具体数据分片实战。比如有张表数据结构如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`hc_question_reply_record`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'自增ID'</span>,</span><br><span class="line">  <span class="string">`reply_text`</span> <span class="built_in">varchar</span>(<span class="number">500</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> <span class="keyword">COMMENT</span> <span class="string">'回复内容'</span>,</span><br><span class="line">  <span class="string">`reply_wheel_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'回复时间'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="string">`ctime`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`mtime`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">  <span class="keyword">INDEX</span> <span class="string">`idx_reply_wheel_time`</span> (<span class="string">`reply_wheel_time`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 <span class="keyword">COLLATE</span>=utf8mb4_unicode_ci</span><br><span class="line">  <span class="keyword">COMMENT</span>=<span class="string">'回复明细记录'</span>;</span><br></pre></td></tr></table></figure>

<h4 id="分片方案确定"><a href="#分片方案确定" class="headerlink" title="分片方案确定"></a>分片方案确定</h4><p>先查询目前目标表月新增趋势：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">count</span>(*), <span class="keyword">date_format</span>(ctime, <span class="string">'%Y-%m'</span>) <span class="keyword">AS</span> <span class="string">`日期`</span></span><br><span class="line"><span class="keyword">FROM</span> hc_question_reply_record</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">date_format</span>(ctime, <span class="string">'%Y-%m'</span>);</span><br></pre></td></tr></table></figure>

<p><img data-src="https://chentianming11.github.io/images/month-increse.png" alt="月新增趋势"></p>
<p>目前月新增在180w左右，预估未来达到300w(基本以2倍计算)以上。期望单表数据量不超过1000w，可使用<code>reply_wheel_time</code>作为分片键按季度归档。</p>
<h4 id="分片配置"><a href="#分片配置" class="headerlink" title="分片配置"></a>分片配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="comment"># sharing-jdbc配置</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="comment"># 数据源名称</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span> <span class="string">defaultDataSource,slaveDataSource</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="comment"># 主从节点配置</span></span><br><span class="line">      <span class="attr">master-slave-rules:</span></span><br><span class="line">        <span class="attr">defaultDataSource:</span></span><br><span class="line">          <span class="comment"># maser数据源</span></span><br><span class="line">          <span class="attr">master-data-source-name:</span> <span class="string">defaultDataSource</span></span><br><span class="line">          <span class="comment"># slave数据源</span></span><br><span class="line">          <span class="attr">slave-data-source-names:</span> <span class="string">slaveDataSource</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="comment"># hc_question_reply_record 分库分表配置</span></span><br><span class="line">        <span class="attr">hc_question_reply_record:</span></span><br><span class="line">          <span class="comment"># 真实数据节点  hc_question_reply_record_2020_q1</span></span><br><span class="line">          <span class="attr">actual-data-nodes:</span> <span class="string">defaultDataSource.hc_question_reply_record_$-&gt;&#123;2020..2025&#125;_q$-&gt;&#123;1..4&#125;</span></span><br><span class="line">          <span class="comment"># 表分片策略</span></span><br><span class="line">          <span class="attr">table-strategy:</span></span><br><span class="line">            <span class="attr">standard:</span></span><br><span class="line">              <span class="comment"># 分片键</span></span><br><span class="line">              <span class="attr">sharding-column:</span> <span class="string">reply_wheel_time</span></span><br><span class="line">              <span class="comment"># 精确分片算法 全路径名</span></span><br><span class="line">              <span class="attr">preciseAlgorithmClassName:</span> <span class="string">com.xx.QuestionRecordPreciseShardingAlgorithm</span></span><br><span class="line">              <span class="comment"># 范围分片算法，用于BETWEEN，可选。。该类需实现RangeShardingAlgorithm接口并提供无参数的构造器</span></span><br><span class="line">              <span class="attr">rangeAlgorithmClassName:</span> <span class="string">com.xx.QuestionRecordRangeShardingAlgorithm</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 默认分布式id生成器</span></span><br><span class="line">      <span class="attr">default-key-generator:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">SEQ</span></span><br><span class="line">        <span class="attr">column:</span> <span class="string">id</span></span><br></pre></td></tr></table></figure>

<h4 id="分片算法实现"><a href="#分片算法实现" class="headerlink" title="分片算法实现"></a>分片算法实现</h4><ul>
<li><p>精确分片算法：<code>QuestionRecordPreciseShardingAlgorithm</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuestionRecordPreciseShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">PreciseShardingAlgorithm</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sharding.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> availableTargetNames available data sources or tables's names</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> shardingValue        sharding value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> sharding result for data source or table's name</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, PreciseShardingValue&lt;Date&gt; shardingValue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ShardingUtils.quarterPreciseSharding(availableTargetNames, shardingValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>范围分片算法：<code>QuestionRecordRangeShardingAlgorithm</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuestionRecordRangeShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title">RangeShardingAlgorithm</span>&lt;<span class="title">Date</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sharding.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> availableTargetNames available data sources or tables's names</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> shardingValue        sharding value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> sharding results for data sources or tables's names</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, RangeShardingValue&lt;Date&gt; shardingValue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> ShardingUtils.quarterRangeSharding(availableTargetNames, shardingValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>具体分片实现逻辑：<code>ShardingUtils</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@UtilityClass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShardingUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QUARTER_SHARDING_PATTERN = <span class="string">"%s_%d_q%d"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * logicTableName_&#123;year&#125;_q&#123;quarter&#125;</span></span><br><span class="line"><span class="comment">    * 按季度范围分片</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> availableTargetNames 可用的真实表集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> shardingValue 分片值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;String&gt; <span class="title">quarterRangeSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, RangeShardingValue&lt;Date&gt; shardingValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里就是根据范围查询条件，筛选出匹配的真实表集合</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * logicTableName_&#123;year&#125;_q&#123;quarter&#125;</span></span><br><span class="line"><span class="comment">    * 按季度精确分片</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> availableTargetNames 可用的真实表集合</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> shardingValue 分片值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">quarterPreciseSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames, PreciseShardingValue&lt;Date&gt; shardingValue)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里就是根据等值查询条件，计算出匹配的真实表</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>到这里，针对<code>hc_question_reply_record</code>表，使用<code>reply_wheel_time</code>作为分片键，按照季度分片的处理就完成了。还有一点要注意的就是，<strong>分库分表之后，查询的时候最好都带上分片键作为查询条件</strong>，否则就会使用全库路由，性能很低。 还有就是<code>Sharing-JDBC</code>对<code>mysql</code>的全文索引支持的不是很好，项目有使用到的地方也要注意一下。总结来说整个过程还是比较简单的，后续碰到其它业务场景，相信大家按照这个思路肯定都能解决的。</p>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sharing-jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot项目整合Swagger自动生成接口文档之最佳实践指南</title>
    <url>/posts/1541374189/</url>
    <content><![CDATA[<p>最近为项目引入<code>Swagger</code>来支持自动生成文档功能，发现很多文章仅仅介绍了如何接入以及如何使用的问题。<strong>但是对于实际工程实践，并没有给出相应的最佳实践方案。因此，我重新梳理相关内容以及文档，整理出一套最佳实践指南</strong>。</p>
<a id="more"></a>

<h2 id="Swagger和Springfox"><a href="#Swagger和Springfox" class="headerlink" title="Swagger和Springfox"></a>Swagger和Springfox</h2><p>在正式介绍之前，我们首先要了解<code>Swagger</code>和<code>Springfox</code>之间的关系。相信在<code>Spring</code>项目使用过<code>Swagger</code>的同学都知道，在<code>Spring</code>项目中是通过<code>Springfox</code>来整合<code>Swagger</code>功能的。</p>
<h3 id="Swagger是什么"><a href="#Swagger是什么" class="headerlink" title="Swagger是什么"></a>Swagger是什么</h3><p>根据官网的介绍，<code>Swagger</code>是一系列用于<code>Restful API</code>开发的工具，开源的部分包括：</p>
<ul>
<li>OpenAPI Specification：API规范，规定了如何描述一个系统的API</li>
<li>Swagger Codegen：用于通过API规范生成服务端和客户端代码</li>
<li>Swagger Editor：用来编写API规范</li>
<li>Swagger UI：用于展示API规范</li>
</ul>
<p><strong>简单来说，我们可以认为<code>swagger</code>主要制定并实现了一个<code>API</code>规范，用于描述系统的<code>API</code>接口</strong>。</p>
<h3 id="Springfox是什么"><a href="#Springfox是什么" class="headerlink" title="Springfox是什么"></a>Springfox是什么</h3><p>简单来说，<code>Springfox</code>其实是一个通过扫描并提取代码中的信息，来生成<code>API</code>文档的工具，支持<code>swagger</code>、<code>RAML</code>、<code>jsonapi</code>等多种<code>API</code>文档的格式。因为我们这里着重讨论<code>swagger</code>，因此我们可以简单理解为：<strong><code>Springfox</code>就是整合<code>SpringMVC</code>和<code>swagger</code>的中间层，以支持自动扫描<code>Controller</code>层的接口来生成符合<code>swagger</code>API规范的描述数据(<code>JSON</code>格式)</strong>。</p>
<p>通过<code>Springfox</code>，已经可以将<code>swagger</code>与<code>SpringBoot</code>项目整合起来了，网上有一大堆整合的文章，这里就不再赘述了，具体可以参考<a href="https://juejin.cn/post/6844903991793418248" target="_blank" rel="noopener">SpringBoot整合Swagger实战</a>。并且官方最近也出了<code>3.0</code>版本，具体可以参考：<a href="https://juejin.cn/post/6890692970018766856" target="_blank" rel="noopener">还在手动整合Swagger？Swagger官方Starter是真的香！</a>。</p>
<h2 id="knife4j简介"><a href="#knife4j简介" class="headerlink" title="knife4j简介"></a>knife4j简介</h2><p>虽然直接通过<code>Springfox</code>已经可以实现<code>SpringBoot</code>接入<code>Swagger</code>生成接口文档。但是这种方式有两个弊端：</p>
<ol>
<li>原生接口文档页面展示不够友好。</li>
<li>使用起来可能比较繁琐。</li>
</ol>
<p>因此，在这里强烈推荐使用<code>Knife4j</code>。<code>Knife4j</code>是<code>Swagger</code>接口文档服务的通用性解决方案，底层基于<code>Springfox</code>实现。最主要的两个特性如下：</p>
<ol>
<li>重写了前端UI界面，更符合国人使用习惯。</li>
<li>支持快速接入，并提供了很多实用功能增强。</li>
<li>文档友好，直接参考<code>Knife4j</code>官网文档就能完成接入。</li>
</ol>
<p>能让用户以最低成本接入的方式就是最好的方式，而<code>Knife4j</code>确实实现的非常好。更多详细信息可以参考官方文档<a href="https://xiaoym.gitee.io/knife4j/documentation/description.html" target="_blank" rel="noopener">https://xiaoym.gitee.io/knife4j/documentation/description.html</a>。</p>
<h2 id="最佳实践指南"><a href="#最佳实践指南" class="headerlink" title="最佳实践指南"></a>最佳实践指南</h2><p><strong>实际上，<code>SpringBoot</code>的<code>Controller</code>层方法已经包含描述该接口详细信息了。当然，因为我们要补充中文说明。因此，最为理想的状况是，接口文档直接能直接根据<code>Controller</code>层的方法自动生成，我们顶多为每个参数编写一个中文说明，仅此而已</strong>。</p>
<p><strong>我觉得完全自描述的接口才是最合理的，同时也是最简便的</strong>。但是，理想很好，现实情况是<code>Springfox</code>对此支持的并不算太好。因此，我们需要在实践的时候，找到一种方式来解决这个问题，下面会介绍一些常见问题的解决思路。</p>
<h3 id="2-x和3-x版本如何选择"><a href="#2-x和3-x版本如何选择" class="headerlink" title="2.x和3.x版本如何选择"></a>2.x和3.x版本如何选择</h3><p><code>Knife4j</code>的<code>2.x</code>版本对应<code>Springfox</code>的<code>2.x</code>版本，其采用的是<code>Swagger2</code>规范，相应的<code>3.x</code>版本使用的<code>OpenAPI3</code>规范。<strong>关于这两个规范，我们不需要了解太多细节，只需要知道<code>OpenAPI3</code>规范能够更准确描述接口就行</strong>。而对于<code>Springfox</code>而言，<code>3.x</code>版本还有一个优势是：<strong>对于<code>Bean Validation</code>支持更好，能够从接口自身解析出更详细的接口信息</strong>。因此，<strong>如果条件允许，强烈建议<code>3.x</code>版本</strong>！我甚至觉得，如果是<code>2.x</code>版本，接入的价值都不大。我始终觉得，在一个本身已经自描述的接口上，再去专门为文档去写各种注释是一件本末倒置的事情。既然已经自描述，那么最佳的解决方案永远都是框架去解析，而不是人工再写一遍！！！</p>
<p>以下是一个<code>2.x</code>和<code>3.x</code>版本，对同一接口生成的接口文档，相信大家看完会有一个自己的判断！</p>
<p><code>2.x</code>版本：<br><img data-src="https://chentianming11.github.io/images/spring/swagger2.x.png" alt="swagger2.x"></p>
<p><code>3.x</code>版本：<br><img data-src="https://chentianming11.github.io/images/spring/swagger3.x.png" alt="swagger3.x"></p>
<p><strong><code>3.x</code>版本能解析出更多的接口信息，描述更为准确</strong>。</p>
<h3 id="对请求体入参支持不够好"><a href="#对请求体入参支持不够好" class="headerlink" title="对请求体入参支持不够好"></a>对请求体入参支持不够好</h3><p>对于<code>Query</code>查询参数，<code>Springfox</code>的<code>3.x</code>版本已经支持的非常好了，我们按之前的方式写接口即可。但是对于请求体参数，现有框架支持的还是不够好。<strong>其中，最为典型的是不支持分组校验</strong>。这样的导致的结果就是，文档上会将整个<code>DTO</code>类的字段以及约束全部展示到任何一个使用了该<code>DTO</code>接收参数的接口上。很明显，这并不合理，因为分组校验做的就是让该接口指定分组下的约束只对这个接口生效。</p>
<p>针对这个问题，有什么完美的解决方案吗？答案是没有，这里只能做一个取舍。<strong>如果十分看重接口文档准确性的话，只能不使用分组校验，这样的话，意味着每个接口的请求体都要用不同的<code>DTO</code>类来接收，以防止互相干扰</strong>。如果不是特别在意，那还是按分组校验来写，实现更简单。目前，我们项目准备选第一种方式。</p>
<blockquote>
<p>如果不了解参数校验，可以戳这里：<a href="https://juejin.cn/post/6856541106626363399" target="_blank" rel="noopener">Spring Validation最佳实践及其实现原理，参数校验没那么简单！</a>。对于参数校验，强烈建议这种注解式的方式。因为只有注解式，才能真正做到接口自描述。</p>
</blockquote>
<h3 id="接入和使用示例"><a href="#接入和使用示例" class="headerlink" title="接入和使用示例"></a>接入和使用示例</h3><h4 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.xiaoymin<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>knife4j-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h4><p><strong>只需要额外再为每个字段加中文说明即可</strong>！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/person"</span>)</span><br><span class="line"><span class="meta">@Validated</span></span><br><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"Person管理"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"保存用户"</span>)</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"savePerson"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;PersonVO&gt; <span class="title">savePerson</span><span class="params">(@RequestBody @Valid SavePersonDTO person)</span> </span>&#123;</span><br><span class="line">        PersonVO personVO = <span class="keyword">new</span> PersonVO().setAge(<span class="number">10</span>).setEmail(<span class="string">"xxxxx"</span>).setId(<span class="number">1L</span>).setName(<span class="string">"哈哈"</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(personVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"更新用户"</span>)</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"updatePerson"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result&lt;PersonVO&gt; <span class="title">updatePerson</span><span class="params">(@RequestBody @Valid UpdatePersonDTO person)</span> </span>&#123;</span><br><span class="line">        PersonVO personVO = <span class="keyword">new</span> PersonVO().setAge(<span class="number">10</span>).setEmail(<span class="string">"xxxxx"</span>).setId(<span class="number">1L</span>).setName(<span class="string">"哈哈"</span>);</span><br><span class="line">        <span class="keyword">return</span> Result.ok(personVO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"查询person"</span>)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"queryPerson"</span>)</span><br><span class="line">    <span class="keyword">public</span> Result&lt;List&lt;PersonVO&gt;&gt; queryPerson(</span><br><span class="line">            <span class="meta">@ApiParam</span>(<span class="string">"用户id"</span>) <span class="meta">@Min</span>(<span class="number">1000</span>) <span class="meta">@Max</span>(<span class="number">10000000</span>) Long id,</span><br><span class="line">            <span class="meta">@ApiParam</span>(<span class="string">"姓名"</span>) <span class="meta">@NotNull</span> <span class="meta">@Size</span>(min = <span class="number">2</span>, max = <span class="number">10</span>) String name,</span><br><span class="line">            <span class="meta">@ApiParam</span>(<span class="string">"年龄"</span>) <span class="meta">@NotNull</span> <span class="meta">@Max</span>(<span class="number">200</span>) Integer age,</span><br><span class="line">            <span class="meta">@ApiParam</span>(<span class="string">"邮箱"</span>) <span class="meta">@Pattern</span>(regexp = <span class="string">"^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$"</span>) String email) &#123;</span><br><span class="line">        List&lt;PersonVO&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> PersonVO().setAge(<span class="number">10</span>).setEmail(<span class="string">"xxxxx"</span>).setId(<span class="number">1L</span>).setName(<span class="string">"哈哈"</span>));</span><br><span class="line">        <span class="keyword">return</span> Result.ok(list);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"保存用户DTO类"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SavePersonDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"姓名"</span>)</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">2</span>, max = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"年龄"</span>)</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="meta">@Max</span>(<span class="number">200</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"邮箱"</span>)</span><br><span class="line">    <span class="meta">@Pattern</span>(regexp = <span class="string">"^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"更新用户DTO类"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpdatePersonDTO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"用户id"</span>)</span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"姓名"</span>)</span><br><span class="line">    <span class="meta">@Size</span>(min = <span class="number">2</span>, max = <span class="number">10</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"年龄"</span>)</span><br><span class="line">    <span class="meta">@Max</span>(<span class="number">200</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"邮箱"</span>)</span><br><span class="line">    <span class="meta">@Pattern</span>(regexp = <span class="string">"^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\\.[a-zA-Z0-9_-]+)+$"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="meta">@ApiModel</span>(<span class="string">"用户VO类"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonVO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"用户id"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"姓名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"年龄"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(<span class="string">"邮箱"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，生产环境并不需要开启接口文档功能，只需要在生产环境加如下配置即可：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">springfox:</span></span><br><span class="line">  <span class="attr">documentation:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h4 id="常用文档注解"><a href="#常用文档注解" class="headerlink" title="常用文档注解"></a>常用文档注解</h4><p><strong>使用文档注解的目的只是为了添加中文说明，仅此而已</strong>！</p>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td><code>@Api</code></td>
<td>标注在<code>Controller</code>上，用于给控制器添加中文说明</td>
<td>@Api(tags = “Person管理”)</td>
</tr>
<tr>
<td><code>@ApiOperation</code></td>
<td>标注在方法上，用于给请求添加中文说明</td>
<td>@ApiOperation(“保存用户”)</td>
</tr>
<tr>
<td><code>@ApiParam</code></td>
<td>标注在方法参数上，用于给请求参数添加中文说明</td>
<td>@ApiParam(“用户id”)</td>
</tr>
<tr>
<td><code>@ApiModel</code></td>
<td>标注在<code>DTO</code>实体类上，用于给请求体添加中文说明</td>
<td>@ApiModel(“保存用户DTO类”)</td>
</tr>
<tr>
<td><code>@ApiModelProperty</code></td>
<td>标注在<code>DTO</code>实体类的字段上，用于给请求体字段添加中文说明</td>
<td>@ApiModelProperty(“姓名”)</td>
</tr>
</tbody></table>
<h4 id="示例截图"><a href="#示例截图" class="headerlink" title="示例截图"></a>示例截图</h4><p><img data-src="https://chentianming11.github.io/images/spring/swagger-demo.png" alt="swagger-demo"></p>
<h4 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h4><p>源码地址：<a href="https://github.com/chentianming11/spring-validation" target="_blank" rel="noopener">https://github.com/chentianming11/spring-validation</a></p>
<p>启动项目，访问<a href="http://localhost:8080/doc.html" target="_blank" rel="noopener">http://localhost:8080/doc.html</a>可查看接口文档。</p>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>2020，我写了个开源项目 | 掘金年度征文</title>
    <url>/posts/2971920835/</url>
    <content><![CDATA[<p><strong>2020年，在技术上最大的一件事情就是写了一个<code>HTTP</code>客户端工具并推动开源，目前该项目在<code>github</code>上差不多收获了<code>400</code>个star</strong>。也许对于各位技术大佬来说，四百<code>star</code>完全微不足道，但对于还是“铁憨憨”的我来说，真的很不容易。在整个过程中，我经历了啃源码时的枯燥、编码设计时的纠结以及开源完成时的喜悦。下面，我们就来详细聊聊这件事。</p>
<a id="more"></a>

<p><img data-src="https://chentianming11.github.io/images/retrofit/retrofit-2020.12.12.png" alt="retrofit-2020.12.12.png"></p>
<p>项目地址：<a href="https://github.com/LianjiaTech/retrofit-spring-boot-starter" target="_blank" rel="noopener">https://github.com/LianjiaTech/retrofit-spring-boot-starter</a></p>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>相信很多小伙伴跟我一样，对代码都有一定的“强迫症”。碰到实现上不够好或者使用上不够方便的代码，总想好好封装一下。<strong>这样不仅能锻炼自己的抽象设计能力，更能显著地提升研发效率，一举两得</strong>。时间回到2019年4月份，当时我们系统是一个<code>spring-boot</code>框架项目，项目中存在大量的<code>http</code>接口调用，但是调用的方式都是<strong>直接在业务方法里面使用类似<code>HttpUtil</code>发起的</strong>。这种实现方式，<strong>不仅丧失了框架层面灵活扩展的可能性，更是完全背离了面向对象的设计原则</strong>。作为一向有代码强迫症的我来说，忍不住就想对它下手了。</p>
<p>当然，光有想法是不够的，更重要的是如何实践。我当时做的第一件事情就是<strong>想清楚自己最终想达成的目标，正所谓“以终为始”，先想清楚目标，再去努力实现</strong>。这里，我联想到了<code>mybatis</code>框架可以直接通过接口执行<code>sql</code>。实际上，不管是执行<code>sql</code>还是发起<code>http</code>请求，本质上都是一种数据交互形式，<strong>因此我最终定的目标就是支持<code>spring-boot</code>项目通过接口发起<code>http</code>请求</strong>。接下来第二件事就是代码实现了，我没有上来直接撸代码，而是先去调研了一下相关的开源实现，毕竟站在巨人的肩膀上才能看得更远。经过一番调研之后，最终有2个项目在我的考虑范围之内，第一个是<code>Feign</code>，另一个是<code>Retrofit</code>，它们都支持通过接口发起<code>http</code>请求。考虑到<code>Feign</code>是<code>spring cloud</code>中消费端的调用框架，而我们的项目当时并不是<code>spring cloud</code>项目，由于不想引入<code>spring cloud</code>相关依赖，因此放弃了<code>Feign</code>。<strong>而<code>Retrofit</code>是基于<code>okhttp</code>封装的<code>http</code>客户端工具，使用同样非常广泛，因此最终选用了<code>Retrofit</code></strong>。</p>
<p>然而，理想很丰满，现实很骨感。<code>retrofit</code>官方并没有提供与<code>spring-boot</code>项目快速整合的<code>starter</code>，这使得我不得不自己将其与<code>spring-boot</code>项目进行整合。实际上，我做的最初版就是做了一个整合，并且也达到过基本可用的状态。如果故事止步于此，<strong>这件事我也就做到了勉强60分甚至是不及格的水准</strong>。<strong>对代码不将就，追求极致才是我们该有的态度</strong>，因此我萌生了一个更加大胆的想法，<strong>做一个开源项目，剥离业务代码，实现更加完整更加优雅的封装</strong>。</p>
<h2 id="开源"><a href="#开源" class="headerlink" title="开源"></a>开源</h2><p><strong>在每一个程序猿心中，自己写一个开源项目是一件很酷的事</strong>，我当时想的就是把这件事做成。但是真正要动手去做的时候才发现，事情比想象中要复杂的多。因为开源项目最终是要给其他人用的，所以我<strong>对自己的代码设计和质量都有更加严格的要求</strong>。而当时不得不承认的一个事实是，我对相关框架源码的理解远远不够，换句话说就是我还不具备写一个开源项目的能力。这个时候，我要做的事情就是先死磕相关源码。经过3个多月的时间，我终于把<code>retrofit</code>、<code>spring</code>和<code>mybatis</code>框架的核心源码全部理解了一遍。看过源码的同学应该都知道，<strong>看源码的过程多少带有一些“煎熬”，但是认真啃完之后收获也会很大</strong>。</p>
<p>准备工作完成之后，就开始正式进入代码设计和实现了。此时，之前啃源码的效果就明显体现出来了，<strong>我在写代码的时候会自然而然地联想到开源框架的优秀实现，然后借鉴过来</strong>。这是一种很抽象的感觉，相信啃过源码的同学都有所体会。就这样，编码大概又花了2个月的时间，整个过程我都处在一个很兴奋的状态，记得那会睡觉的时候都在想怎么撸代码。由于这些工作都是业余时间进行的，因此这大半年时间里面，<strong>我的业余生活明显变得非常充实，现在回想起来，确实很累但很有收获</strong>。</p>
<p>当一切准备就绪，接下来就是接受实际考验的时候了，我们当时替换了线上2个<code>Java</code>项目的<code>http</code>调用，并且通过自测就直接上线了，上线之后效果也很好，没有出现任何异常。后来正式申请项目开源，整个过程比较漫长，大概花了4个月的时间，终于在2020年4月份审核通过。我记得当时刚好是清明节，<strong>我在<code>github</code>上正式发布了自己首个开源项目</strong>。不知不觉完成了目标，甚是欣慰。</p>
<h2 id="百星"><a href="#百星" class="headerlink" title="百星"></a>百星</h2><p>在接下来的2个月里面，我主要是做了一些功能上的迭代优化，<code>github</code>上的<code>star</code>数量依然少的可怜。在6月份的时候，我准备写<code>2.0</code>版本了。之所以要这么快写<code>2.0</code>版本，不是因为我们<code>1.0</code>写的有多烂，而是因为这段时间，我思想上出现了一些转变。<strong>之前写<code>1.0</code>的时候，我完全站在自己的视角去想项目应该支持哪些功能，兼容哪些框架，这诚然是我应该考虑的问题，但是好像偏离了方向，偏离了实际</strong>。我把实现做的复杂，仅仅是为了支持可能并不存在的需求。因此，<strong>在<code>2.0</code>的设计上，我做了大量简化，仅保留最重要最核心的功能，我觉得只有用户一下就能看懂你的设计，他们才会更有兴趣和更有安全感</strong>。最后，我还花了整整<code>2</code>天时间为<code>2.0</code>编写文档，这简直是一件不可思议的事情。</p>
<p>由于我这个时候已经开始写技术文章了，因此就在掘金上发了一篇<strong>介绍开源项目使用</strong>的文章。为了吸引眼球，我还特意取了一个很唬人的标题《spring-boot项目下最优雅的http客户端工具，用它就够了！》。没想到一下子就火了，马上就上了当天的热门推荐，还给我带来了<code>30</code>多个<code>star</code>。这对于平时都是“小透明”的我来说，真的是出乎意料。后来，有很多技术公众号也转载了我的开源项目，比如<code>程序员DD</code>、<code>HelloGithub</code>、<code>Java知音</code>、<code>SpringForAll社区</code>等等。截止到12月12日为止，整个项目在<code>github</code>上已经收获了差不多<code>400</code>个<code>star</code>。</p>
<h2 id="收获"><a href="#收获" class="headerlink" title="收获"></a>收获</h2><p><strong>对我而言，做完整个开源项目，除了在技术上有更多的成长以外，更重要的是收获了自信</strong>。在日常工作中，我不会畏惧更复杂的业务，同时也更想在技术上做出更多的成绩。最近重听了罗胖“2019跨年演讲”，对里面有两个词语印象深刻，一个是“我辈中人”，另一个是“做事的人“。“我辈中人”是一种自信与自豪，“做事的人“是一种脚踏实地的态度。2020即将过去，2021马上到来，继续加油！</p>
<p><a href="https://juejin.cn/post/6901125532729999374" target="_blank" rel="noopener">掘金年度征文 | 2020 与我的技术之路 征文活动正在进行中……</a></p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>纪念第一个百星开源项目 | 做难而正确的事情</title>
    <url>/posts/2770887498/</url>
    <content><![CDATA[<p>最近个人的开源项目<a href="https://github.com/LianjiaTech/retrofit-spring-boot-starter" target="_blank" rel="noopener">retrofit-spring-boot-starter</a>突破一百star了，我非常地开心。也许对于各位技术大佬来说，一百star完全微不足道，但对于还是“铁憨憨”的我来说，真的很不容易。乘着现在印象比较深刻，详细总结一下整个过程。</p>
<a id="more"></a>
<p><img data-src="https://chentianming11.github.io/images/retrofit/baixing.png" alt=""><br><strong>star数量在整个<code>lianjiatech</code>仓库排名第四，Java项目排第二</strong>。具体可以查看<a href="https://github.com/LianjiaTech" target="_blank" rel="noopener">https://github.com/LianjiaTech</a>。</p>
<h2 id="我有代码强迫症"><a href="#我有代码强迫症" class="headerlink" title="我有代码强迫症"></a>我有代码强迫症</h2><p>相信很多小伙伴跟我一样，对代码都有一定的“强迫症”。碰到实现上不够好或者使用上不够方便的代码，总想好好封装一下。<strong>这样不仅能锻炼自己的抽象设计能力，更能显著地提升研发效率，一举两得</strong>。时间回到2019年4月份，当时我们系统是一个<code>spring-boot</code>框架项目，项目中存在大量的<code>http</code>接口调用，但是调用的方式都是<strong>直接在业务方法里面使用类似<code>HttpUtil</code>发起的</strong>。这种实现方式，<strong>不仅丧失了框架层面灵活扩展的可能性，更是完全背离了面向对象的设计原则</strong>。作为一向有代码强迫症的我来说，忍不住就想对它下手了。</p>
<p>当然，光有想法是不够的，更重要的是如何实践。我当时做的第一件事情就是<strong>想清楚自己最终想达成的目标，正所谓“以终为始”，先想清楚目标，再去努力实现</strong>。这里，我联想到了<code>mybatis</code>框架可以直接通过接口执行<code>sql</code>。实际上，不管是执行<code>sql</code>还是发起<code>http</code>请求，本质上都是一种数据交互形式，<strong>因此我最终定的目标就是支持<code>spring-boot</code>项目通过接口发起<code>http</code>请求</strong>。接下来第二件事就是代码实现了，我没有上来直接撸代码，而是先去调研了一下相关的开源实现，毕竟站在巨人的肩膀上才能看得更远。经过一番调研之后，最终有2个项目在我的考虑范围之内，第一个是<code>Feign</code>，另一个是<code>Retrofit</code>，它们都支持通过接口发起<code>http</code>请求。考虑到<code>Feign</code>是<code>spring cloud</code>中消费端的调用框架，而我们的项目当时并不是<code>spring cloud</code>项目，由于不想引入<code>spring cloud</code>相关依赖，因此放弃了<code>Feign</code>。<strong>而<code>Retrofit</code>是基于<code>okhttp</code>封装的<code>http</code>客户端工具，使用同样非常广泛，因此最终选用了<code>Retrofit</code></strong>。</p>
<p>理想很丰满，现实很骨感。<code>retrofit</code>官方并没有提供与<code>spring-boot</code>项目快速整合的<code>starter</code>，这使得我不得不自己将其与<code>spring-boot</code>项目进行整合。实际上，我做的最初版就是做了一个整合，并且也达到过基本可用的状态。如果故事止步于此，<strong>这件事我也就做到了勉强60分甚至是不及格的水准</strong>。<strong>对代码不将就，追求极致才是我们该有的态度</strong>，因此我萌生了一个更加大胆的想法，<strong>做一个开源项目，剥离业务代码，实现更加完整更加优雅的封装</strong>。</p>
<h2 id="开源项目是一件很酷的事"><a href="#开源项目是一件很酷的事" class="headerlink" title="开源项目是一件很酷的事"></a>开源项目是一件很酷的事</h2><p><strong>在每一个程序猿心中，拥有一个开源项目是一件很酷的事</strong>，我当时想的就是把这件事做成。但是真正要动手去做的时候才发现，事情比想象中要复杂的多。因为开源项目最终是要给其他人用的，所以我<strong>对自己的代码设计和质量都有更加严格的要求</strong>。而当时不得不承认的一个事实是，我对相关框架源码的理解远远不够，换句话说就是我还不具备写一个开源项目的能力。这个时候，我要做的事情就是先死磕相关源码。经过3个多月的时间，我终于把<code>retrofit</code>、<code>spring</code>和<code>mybatis</code>框架的核心源码全部理解了一遍。看过源码的同学应该都知道，<strong>看源码的过程多少带有一些“煎熬”，但是认真啃完之后收获也会很大</strong>。</p>
<p>准备工作完成之后，就开始正式进入代码设计和实现了。此时，之前啃源码的效果就明显体现出来了，<strong>我在写代码的时候会自然而然地联想到开源框架的优秀实现，然后借鉴过来</strong>。这是一种很抽象的感觉，相信啃过源码的同学都有所体会。就这样，编码大概又花了2个月的时间，整个过程我都处在一个很兴奋的状态，记得那会睡觉的时候都在想怎么撸代码。由于这些工作都是业余时间进行的，因此这大半年时间里面，<strong>我的业余生活明显变得非常充实，现在回想起来，确实很累但很有收获</strong>。在此期间，我刚好也在做<code>cms组件化框架</code>的设计和实现，此时对<code>spring</code>框架的深入理解给了我非常大的帮助。到目前为止，<code>cms</code>已经是交易助手最复杂的业务，复杂度比交易助手其它所有业务加起来还要高，而<code>cms组件化框架</code>完美支持了相关业务的高效产出！</p>
<p>当一切准备就绪，接下来就是接受实际考验的时候了，我们当时替换了交易助手2个<code>Java</code>项目的<code>http</code>调用，并且通过自测就直接上线了，上线之后效果很好，没有出现任何异常。后来正式申请项目开源，整个过程比较漫长，大概花了4个月的时间，终于在2020年4月份审核通过。我记得当时刚好是清明节，<strong>我在<code>github</code>上正式发布了自己首个开源项目</strong>。不知不觉完成了目标，甚是欣慰。</p>
<h2 id="突破百星"><a href="#突破百星" class="headerlink" title="突破百星"></a>突破百星</h2><p>在接下来的2个月里面，我主要是做了一些功能上的迭代优化，<code>github</code>上的<code>star</code>数量依然少的可怜。在6月份的时候，我准备写<code>2.0</code>版本了。之所以要这么快写<code>2.0</code>版本，不是因为我们<code>1.0</code>写的有多烂，而是因为这段时间，我思想上出现了一些转变。<strong>之前写<code>1.0</code>的时候，我完全站在自己的视角去想项目应该支持哪些功能，兼容哪些框架，这诚然是我应该考虑的问题，但是好像偏离了方向，偏离了实际</strong>。我把实现做的复杂，仅仅是为了支持可能并不存在的需求。因此，<strong>在<code>2.0</code>的设计上，我做了大量简化，仅保留最重要最核心的功能，我觉得只有用户一下就能看懂你的设计，他们才会更有兴趣和更有安全感</strong>。最后，我还花了整整<code>2</code>天时间为<code>2.0</code>编写文档，这简直是一件不可思议的事情。</p>
<p>由于我这个时候已经开始写技术文章了，因此就在掘金上发了一篇<strong>介绍开源项目使用</strong>的文章。为了吸引眼球，我还特意取了一个很唬人的标题《spring-boot项目下最优雅的http客户端工具，用它就够了！》。没想到一下子就火了，马上就上了当天的热门推荐，还给我带来了<code>30</code>多个<code>star</code>。这对于平时都是“小透明”的我来说，真的是出乎意料。本来以为这件事两天就过去了，但是<code>github</code>上的<code>star</code>一直都在缓慢上涨，因此我特意使用搜索引擎查了一下，发现很多平台都有转载的文章出现，这一切也算合理了。直到<code>8</code>月<code>11</code>号，<code>github</code>上的<code>star</code>一早上就涨了<code>11</code>个，这对于我来说太反常了，<strong>后来才发现技术公众号大V<code>@程序员DD</code>(永辉云创架构师，《Spring Cloud微服务实战》作者，SpringCloud中文社区创始人，Spring4All社区联合发起人)和<code>@Java知音</code>转载了文章</strong>。不少网友在评论里面表示了支持和认可，当然也有一些质疑的声音，这里很感谢<code>@程序员DD</code>对我说的话，<strong>“没有最好，只有最合适，用心了！”</strong>，这也坚定了我持续进行迭代优化的信心。三天之后，<strong>开源项目顺利突破百星</strong>，为了庆祝，直属leader培麻麻还请全组的研发吃了顿饭。</p>
<table>
<thead>
<tr>
<th align="left"><img data-src="https://chentianming11.github.io/images/retrofit/chengxuyuandd.png" alt=""></th>
<th align="left"><img data-src="https://chentianming11.github.io/images/retrofit/javazhiyin.png" alt=""></th>
</tr>
</thead>
</table>
<p><img data-src="https://chentianming11.github.io/images/retrofit/pinglun.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>我其实只是做了一件很小的事情，唯一的区别是追求极致地去做好这件事情</strong>。在整个过程中，很感谢培麻麻的支持与鼓励，同时也为贝壳这种对技术包容和支持的技术氛围点赞。有时候我会想，如果当时做到60分就停止了，也许我不需要付出这么大的心力，但也不可能有这么大的成长。<strong>如果我们做的每件事，都只追求60分就行，那么即使做再多的事情，我们依然只有60分的水平</strong>。相反，<strong>如果我们做每件事的时候都追求做精做细，虽然会更累更难，但自身的能力也会得到锤炼和快速提升</strong>。<strong>正如<code>Stanley</code>所言，坚持长期主义，做难而正确的事情</strong>，写开源项目这件事，正是如此！</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>重新理解软件设计六大原则</title>
    <url>/posts/263077743/</url>
    <content><![CDATA[<p>软件设计六大原则包括：单一职责原则、里氏替换原则、依赖倒置原则、接口隔离原则、迪米特法则和开闭原则。</p>
<a id="more"></a>

<blockquote>
<p>本文主要内容参考自《设计模式之禅》</p>
</blockquote>
<h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><h3 id="单一职责原则定义"><a href="#单一职责原则定义" class="headerlink" title="单一职责原则定义"></a>单一职责原则定义</h3><p>单一职责原则的英文名称是<code>Single Responsibility Principle</code>，简称是<code>SRP</code>。单一职责原则的定义是：<strong>应该有且仅有一个原因引起类的变更</strong>。</p>
<p>我们以用户管理为例进行说明，包含修改用户的信息、增加机构、增加角色等，用户有这么多的信息和行为要维护，我们就把这些写到一个用户管理接口中。类图如下：<br><img data-src="https://chentianming11.github.io/images/design/IUserInfo.jpg" alt="IUserInfo"></p>
<p>相信大家都看的出来，这个接口设计有问题，用户属性和用户行为没有分开，违背了单一职责设计原则。应该把用户的信息抽取成一个BO（Business Object，业务对象），把行为抽取成一个Biz（Business Logic，业务逻辑）。修改后的类图如下：<br><img data-src="https://chentianming11.github.io/images/design/IUserInfo_v2.jpg" alt="IUserInfo_v2"></p>
<p>重新拆封成两个接口，<code>IUserBO</code>负责用户的属性，简单地说，<code>IUserBO</code>的职责就是收集和反馈用户的属性信息；<code>IUserBiz</code>负责用户的行为，完成用户信息的维护和变更。我们现在是面向接口编程，所以产生了这个<code>UserInfo</code>对象之后，当然可以把它当<code>IUserBO</code>接口使用。也可以当<code>IUserBiz</code>接口使用，这要看你在什么地方使用了。要获得用户信息，就当是<code>IUserBO</code>的实现类；要是希望维护用户的信息，就把它当作<code>IUserBiz</code>的实现类就成了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">IUserInfo userInfo = <span class="keyword">new</span> UserInfo();</span><br><span class="line"><span class="comment">//我要赋值了，我就认为它是一个纯粹的BO</span></span><br><span class="line">IUserBO userBO = (IUserBO)userInfo;</span><br><span class="line">userBO.setPassword(<span class="string">"abc"</span>);</span><br><span class="line"><span class="comment">//我要执行动作了，我就认为是一个业务逻辑类</span></span><br><span class="line">IUserBiz userBiz = (IUserBiz)userInfo;</span><br><span class="line">userBiz.deleteUser();</span><br></pre></td></tr></table></figure>

<p>上面的实现虽然能够解决问题，但是在实际的使用中，我们更倾向于使用两个不同的类或接口：一个是<code>IUserBO</code>，一个是<code>IUserBiz</code>。类图如下：<br><img data-src="https://chentianming11.github.io/images/design/IUserInfo_v3.jpg" alt="IUserInfo_v3"></p>
<p>单一职责原则的优点如下：</p>
<ul>
<li>类的复杂性降低。实现什么职责都有清晰明确的定义；</li>
<li>可读性提高。复杂性降低，那当然可读性提高了；</li>
<li>可维护性提高。可读性提高，那当然更容易维护了；</li>
<li>变更引起的风险降低。变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</li>
</ul>
<h3 id="单一职责原则最佳实践"><a href="#单一职责原则最佳实践" class="headerlink" title="单一职责原则最佳实践"></a>单一职责原则最佳实践</h3><p><strong>单一职责适用于接口、类，同时也适用于方法</strong>。一个方法尽可能做一件事情，比如一个方法修改用户密码，不要把这个方法放到“修改用户信息”方法中，这个方法的颗粒度很粗，比如下图所示的方法。<br><img data-src="https://chentianming11.github.io/images/design/IUserManager.jpg" alt="IUserManager"></p>
<p>在<code>IUserManager</code>中定义了一个方法<code>changeUser</code>，根据传递的类型不同，把可变长度参数<code>changeOptions</code>修改到<code>userBO</code>这个对象上，并调用持久层的方法保存到数据库中。<br>更好的实现如下图所示，如果要修改用户名称，就调用<code>changeUserName</code>方法；要修改家庭地址，就调用<code>changeHomeAddress</code>方法；要修改单位电话，就调用<code>changeOfficeTel</code>方法。每个方法的职责非常清晰明确，不仅开发简单，而且日后的维护也非常容易，大家可以逐渐养成这样的习惯。<br><img data-src="https://chentianming11.github.io/images/design/IUserManager_v2.jpg" alt="IUserManager_v2"></p>
<p>虽然单一职责说起来比较简单，但是<strong>在工程实践中往往综合考虑项目工期、成本、人员技术水平等因素，这就导致了类设计很难严格遵守单一职责原则</strong>。因此，<strong>对于单一职责原则，建议是接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化</strong>。</p>
<h2 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h2><h3 id="里氏替换原则定义"><a href="#里氏替换原则定义" class="headerlink" title="里氏替换原则定义"></a>里氏替换原则定义</h3><p>在面向对象的语言中，继承是必不可少的、非常优秀的语言机制，它有如下优点：</p>
<ul>
<li>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；</li>
<li>提高代码的重用性；</li>
<li>子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；</li>
<li>提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的扩展接口都是通过继承父类来完成的；</li>
<li>提高产品或项目的开放性。</li>
</ul>
<p>有有点肯定也有缺点，继承的缺点如下：</p>
<ul>
<li>继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；</li>
<li>降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；</li>
<li>增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构</li>
</ul>
<p>从整体上来看，继承利大于弊，怎么才能让“利”的因素发挥最大的作用，同时减少“弊”带来的麻烦呢？解决方案是引入里氏替换原则（Liskov Substitution Principle，LSP）。简单来讲，里氏替换原则含义如下：<br><strong>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类</strong>。</p>
<h3 id="里氏替换原则四层含义"><a href="#里氏替换原则四层含义" class="headerlink" title="里氏替换原则四层含义"></a>里氏替换原则四层含义</h3><p><strong>里氏替换原则为良好的继承定义了一个规范，一句简单的定义包含了4层含义</strong>。</p>
<ol>
<li><p><strong>子类必须完全实现父类的方法</strong><br> 我们在做系统设计时，经常会定义一个接口或抽象类，然后编码实现，调用类则直接传入接口或抽象类，其实这里已经使用了里氏替换原则。</p>
</li>
<li><p><strong>子类可以有自己的个性</strong><br>子类当然可以有自己的行为和外观了，也就是方法和属性，那这里为什么要再提呢？是因为里氏替换原则可以正着用，但是不能反过来用。在子类出现的地方，父类未必就可以胜任。</p>
</li>
<li><p><strong>覆盖或实现父类的方法时输入参数可以被放大</strong><br>这个比较难理解，我们来看一个例子，我们先定义一个Father类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;           </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">doSomething</span><span class="params">(HashMap map)</span></span>&#123;             </span><br><span class="line">        System.out.println(<span class="string">"父类被执行..."</span>);                 </span><br><span class="line">        <span class="keyword">return</span> map.values();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类非常简单，就是把HashMap转换为Collection集合类型，然后再定义一个子类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;     </span><br><span class="line">    <span class="comment">//放大输入参数类型     </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">doSomething</span><span class="params">(Map map)</span></span>&#123;             </span><br><span class="line">        System.out.println(<span class="string">"子类被执行..."</span>);             </span><br><span class="line">        <span class="keyword">return</span> map.values();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 请注意，子类与父类的方法名相同，但又不是覆写（Override）父类的方法，而是重载（Overload）！父类和子类都已经声明了，场景类的调用如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoker</span><span class="params">()</span></span>&#123;             </span><br><span class="line">        <span class="comment">//父类存在的地方，子类就应该能够存在             </span></span><br><span class="line">        Father f = <span class="keyword">new</span> Father();             </span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();             </span><br><span class="line">        f.doSomething(map);     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        invoker();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 代码运行后的结果是：<code>父类被执行...</code>。</p>
<p> 根据里氏替换原则，父类出现的地方子类就可以出现。将上面的类型替换为子类执行：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoker</span><span class="params">()</span></span>&#123;             </span><br><span class="line">        <span class="comment">//父类存在的地方，子类就应该能够存在             </span></span><br><span class="line">        Son f =<span class="keyword">new</span> Son();           </span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();             </span><br><span class="line">        f.doSomething(map);     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; </span><br><span class="line">        invoker();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 运行结果还是一样。父类方法的输入参数是<code>HashMap</code>类型，子类的输入参数是<code>Map</code>类型，也就是说<strong>子类的输入参数类型的范围扩大了，子类代替父类传递到调用者中，子类的方法永远都不会被执行</strong>。这是正确的，如果你想让子类的方法运行，就必须覆写父类的方法。<br> 我们再反过来想一下，如果<code>Father</code>类的输入参数类型宽于子类的输入参数类型，会出现什么问题呢？</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">doSomething</span><span class="params">(Map map)</span></span>&#123;             </span><br><span class="line">        System.out.println(<span class="string">"父类被执行..."</span>);             </span><br><span class="line">        <span class="keyword">return</span> map.values();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 把父类的前置条件修改为<code>Map</code>类型，我们再修改一下子类方法的输入参数，相对父类缩小输入参数的类型范围。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;     </span><br><span class="line">    <span class="comment">//缩小输入参数范围     </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection <span class="title">doSomething</span><span class="params">(HashMap map)</span></span>&#123;             </span><br><span class="line">        System.out.println(<span class="string">"子类被执行..."</span>);             </span><br><span class="line">        <span class="keyword">return</span> map.values();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 业务场景的源代码如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoker</span><span class="params">()</span></span>&#123;             </span><br><span class="line">        <span class="comment">//有父类的地方就有子类             </span></span><br><span class="line">        Father f= <span class="keyword">new</span> Father();             </span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();             </span><br><span class="line">        f.doSomething(map);     </span><br><span class="line">    &#125;       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;             </span><br><span class="line">        invoker();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 代码运行后的结果是：<code>父类被执行...</code>。那我们再把里氏替换原则引入进来会有什么问题？有父类的地方子类就可以使用，好，我们把这个<code>Client</code>类修改一下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invoker</span><span class="params">()</span></span>&#123;             </span><br><span class="line">        <span class="comment">//有父类的地方就有子类             </span></span><br><span class="line">        Son f =<span class="keyword">new</span> Son();             </span><br><span class="line">        HashMap map = <span class="keyword">new</span> HashMap();             </span><br><span class="line">        f.doSomething(map);     </span><br><span class="line">    &#125;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;             </span><br><span class="line">        invoker();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 代码运行后的结果是：<code>子类类被执行...</code>。完蛋了吧？！子类在没有覆写父类的方法的前提下，子类方法被执行了，这会引起业务逻辑混乱。明显违背了里氏替换原则。</p>
</li>
<li><p><strong>覆写或实现父类的方法时输出结果可以被缩小</strong><br><strong>父类的一个方法的返回值是一个类型<code>T</code>，子类的相同方法（重载或覆写）的返回值为<code>S</code>，那么里氏替换原则就要求<code>S</code>必须小于等于<code>T</code></strong>，也就是说，要么S和T是同一个类型，要么S是T的子类。分两种情况，如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值<code>S</code>小于等于<code>T</code>，这是覆写的要求，子类覆写父类的方法，天经地义。如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的。</p>
</li>
</ol>
<p><strong>采用里氏替换原则的目的就是增强程序的健壮性，版本升级时也可以保持非常好的兼容性</strong>。即使增加子类，原有的子类还可以继续运行。在实际项目中，每个子类对应不同的业务含义，使用父类作为参数，传递不同的子类完成不同的业务逻辑，非常完美！</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><h3 id="依赖倒置原则的定义"><a href="#依赖倒置原则的定义" class="headerlink" title="依赖倒置原则的定义"></a>依赖倒置原则的定义</h3><p>依赖倒置原则含义如下：</p>
<ul>
<li>高层模块不应该依赖低层模块，两者都应该依赖其抽象；</li>
<li>抽象不应该依赖细节；</li>
<li>细节应该依赖抽象</li>
</ul>
<p>高层模块和低层模块容易理解，每一个逻辑的实现都是由原子逻辑组成的，不可分割的原子逻辑就是低层模块，原子逻辑的再组装就是高层模块。依赖倒置原则在Java语言中的表现就是：</p>
<ul>
<li>模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</li>
<li>接口或抽象类不依赖于实现类；</li>
<li>实现类依赖接口或抽象类</li>
</ul>
<p>采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。</p>
<h3 id="依赖的三种写法"><a href="#依赖的三种写法" class="headerlink" title="依赖的三种写法"></a>依赖的三种写法</h3><p>依赖是可以传递的，A对象依赖B对象，B又依赖C，C又依赖D……生生不息，依赖不止，记住一点：只要做到抽象依赖，即使是多层的依赖传递也无所畏惧！对象的依赖关系有三种方式来传递，如下所示：</p>
<ol>
<li><p><strong>构造函数传递依赖对象</strong><br>在类中通过构造函数声明依赖对象，按照依赖注入的说法，这种方式叫做构造函数注入。</p>
</li>
<li><p><strong><code>Setter</code>方法传递依赖对象</strong><br> 在抽象中设置Setter方法声明依赖关系，依照依赖注入的说法，这是<code>Setter</code>依赖注入。</p>
</li>
<li><p><strong>接口声明依赖对象</strong><br> 在接口的方法中声明依赖对象，该方法也叫做接口注入。</p>
</li>
</ol>
<h3 id="依赖倒置原则最佳实践"><a href="#依赖倒置原则最佳实践" class="headerlink" title="依赖倒置原则最佳实践"></a>依赖倒置原则最佳实践</h3><p>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，我们怎么在项目中使用这个规则呢？只要遵循以下的几个规则就可以：</p>
<ul>
<li><strong>每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备</strong><br>  这是依赖倒置的基本要求，接口和抽象类都是属于抽象的，有了抽象才可能依赖倒置。</li>
<li><strong>变量的表面类型尽量是接口或者是抽象类</strong></li>
<li><strong>任何类都不应该从具体类派生</strong></li>
<li><strong>尽量不要覆写基类的方法</strong><br>  如果基类是一个抽象类，而且这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。</li>
<li><strong>结合里氏替换原则使用</strong><br>   接口负责定义<code>public</code>属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。</li>
</ul>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><h3 id="接口隔离原则的定义"><a href="#接口隔离原则的定义" class="headerlink" title="接口隔离原则的定义"></a>接口隔离原则的定义</h3><p>接口隔离原则定义如下：</p>
<ul>
<li><strong>客户端不应该依赖它不需要的接口</strong></li>
<li><strong>类间的依赖关系应该建立在最小的接口上</strong></li>
</ul>
<p>我们把这两个定义剖析一下，先说第一种定义：“客户端不应该依赖它不需要的接口”，那依赖什么？依赖它需要的接口，客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，那就需要对接口进行细化，保证其纯洁性；再看第二种定义：“类间的依赖关系应该建立在最小的接口上”，它要求是最小的接口，也是要求接口细化，接口纯洁，与第一个定义如出一辙，只是一个事物的两种不同描述。</p>
<p>我们可以把这两个定义概括为一句话：<strong>建立单一接口，不要建立臃肿庞大的接口</strong>。再通俗一点讲：接口尽量细化，同时接口中的方法尽量少。看到这里大家有可能要疑惑了，这与单一职责原则不是相同的吗？错，<strong>接口隔离原则与单一职责的审视角度是不相同的，单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分，而接口隔离原则要求接口的方法尽量少</strong>。例如一个接口的职责可能包含10个方法，这10个方法都放在一个接口中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约束“不使用的方法不要访问”，按照单一职责原则是允许的，按照接口隔离原则是不允许的，因为它要求“尽量使用多个专门的接口”。专门的接口指什么？就是指提供给每个模块的都应该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容纳所有的客户端访问。</p>
<h3 id="保证接口的纯洁性"><a href="#保证接口的纯洁性" class="headerlink" title="保证接口的纯洁性"></a>保证接口的纯洁性</h3><p>接口隔离原则是对接口进行规范约束，其包含以下4层含义：</p>
<ol>
<li><p><strong>接口要尽量小</strong><br>这是接口隔离原则的核心定义，不出现臃肿的接口（Fat Interface），但是“小”是有限度的，首先就是不能违反单一职责原则。<strong>根据接口隔离原则拆分接口时，首先必须满足单一职责原则</strong>。</p>
</li>
<li><p><strong>接口要高内聚</strong><br>什么是高内聚？高内聚就是提高接口、类、模块的处理能力，减少对外的交互。<strong>具体到接口隔离原则就是，要求在接口中尽量少公布public方法，接口是对外的承诺，承诺越少对系统的开发越有利，变更的风险也就越少，同时也有利于降低成本</strong>。</p>
</li>
<li><p><strong>定制服务</strong><br>一个系统或系统内的模块之间必然会有耦合，有耦合就要有相互访问的接口。我们设计时就需要为各个访问者（即客户端）定制服务，什么是定制服务？定制服务就是单独为一个个体提供优良的服务。<strong>我们在做系统设计时也需要考虑对系统之间或模块之间的接口采用定制服务，采用定制服务就必然有一个要求：只提供访问者需要的方法</strong>。</p>
</li>
<li><p><strong>接口设计是有限度的</strong><br>接口的设计粒度越小，系统越灵活，这是不争的事实。但是，灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低，这不是一个项目或产品所期望看到的，所以接口设计一定要注意适度，这个“度”如何来判断呢？根据经验和常识判断，没有一个固化或可测量的标准。</p>
</li>
</ol>
<h3 id="接口隔离原则最佳实践"><a href="#接口隔离原则最佳实践" class="headerlink" title="接口隔离原则最佳实践"></a>接口隔离原则最佳实践</h3><p>接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用原子接口或原子类来组装。但是，这个原子该怎么划分是设计模式中的一大难题，在实践中可以根据以下几个规则来衡量：</p>
<ul>
<li>一个接口只服务于一个子模块或业务逻辑；</li>
<li>通过业务逻辑压缩接口中的<code>public</code>方法，接口时常去回顾，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；</li>
<li>已经被污染了的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；</li>
<li>了解环境，拒绝盲从。每个项目或产品都有特定的环境因素，别看到大师是这样做的你就照抄。</li>
</ul>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><h3 id="迪米特法则的定义"><a href="#迪米特法则的定义" class="headerlink" title="迪米特法则的定义"></a>迪米特法则的定义</h3><p>迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge Principle，LKP）。<strong>一个对象应该对其他对象有最少的了解</strong>。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public方法，我就调用这么多，其他的我一概不关心。</p>
<h3 id="迪米特法则三层含义"><a href="#迪米特法则三层含义" class="headerlink" title="迪米特法则三层含义"></a>迪米特法则三层含义</h3><p>迪米特法则对类的低耦合提出了明确的要求，其包含以下4层含义。</p>
<ol>
<li><p><strong>只和朋友交流</strong><br> 迪米特法则还有一个英文解释是：Only talk to your immediate friends（只与直接的朋友交流）。什么叫做直接的朋友呢？每个对象都必然会与其他对象有耦合关系，两个对象之间的耦合就成为朋友关系，这种关系的类型有很多，例如组合、聚合、依赖等。<strong>朋友类的定义是这样的：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类</strong>。一个类只和朋友交流，不与陌生类交流，不要出现getA().getB().getC().getD()这种情况。</p>
</li>
<li><p><strong>朋友间也是有距离</strong><br> 对朋友关系描述最贴切的故事就是：两只刺猬取暖，太远取不到暖，太近刺伤了对方，必须保持一个既能取暖又不刺伤对方的距离。迪米特法则就是对这个距离进行描述，即使是朋友类之间也不能无话不说，无所不知。<br> 我们在安装软件的时候，经常会有一个导向动作，第一步是确认是否安装，第二步确认<code>License</code>，再然后选择安装目录……这是一个典型的顺序执行动作，<strong>具体到程序中就是：调用一个或多个类，先执行第一个方法，然后是第二个方法，根据返回结果再来看是否可以调用第三个方法，或者第四个方法，等等</strong>，其类图如下所示：<br> <img data-src="https://chentianming11.github.io/images/design/InstallSoftware.jpg" alt="InstallSoftware"><br> 在Wizard类中分别定义了三个步骤方法，每个步骤中都有相关的业务逻辑完成指定的任务。软件安装InstallSoftware类代码如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallSoftware</span> </span>&#123;          </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installWizard</span><span class="params">(Wizard wizard)</span></span>&#123;             </span><br><span class="line">        <span class="keyword">int</span> first = wizard.first();               </span><br><span class="line">        <span class="comment">//根据first返回的结果，看是否需要执行second             </span></span><br><span class="line">        <span class="keyword">if</span>(first&gt;<span class="number">50</span>)&#123;                      </span><br><span class="line">            <span class="keyword">int</span> second = wizard.second();                      </span><br><span class="line">            <span class="keyword">if</span>(second&gt;<span class="number">50</span>)&#123;                                </span><br><span class="line">                <span class="keyword">int</span> third = wizard.third();                                </span><br><span class="line">                <span class="keyword">if</span>(third &gt;<span class="number">50</span>)&#123;                                          </span><br><span class="line">                    wizard.first();                      </span><br><span class="line">                &#125;                 </span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;                </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <code>Wizard</code>类把太多的方法暴露给<code>InstallSoftware</code>类，两者的朋友关系太亲密了，耦合关系变得异常牢固。如果要将<code>Wizard</code>类中的<code>first</code>方法返回值的类型由int改为<code>boolean</code>，就需要修改<code>InstallSoftware</code>类，从而把修改变更的风险扩散开了。因此，这样的耦合是极度不合适的，我们需要对设计进行重构，重构后的类图如下所示。<br> <img data-src="https://chentianming11.github.io/images/design/InstallSoftware_v2.jpg" alt="InstallSoftware_v2"><br> 将三个步骤的访问权限修改为<code>private</code>，同时把<code>InstallSoftware</code>中的方法<code>installWizad</code>移动到<code>Wizard</code>方法中。通过这样的重构后，<code>Wizard</code>类就只对外公布了一个<code>public</code>方法，即使要修改<code>first</code>方法的返回值，影响的也仅仅只是<code>Wizard</code>本身，其他类不受影响，这显示了类的高内聚特性。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InstallSoftware</span> </span>&#123;     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">installWizard</span><span class="params">(Wizard wizard)</span></span>&#123;             </span><br><span class="line">        <span class="comment">//直接调用             </span></span><br><span class="line">        wizard.installWizard();     </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 一个类公开的<code>public</code>属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，<strong>为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少<code>public</code>方法和属性，是否可以修改为<code>private</code>、<code>package-private</code>（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、<code>protected</code>等访问权限，是否可以加上<code>final</code>关键字等</strong>。</p>
</li>
<li><p><strong>是自己的就是自己的</strong><br> 在实际应用中经常会出现这样一个方法：放在本类中也可以，放在其他类中也没有错，那怎么去衡量呢？你可以坚持这样一个原则：<strong>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</strong>。</p>
</li>
</ol>
<h3 id="迪米特法则最佳实践"><a href="#迪米特法则最佳实践" class="headerlink" title="迪米特法则最佳实践"></a>迪米特法则最佳实践</h3><p>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合了以后，类的复用率才可以提高。其要求的结果就是产生了大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。读者在采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚低耦合。</p>
<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><h3 id="开闭原则的定义"><a href="#开闭原则的定义" class="headerlink" title="开闭原则的定义"></a>开闭原则的定义</h3><p>开闭原则的定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。那什么又是软件实体呢？软件实体包括以下几个部分：</p>
<ul>
<li>项目或软件产品中按照一定的逻辑规则划分的模块。</li>
<li>抽象和类。</li>
<li>方法</li>
</ul>
<h3 id="开闭原则最佳实践"><a href="#开闭原则最佳实践" class="headerlink" title="开闭原则最佳实践"></a>开闭原则最佳实践</h3><p>开闭原则是一个非常虚的原则，前面5个原则是对开闭原则的具体解释，但是开闭原则并不局限于这么多，它“虚”得没有边界。可以通过以下4个方面来使用开闭原则：</p>
<ol>
<li><p><strong>抽象约束</strong><br> 抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：</p>
<ol>
<li><strong>通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法</strong>；</li>
<li><strong>参数类型、引用对象尽量使用接口或者抽象类，而不是实现类</strong>；</li>
<li><strong>抽象层尽量保持稳定，一旦确定即不允许修改</strong>。</li>
</ol>
</li>
<li><p><strong>元数据（metadata）控制模块行为</strong><br>编程是一个很苦很累的活，那怎么才能减轻我们的压力呢？<strong>答案是尽量使用元数据来控制程序的行为，减少重复开发</strong>。什么是元数据？用来描述环境和数据的数据，通俗地说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。</p>
</li>
<li><p><strong>制定项目章程</strong><br> 在一个团队中，建立项目章程是非常重要的，因为章程中指定了所有人员都必须遵守的约定，对项目来说，约定优于配置。</p>
</li>
<li><p><strong>封装变化</strong><br>对变化的封装包含两层含义：第一，<strong>将相同的变化封装到一个接口或抽象类中</strong>；第二，<strong>将不同的变化封装到不同的接口或抽象类中</strong>，不应该有两个不同的变化出现在同一个接口或抽象类中。封装变化，也就是受保护的变化（protected variations），找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口，准确地讲是封装可能发生的变化，一旦预测到或“第六感”发觉有变化，就可以进行封装。</p>
</li>
</ol>
<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>七、模板方法模式</title>
    <url>/posts/2785039244/</url>
    <content><![CDATA[<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以冲泡咖啡喝茶为例：<br>咖啡冲泡法：</p>
<a id="more"></a>
<ol>
<li>把水煮沸</li>
<li>用沸水冲泡咖啡</li>
<li>把咖啡倒进杯子</li>
<li>加糖加牛奶</li>
</ol>
<p>茶冲泡法：</p>
<ol>
<li>把水煮沸</li>
<li>用沸水浸泡茶叶</li>
<li>把茶倒进杯子</li>
<li>加柠檬</li>
</ol>
<p>茶和咖啡的冲泡方法非常相似。</p>
<p>Coffee.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 把水煮沸</span></span><br><span class="line">        boilWater();</span><br><span class="line">        <span class="comment">// 用沸水冲泡咖啡</span></span><br><span class="line">        brewCoffeeGrinds();</span><br><span class="line">        <span class="comment">// 把咖啡倒进杯子</span></span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="comment">// 加糖加牛奶</span></span><br><span class="line">        addSugarAndMilk();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addSugarAndMilk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加糖加牛奶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把咖啡倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">brewCoffeeGrinds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用沸水冲泡咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把水煮沸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tea.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 把水煮沸</span></span><br><span class="line">        boilWater();</span><br><span class="line">        <span class="comment">// 浸泡茶叶</span></span><br><span class="line">        stepTeaBag();</span><br><span class="line">        <span class="comment">// 把茶倒进杯子</span></span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="comment">// 加柠檬</span></span><br><span class="line">        addLemon();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加柠檬"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把茶倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stepTeaBag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"浸泡茶叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把水煮沸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>可以看到上面的Coffee和Tea中有重复代码，都含有prepareRecipe()、boilWater()和pourInCup()方法，并且boilWater()和pourInCup()实现完全一样，prepareRecipe()在两者中的实现有所不同。因此，我们可能想到的抽象设计可能是如下：<br><img data-src="https://chentianming11.github.io/images/design/template/30417619.png" alt="30417619"></p>
<p>进一步封装冲泡法，茶和咖啡的冲泡法都采用了相同的算法。</p>
<ul>
<li>把水煮沸</li>
<li>用热水泡咖啡或茶</li>
<li>把饮料倒进杯子</li>
<li>在饮料内加入适当的调料<br>因此，我们可以将prepareRecipe()也进行抽象。</li>
</ul>
<p>咖啡因饮料基类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CaffeineBeverage</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 冲泡方法</span></span><br><span class="line"><span class="comment">     * 模板算法，定义为final，不可被覆盖</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">prepareRecipe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 把水煮沸</span></span><br><span class="line">        boilWater();</span><br><span class="line">        <span class="comment">// 用沸水冲泡</span></span><br><span class="line">        brew();</span><br><span class="line">        <span class="comment">// 倒进杯子</span></span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="comment">// 加调料</span></span><br><span class="line">        addCondiments();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把水煮沸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把咖啡倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用沸水冲泡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入调料</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Coffee.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">CaffeineBeverage</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用沸水冲泡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用沸水冲泡咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入调料</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加糖加牛奶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tea.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">CaffeineBeverage</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用沸水冲泡</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"浸泡茶叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入调料</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addCondiments</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加柠檬"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们做了什么：<br><img data-src="https://chentianming11.github.io/images/design/template/32050358.png" alt="32050358"></p>
<h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><p>模板方法定义了一个算法的步骤，并允许子类为一个或多个步骤提供实现。</p>
<p><strong>定义</strong>：<br>模板方法模式在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法的某些步骤。<br><img data-src="https://chentianming11.github.io/images/design/template/30810299.png" alt="30810299"></p>
<h3 id="对模板方法进行挂钩"><a href="#对模板方法进行挂钩" class="headerlink" title="对模板方法进行挂钩"></a>对模板方法进行挂钩</h3><p>钩子是一种声明在抽象类中的方法，但只有空的或默认实现。钩子的存在，可以让子类有能力对算法的不同点进行挂钩。要不要挂钩，由子类自行决定。</p>
<p>钩子使用方式一：条件语句<br><img data-src="https://chentianming11.github.io/images/design/template/31491858.png" alt="31491858"></p>
<p>为了使用钩子，我们要在子类中覆盖它。在这里，钩子控制了咖啡因饮料是否执行某部分算法。说的明确一点，就是饮料中是否要加调料。</p>
<h4 id="QA"><a href="#QA" class="headerlink" title="QA"></a>QA</h4><ul>
<li><p>创建模板方法时，什么时候用抽象方法，什么时候用钩子？<br>当子类必须提供算法中某个方法或步骤的实现时，就使用抽象方法。如果这个步骤是可选的，就用钩子。</p>
</li>
<li><p>使用钩子的目的是什么？</p>
<ol>
<li>钩子可以让子类实现算法的可选部分。</li>
<li>让子类能够有机会对模板方法中某些即将发生的步骤做出反应。</li>
</ol>
</li>
</ul>
<h4 id="好莱坞原则"><a href="#好莱坞原则" class="headerlink" title="好莱坞原则"></a>好莱坞原则</h4><p><strong>别调用我们，我们会调用你。</strong><br>好莱坞原则可以给我们一种防止“依赖腐败”的方法。当高层组件依赖低层组件，低层组件又依赖高层组件，高层组件又依赖边侧组件，边侧组件又依赖低层组件时，依赖腐败就发生了。<br>在好莱坞原则下，我们允许低层组件将自己挂钩到系统上，但是高层组件会决定什么时候和怎样使用这些低层组件。换句话说，高层组件对待低层组件的方式是“别调用我，我会调用你”。</p>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>template包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>三、装饰者模式</title>
    <url>/posts/2802361869/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>有一家咖啡店,需要设计一个订单系统，一开始的饮料设计如下：</p>
<a id="more"></a>

<p><img data-src="https://chentianming11.github.io/images/design/decorator/62255575.png" alt="62255575"></p>
<p>但是，购买咖啡时，也可以加入各种调料。咖啡店会根据不同的调料收取不同的费用。因此需要对设计进行改造。<br><img data-src="https://chentianming11.github.io/images/design/decorator/62518283.png" alt="62518283"></p>
<p>一种咖啡配合任意种调料作为一种新的饮料，这简直就是<strong>类爆炸</strong>，并且非常难以维护。</p>
<p><strong>开闭原则：类应该对扩展开放，对修改关闭</strong>。</p>
<h3 id="初识装饰者模式"><a href="#初识装饰者模式" class="headerlink" title="初识装饰者模式"></a>初识装饰者模式</h3><p>在这里，我们使用不一样的做法：我们要以饮料为主体，然后运行时以调料来装饰饮料。比如说，如果顾客想要摩卡和奶泡深培咖啡，那么要做的是：</p>
<ul>
<li>拿一个深培咖啡（DarkRoast）对象。</li>
<li>以摩卡（Mocha）对象装饰它</li>
<li>以奶泡对象（Whip）装饰它</li>
<li>调用cost()方法，并依赖委托将调料的价格加上去。</li>
</ul>
<h4 id="以装饰者构造饮料订单"><a href="#以装饰者构造饮料订单" class="headerlink" title="以装饰者构造饮料订单"></a>以装饰者构造饮料订单</h4><ul>
<li><p>以DarkRoast对象开始<br><img data-src="https://chentianming11.github.io/images/design/decorator/63877539.png" alt="63877539"></p>
</li>
<li><p>顾客想要摩卡（Mocha），所以建立一个Mocha对象，并用它将DarkRoast对象包起来<br><img data-src="https://chentianming11.github.io/images/design/decorator/64043519.png" alt="64043519"></p>
</li>
<li><p>顾客想要奶泡（Whip），所以需要建立一个Whip对象，并用它将Mocha对象包起来。<br><img data-src="https://chentianming11.github.io/images/design/decorator/64178210.png" alt="64178210"></p>
</li>
<li><p>通过最外圈装饰者（Whip）的cost()就可以计算出总的价钱了。<br><img data-src="https://chentianming11.github.io/images/design/decorator/64326654.png" alt="64326654"></p>
</li>
</ul>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ol>
<li>装饰者和被装饰对象有相同的超类型。</li>
<li>可以用一个或者多个装饰者包装一个对象。</li>
<li>既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象的场合，可以用装饰过的对象代替它。</li>
<li><em>装饰者可以在所委托的被装饰者的行为前后，加上自己的行为，以达到特定的目的</em></li>
<li>对象可以在任何时候被装饰。</li>
</ol>
<h3 id="定义装饰者模式"><a href="#定义装饰者模式" class="headerlink" title="定义装饰者模式"></a>定义装饰者模式</h3><p><strong>动态地将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案</strong>。<br><img data-src="https://chentianming11.github.io/images/design/decorator/68214341.png" alt="68214341"></p>
<h3 id="装饰饮料"><a href="#装饰饮料" class="headerlink" title="装饰饮料"></a>装饰饮料</h3><p><img data-src="https://chentianming11.github.io/images/design/decorator/68693233.png" alt="68693233"></p>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>decorator包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>一、策略模式</title>
    <url>/posts/1927526001/</url>
    <content><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><h4 id="1-1-先从简单的模拟鸭子应用做起"><a href="#1-1-先从简单的模拟鸭子应用做起" class="headerlink" title="1.1 先从简单的模拟鸭子应用做起"></a>1.1 先从简单的模拟鸭子应用做起</h4><p>假设有一个模拟鸭子的游戏SimUDuck，游戏中有各种鸭子，一边游泳，一边呱呱叫。</p>
<a id="more"></a>

<p><img data-src="https://chentianming11.github.io/images/design/strategy/duck.png" alt="duck"></p>
<h4 id="1-2-现在我们得让一些鸭子能飞"><a href="#1-2-现在我们得让一些鸭子能飞" class="headerlink" title="1.2 现在我们得让一些鸭子能飞"></a>1.2 现在我们得让一些鸭子能飞</h4><ol>
<li>实现1：新增fly()<br>在抽象父类中新增fly()方法并实现, 使得所有的鸭子都具有了fly()。<br>问题：并不是所有鸭子都能飞。</li>
</ol>
<p><strong>总结：当维护的时候，为了复用而使用继承，实际效果并不好</strong></p>
<ol start="2">
<li><p>实现2：fly()空实现<br>抽象父类的fly()方法进行空实现，具体实现由子类自己去做。<br>问题: 基本上每出现一个鸭子类型，都要去检测其行为与默认实现之间的关系。可能新出现的鸭子品类的quack(), swim()和fly()等行为与父类中实现的完全不一样。<br>总结：<strong>使用继承的时候，共性抽取到父类一定要小心处理，只有绝对不变的共性才适合抽取到父类中。</strong></p>
</li>
<li><p>实现3：利用接口<br>使用接口，将不是所有鸭子都一定会存在的行为定义到各自的接口中，具体的鸭子实现该接口就好了。<br>问题：可能多中鸭子的某个行为实现是一样的，通过接口无法实现代码复用。</p>
</li>
</ol>
<p><img data-src="https://chentianming11.github.io/images/design/strategy/duck-interface.png" alt="duck-interface"></p>
<h3 id="二、把为题归零"><a href="#二、把为题归零" class="headerlink" title="二、把为题归零"></a>二、把为题归零</h3><p>现在我们知道使用继承并不能很好的解决问题，因为鸭子的行为在子类里不断变化，并且并不是所有子类都应该具有这些行为。使用Flyable、Quackable接口的方式，看似解决了问题(只有会飞的鸭子才要实现Flyable接口)。但是Java接口没有实现代码，所有继承接口无法达到代码的复用。<br><strong>设计原则：封装变化</strong><br><em>找出应用中可能需要变化的地方，把它们独立出来，不要和那些不需要变化的代码混在一起。</em></p>
<h4 id="2-1-分来变化和不变化的部分"><a href="#2-1-分来变化和不变化的部分" class="headerlink" title="2.1 分来变化和不变化的部分"></a>2.1 分来变化和不变化的部分</h4><p>我们知道Duck中的fly()和quack()会随着鸭子的不同而改变。为了要把2个行为从Duck类中分开，我们要把它们从Duck中取出来，建立一组新类代替每个行为。</p>
<p><img data-src="https://chentianming11.github.io/images/design/strategy/52663965.png" alt="52663965"></p>
<h4 id="2-2-设计鸭子的行为"><a href="#2-2-设计鸭子的行为" class="headerlink" title="2.2 设计鸭子的行为"></a>2.2 设计鸭子的行为</h4><p>从现在开始，鸭子的行为将被放到分开的类中，此类专门提供某行为接口的实现。这样，鸭子类就不需要知道行为的实现细节。</p>
<p><img data-src="https://chentianming11.github.io/images/design/strategy/53015869.png" alt="53015869"></p>
<p><strong>设计原则</strong><br><em>针对接口编程，而不是针对实现编程。</em></p>
<h4 id="2-3-实现鸭子的行为"><a href="#2-3-实现鸭子的行为" class="headerlink" title="2.3 实现鸭子的行为"></a>2.3 实现鸭子的行为</h4><p>在此，我们有2个接口，FlyBehavior和QuackBehavior，还有它们对应的类，负责实现具体的行为。</p>
<p><img data-src="https://chentianming11.github.io/images/design/strategy/53621434.png" alt="53621434"></p>
<p>优点：新增一些新的行为，不会影响到既有的行为类，也不会影响“使用”某个行为的鸭子类。</p>
<h4 id="2-4-整合鸭子的行为"><a href="#2-4-整合鸭子的行为" class="headerlink" title="2.4 整合鸭子的行为"></a>2.4 整合鸭子的行为</h4><p>关键在于，鸭子现在将飞行和呱呱叫的动作“委托”别人处理，而不是使用定义在Duck类中的呱呱叫和飞行方法。</p>
<ol>
<li><p>在Duck类中加入两个实例变量（接口类型）flyBehavior和quackBehavior。<br><img data-src="https://chentianming11.github.io/images/design/strategy/54284168.png" alt="54284168"></p>
</li>
<li><p>在Duck类中实现performFly()和performQuack()方法</p>
</li>
<li><p>在具体鸭子子类的构造方法红设定具体的flyBehavior和quackBehavior</p>
</li>
</ol>
<h4 id="2-5-封装行为的大局观"><a href="#2-5-封装行为的大局观" class="headerlink" title="2.5 封装行为的大局观"></a>2.5 封装行为的大局观</h4><p>由于鸭子的fly和quack行为是变化的，所以需要将这些行为进行分装。为了能统一管理所有同类行为，因此使用了接口。<br><img data-src="https://chentianming11.github.io/images/design/strategy/57495961.png" alt="57495961"></p>
<p><strong>设计原则</strong><br><em>多用组合，少用继承。</em><br><strong>策略模式定义了算法族，分别分装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的客户</strong></p>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>strategy包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>九、状态模式</title>
    <url>/posts/1713262675/</url>
    <content><![CDATA[<h3 id="以糖果机为例"><a href="#以糖果机为例" class="headerlink" title="以糖果机为例"></a>以糖果机为例</h3><p>我们需要使用java实现一个糖果机，糖果机状态如下所示：</p>
<a id="more"></a>
<p><img data-src="https://chentianming11.github.io/images/design/state/43259283.png" alt="43259283"></p>
<h3 id="状态机101"><a href="#状态机101" class="headerlink" title="状态机101"></a>状态机101</h3><p>使用状态机的方式实现，这里使用一个通用技巧：<br><strong>如何对对象的内的状态建模–通过创建一个实例变量来持有状态值，并在方法内书写条件代码来处理不同状态。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMachine101</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 糖果售罄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SOLD_OUT = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> NO_QUARTER = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> HAS_QUARTER = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售出糖果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> SOLD = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = SOLD_OUT;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售出糖果数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GumballMachine101</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.count = count;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            state = NO_QUARTER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 投入硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == HAS_QUARTER)&#123;</span><br><span class="line">            System.out.println(<span class="string">"你不能重复投入硬币"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == NO_QUARTER)&#123;</span><br><span class="line">            state = HAS_QUARTER;</span><br><span class="line">            System.out.println(<span class="string">"投入硬币"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SOLD_OUT)&#123;</span><br><span class="line">            System.out.println(<span class="string">"无法投入硬币，糖果已售罄"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SOLD)&#123;</span><br><span class="line">            System.out.println(<span class="string">"请等待，正在为您准备糖果"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退回硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == HAS_QUARTER)&#123;</span><br><span class="line">            System.out.println(<span class="string">"硬币已退回"</span>);</span><br><span class="line">            state = NO_QUARTER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == NO_QUARTER)&#123;</span><br><span class="line">            System.out.println(<span class="string">"无法退回,您还未投入硬币"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SOLD)&#123;</span><br><span class="line">            System.out.println(<span class="string">"无法退回，您已经转动了曲柄"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SOLD_OUT)&#123;</span><br><span class="line">            System.out.println(<span class="string">"无法退回,您还未投入硬币"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转动曲柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trunCrank</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == SOLD) &#123;</span><br><span class="line">            System.out.println(<span class="string">"不能转动2次曲柄"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == NO_QUARTER)&#123;</span><br><span class="line">            System.out.println(<span class="string">"还没投入硬币"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SOLD_OUT) &#123;</span><br><span class="line">            System.out.println(<span class="string">"糖果已售罄"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == HAS_QUARTER) &#123;</span><br><span class="line">            System.out.println(<span class="string">"转动曲柄。。。"</span>);</span><br><span class="line">            state = SOLD;</span><br><span class="line">            dispense();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发放糖果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (state == SOLD) &#123;</span><br><span class="line">            System.out.println(<span class="string">"售出糖果"</span>);</span><br><span class="line">            count--;</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"糖果卖完了"</span>);</span><br><span class="line">                state = SOLD_OUT;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                state = NO_QUARTER;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == NO_QUARTER) &#123;</span><br><span class="line">            System.out.println(<span class="string">"需要先投入硬币"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == SOLD_OUT) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有糖果可发放"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == HAS_QUARTER) &#123;</span><br><span class="line">            System.out.println(<span class="string">"没有糖果可发放"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变更请求"><a href="#变更请求" class="headerlink" title="变更请求"></a>变更请求</h3><p>我们需要在糖果机上变点花样，当曲柄转动时，有10%的概率掉下来的是两颗糖果。<br>使用一种考虑周详的方法写糖果机的代码，并不意味着这份代码容易扩展。首先，你必须加上一个新的状态，“赢家”状态。然后，你必须在每个方法中加入一个新的条件判断来处理“赢家”状态，这可就有忙的了。<br>trunCrack()尤其会变得一团乱，因为你必须加入代码来检查目前的顾客是否是赢家，然后再决定切换到赢家状态还是售出糖果转态。</p>
<h3 id="新的设计"><a href="#新的设计" class="headerlink" title="新的设计"></a>新的设计</h3><p>不要维护现有代码，我们重写它以便于将状态对象封装在各自的类中，然后在动作发生时委托给当前状态。</p>
<ul>
<li>首先，我们定义一个state接口。在这个接口中，糖果机的每个动作都有一个对应的方法。</li>
<li>然后为机器中的每个状态实现状态类。这些类将负责在对应的状态下进行机器的行为。</li>
<li>最后，我们要摆脱旧的条件代码，取而代之的方式是，将动作委托到状态类。</li>
</ul>
<p><img data-src="https://chentianming11.github.io/images/design/state/47618146.png" alt="47618146"></p>
<p>糖果机：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GumballMachine</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 糖果售罄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> State soldOutState;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 没有硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> State noQuarterState;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> State hasQuarterState;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售出糖果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> State soldState;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> State state = soldOutState;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 售出糖果数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GumballMachine</span><span class="params">(<span class="keyword">int</span> numberGumballs)</span> </span>&#123;</span><br><span class="line">        soldOutState = <span class="keyword">new</span> SoldOutState(<span class="keyword">this</span>);</span><br><span class="line">        noQuarterState = <span class="keyword">new</span> NoQuarterState(<span class="keyword">this</span>);</span><br><span class="line">        hasQuarterState = <span class="keyword">new</span> HasQuarterState(<span class="keyword">this</span>);</span><br><span class="line">        soldState = <span class="keyword">new</span> SoldState(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.count = numberGumballs;</span><br><span class="line">        <span class="keyword">if</span> (numberGumballs &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            state = noQuarterState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 投入硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.insertQuarter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退回硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.ejectQuarter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转动曲柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        state.turnCrank();</span><br><span class="line">        state.dispense();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>状态对象NoQuarterState:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoQuarterState</span> <span class="keyword">implements</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GumballMachine gumballMachine;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoQuarterState</span><span class="params">(GumballMachine gumballMachine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gumballMachine = gumballMachine;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 投入硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"投入硬币"</span>);</span><br><span class="line">        gumballMachine.setState(gumballMachine.getHasQuarterState());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 退回硬币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ejectQuarter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"无法退回,您还未投入硬币"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 转动曲柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">turnCrank</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请先投入硬币"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发放糖果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispense</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请先投入硬币"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，我们做了哪些事情？</p>
<ul>
<li>将每个状态的行为局部化到它自己的类中。</li>
<li>将容易产生的问题的if语句删除，以方便日后维护。</li>
<li>让每一个状态“对修改关闭”，让糖果机“对扩展开放”。</li>
</ul>
<p><img data-src="https://chentianming11.github.io/images/design/state/76555373.png" alt="76555373"></p>
<h3 id="定义状态模式"><a href="#定义状态模式" class="headerlink" title="定义状态模式"></a>定义状态模式</h3><p><strong>状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。</strong><br>因为这个类将状态封装成独立的类，并将动作委托到代表当前状态的对象，我们知道行为会随着内部状态的改变而改变。<br>从客户的视角来看，如果说你使用的对象能够完全改变它的行为，那么你会觉得，这个对象实际上是从别的类实例化而来的。<br><img data-src="https://chentianming11.github.io/images/design/state/77253919.png" alt="77253919"></p>
<p>从类图上看，策略模式和状态模式的类图是一样的，但是这两个模式的差别在于它们的“意图”。<br>以状态模式而言，我们将一群行为封装在状态对象中，context的行为随时可委托到那些状态对象中的一个。当前状态在状态对象集合中游走改变，以反映出context内部状态，因此context的行为也会跟着改变。<br>以策略模式而言，客户通常主动指定context所要组合的策略对象是哪一个。现在，固然策略模式让我们具有弹性，能够在运行时改变策略，但对于某个context对象来说，通常都只有一个最合适的策略对象。<br>一般来说，我们把策略模式想成是除了继承之外的一种弹性替代。<br>把状态模式想成是不用在context中放置许多条件判断的替代方案。通过将行为包装进状态对象中，你可以通过在context中简单的改变状态对象来改变context的行为。</p>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>state包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>五、命令模式</title>
    <url>/posts/438784632/</url>
    <content><![CDATA[<h3 id="示例说明"><a href="#示例说明" class="headerlink" title="示例说明"></a>示例说明</h3><p>设计一个家电自动化遥控器的api，这个遥控器具有7个可编程插槽(每个都可以指定到一个不同的家电装置)，每个插槽都有对应的开关按钮。这个遥控器还具备一个整体的撤销按钮。<br>现有一组java类，这些类是由多家厂商开发出来的，用来控制家电自动化装置。希望你创建一组控制遥控器的api，让每个插槽都可以控制一个或者一组装置。注意，能够控制目前的装置和任何未来可能出现的装置，这一点很重要。</p>
<a id="more"></a>
<p><img data-src="https://chentianming11.github.io/images/design/command/29832103.png" alt="29832103"></p>
<p>厂商类：接口各有差异<br><img data-src="https://chentianming11.github.io/images/design/command/29965408.png" alt="29965408"></p>
<h3 id="简单介绍命令模式"><a href="#简单介绍命令模式" class="headerlink" title="简单介绍命令模式"></a>简单介绍命令模式</h3><p>以餐厅为例，研究顾客，女招待，订单以及快餐厨师之间的交互。<br><img data-src="https://chentianming11.github.io/images/design/command/30383427.png" alt="30383427"></p>
<p>让我们更详细的研究这个交互过程<br><img data-src="https://chentianming11.github.io/images/design/command/30535334.png" alt="30535334"></p>
<p><strong>一张订单封装了准备餐点的请求</strong><br>把订单想象成一个用来请求准备餐点的对象，和一般的对象一样，订单对象可以被传递：从女招待传递到订单柜台。订单接口只包含一个方法：orderUp()。这个方法封装了准备餐点所需的动作。订单内有一个到“需要进行准备工作的对象”（厨师）的引用。这一切都被封装起来了，所以女招待不需要知道订单上有什么，也不需要要知道是谁来准备餐点。她只需要将订单放到订单窗口，然后喊一声“订单来了”。<br><strong>女招待的工作是接受订单，然后调用订单orderUp()方法</strong><br>女招待的工作很简单：接下顾客的订单，继续帮助下一个顾客，然后将一定数量订单放到订单柜台，并调用orderUp()方法，让人准备餐点。<br>现在，一天内，不同的顾客有不同的订单，这会使得女招待的takeOrder()方法传入不同的参数。女招待知道所有的订单都支持orderUp方法。<br><strong>快餐厨师具备准备餐点的知识</strong><br>快餐厨师是一个对象，他真正知道如何准备餐点。一旦女招待调用orderUp方法，快餐厨师就接手，实现需要创建餐点的所有方法。请注意，女招待和厨师之间彻底解耦：女招待的订单封装了餐点的细节，她只要调用每个订单的方法即可，而厨师看了订单就知道该做些什么餐点；厨师和女招待之间从来都不需要直接沟通。</p>
<p><img data-src="https://chentianming11.github.io/images/design/command/75856343.png" alt="75856343"></p>
<h3 id="第一个命令对象"><a href="#第一个命令对象" class="headerlink" title="第一个命令对象"></a>第一个命令对象</h3><p><strong>命令接口</strong><br>所有的命令对象都实现都实现了相同的包含一个方法execute()的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>实现一个打开电灯的命令</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LightOnCommand</span><span class="params">(Light light)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.light = light;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用命令对象</strong><br>假设遥控器只有一个按钮和对应的插槽，可以控制一个装置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRemoteControl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按钮被按下</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buttonWasPressed</span><span class="params">()</span></span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义命令对象"><a href="#定义命令对象" class="headerlink" title="定义命令对象"></a>定义命令对象</h3><p><strong>将“请求”封装成对象，以便使用不同的请求队列或日志来参数化其他对象。命令模式也支持可撤销的操作</strong><br>我们知道一个命令对象通过在特定的接收者上绑定一组动作来封装一个请求。命令对象将动作和接收者包进对象中。这个对象只暴露出一个execute()方法，当该方法被调用，接收者就会执行对应的动作。<br><img data-src="https://chentianming11.github.io/images/design/command/78928316.png" alt="78928316"></p>
<h3 id="将命令指定到插槽"><a href="#将命令指定到插槽" class="headerlink" title="将命令指定到插槽"></a>将命令指定到插槽</h3><p>我们打算将遥控器的每个插槽对应到一个命令，这样就让遥控器变成了调用者。当按下按钮，相应的命令对象的execute()方法就会被调用，其结果就是，接收者(电灯，音响等)的动作被执行。<br><img data-src="https://chentianming11.github.io/images/design/command/79501931.png" alt="79501931"></p>
<p><strong>实现音响</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   Command[] onCommands;</span><br><span class="line">   Command[] offCommands;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 有7个插槽</span></span><br><span class="line"><span class="comment">     * 默认都是空命令对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">RemoteControl</span><span class="params">()</span></span>&#123;</span><br><span class="line">       onCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">       offCommands = <span class="keyword">new</span> Command[<span class="number">7</span>];</span><br><span class="line">       NoCommand noCommand = <span class="keyword">new</span> NoCommand();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">           onCommands[i] = noCommand;</span><br><span class="line">           offCommands[i] = noCommand;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slot 槽位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onCommand 打开命令</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> offCommand 关闭命令</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(<span class="keyword">int</span> slot, Command onCommand, Command offCommand)</span></span>&#123;</span><br><span class="line">       onCommands[slot] = onCommand;</span><br><span class="line">       offCommands[slot] = offCommand;</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按下打开按钮</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slot 槽位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onButtonPushed</span><span class="params">(<span class="keyword">int</span> slot)</span></span>&#123;</span><br><span class="line">       onCommands[slot].execute();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 按下关闭按钮</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> slot 槽位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offButtonPushed</span><span class="params">(<span class="keyword">int</span> slot)</span></span>&#123;</span><br><span class="line">       offCommands[slot].execute();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">        Light light = <span class="keyword">new</span> Light();</span><br><span class="line">        Stereo stereo = <span class="keyword">new</span> Stereo();</span><br><span class="line">        GarageDoor garageDoor = <span class="keyword">new</span> GarageDoor();</span><br><span class="line">        LightOnCommand lightOnCommand = <span class="keyword">new</span> LightOnCommand(light);</span><br><span class="line">        LightOffCommand lightOffCommand = <span class="keyword">new</span> LightOffCommand(light);</span><br><span class="line">        GarageDoorOpenCommand garageDoorOpenCommand = <span class="keyword">new</span> GarageDoorOpenCommand(garageDoor);</span><br><span class="line">        GarageDoorCloseCommand garageDoorCloseCommand = <span class="keyword">new</span> GarageDoorCloseCommand(garageDoor);</span><br><span class="line">        StereoOnWithCdCommand stereoOnWithCdCommand = <span class="keyword">new</span> StereoOnWithCdCommand(stereo);</span><br><span class="line">        StereoOffCommand stereoOffCommand = <span class="keyword">new</span> StereoOffCommand(stereo);</span><br><span class="line">        remoteControl.setCommand(<span class="number">0</span>, lightOnCommand, lightOffCommand);</span><br><span class="line">        remoteControl.setCommand(<span class="number">1</span>, garageDoorOpenCommand, garageDoorCloseCommand);</span><br><span class="line">        remoteControl.setCommand(<span class="number">2</span>, stereoOnWithCdCommand, stereoOffCommand);</span><br><span class="line">        System.out.println(remoteControl);</span><br><span class="line">        remoteControl.onButtonPushed(<span class="number">0</span>);</span><br><span class="line">        remoteControl.onButtonPushed(<span class="number">1</span>);</span><br><span class="line">        remoteControl.onButtonPushed(<span class="number">2</span>);</span><br><span class="line">        remoteControl.offButtonPushed(<span class="number">0</span>);</span><br><span class="line">        remoteControl.offButtonPushed(<span class="number">1</span>);</span><br><span class="line">        remoteControl.offButtonPushed(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现撤销"><a href="#实现撤销" class="headerlink" title="实现撤销"></a>实现撤销</h3><p>现在需要给遥控器加上撤销的功能，比如说电灯现在是关闭的，按下打开按钮后，电灯打开。再按下撤销按钮，上一个动作将被倒转。在这个例子中，电灯将被关闭。</p>
<ul>
<li><p>当命令支持撤销时，该命令就必须提供和execute()方法相反的的undo()方法。不管execute()做了什么，undo()都会倒转过来。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>从lightOnCommand开始，execute是on()，undo()执行的就是off()。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LightOnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Light light;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.on();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        light.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>要加上对撤销按钮的支持，我们必须对遥控器类做一些小修改：加入一个新的实例变量，用来追踪最后被调用的命令，然后，不管何时按下撤销按钮，我们都取出这个命令并调用它的undo()方法。</p>
</li>
</ul>
<h4 id="使用状态实现撤销"><a href="#使用状态实现撤销" class="headerlink" title="使用状态实现撤销"></a>使用状态实现撤销</h4><p>通常实现撤销功能，需要记录一些状态。已吊扇为例。<br>需要追踪吊扇最后设置的速度，如果undo()方法被调用了，就恢复成之前吊扇速度的设置值。</p>
<ul>
<li>增加局部变量以便追踪之前的速度</li>
<li>在execute中，先将之前的状态记录下来，以便需要撤销时使用。</li>
<li>undo()将吊扇的速度设置回之前的值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractCeilingFanCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">   <span class="keyword">protected</span> CeilingFan ceilingFan;</span><br><span class="line">   <span class="keyword">protected</span> <span class="keyword">int</span> prevSpeed;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AbstractCeilingFanCommand</span><span class="params">(CeilingFan ceilingFan)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ceilingFan = ceilingFan;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        prevSpeed = ceilingFan.getSpeed();</span><br><span class="line">        doExecute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doExecute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (prevSpeed == CeilingFan.HIGH)&#123;</span><br><span class="line">            ceilingFan.high();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevSpeed == CeilingFan.MEDIUM)&#123;</span><br><span class="line">            ceilingFan.mediun();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevSpeed == CeilingFan.LOW)&#123;</span><br><span class="line">            ceilingFan.low();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevSpeed == CeilingFan.OFF)&#123;</span><br><span class="line">            ceilingFan.off();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="每个遥控器都具备“party模式”-宏命令"><a href="#每个遥控器都具备“party模式”-宏命令" class="headerlink" title="每个遥控器都具备“party模式”-宏命令"></a>每个遥控器都具备“party模式”-宏命令</h3><p>使用一个宏命令，用来执行一堆命令。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 宏命令</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacroCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span>&#123;</span><br><span class="line">    Command[] commands;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MacroCommand</span><span class="params">(Command[] commands)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.commands = commands;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commands.length; i++) &#123;</span><br><span class="line">            commands[i].execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commands.length; i++) &#123;</span><br><span class="line">            commands[i].undo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>command包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>二、观察者模式</title>
    <url>/posts/2586075670/</url>
    <content><![CDATA[<h3 id="气象监测应用的概况"><a href="#气象监测应用的概况" class="headerlink" title="气象监测应用的概况"></a>气象监测应用的概况</h3><p>此系统中的三个部分是气象站(获取实际气象数据的物理装置)、WeatherData对象（追踪来自气象站的数据，并更新布告板）和布告板（显示目前天气状况给用户看）。</p>
<a id="more"></a>

<p><img data-src="https://chentianming11.github.io/images/design/observer/29232658.png" alt="29232658"></p>
<p>我们的工作就是建立一个应用，利用WeatherData对象获取数据，并更新3个布告板：目前状况、气象统计和天气预报。</p>
<h3 id="WeatherData类"><a href="#WeatherData类" class="headerlink" title="WeatherData类"></a>WeatherData类</h3><p><img data-src="https://chentianming11.github.io/images/design/observer/29563592.png" alt="29563592"></p>
<ol>
<li>WeatherData类中有getter方法，可以取得三个测量值：温度、湿度和气压。</li>
<li>当新的测量数据准备妥当时，measurementsChanged()方法就会被调用。</li>
<li>我们需要实现三个使用天气数据的布告板：“目前状况”、“气象统计”、“天气预报”。一旦WeatherData有新的测量，这些布告必须马上更新。</li>
<li>此系统必须可以扩展，让其他开发人员建立定制布告板，用户可以随心所欲的添加或删除任何布告板。</li>
</ol>
<h3 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h3><p><img data-src="https://chentianming11.github.io/images/design/observer/30208312.png" alt="30208312"></p>
<p>问题分析：<br><img data-src="https://chentianming11.github.io/images/design/observer/30229873.png" alt="30229873"></p>
<h3 id="认识观察者模式"><a href="#认识观察者模式" class="headerlink" title="认识观察者模式"></a>认识观察者模式</h3><p>出版者+订阅者=观察者模式<br><img data-src="https://chentianming11.github.io/images/design/observer/30929065.png" alt="30929065"></p>
<h3 id="定义观察者模式"><a href="#定义观察者模式" class="headerlink" title="定义观察者模式"></a>定义观察者模式</h3><p><strong>观察者模式：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖都会收到通知并自动更新</strong>。</p>
<p><img data-src="https://chentianming11.github.io/images/design/observer/31615093.png" alt="31615093"></p>
<p>松耦合的设计之所以能让我们建立有弹性的OO系统，能够应对变化，是因为对象之间的互相依赖降到最低。</p>
<h3 id="设计气象站"><a href="#设计气象站" class="headerlink" title="设计气象站"></a>设计气象站</h3><p><img data-src="https://chentianming11.github.io/images/design/observer/31755226.png" alt="31755226"></p>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>observer包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>八、迭代器与组合模式</title>
    <url>/posts/2681276079/</url>
    <content><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>对象村餐厅和对象村煎饼屋合并了，但是它们的菜单存储方式不同，一个是用Arraylist，另一个是数组实现的。</p>
<a id="more"></a>
<ul>
<li>菜单项-MenuItem</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MenuItem</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否为素食</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> vegetarian;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>煎饼屋菜单-ArrayList实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PancakeHouseMenu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;MenuItem&gt; menuItems;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PancakeHouseMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        menuItems = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        addItem(<span class="string">"K&amp;B薄煎饼早餐"</span>, <span class="string">"薄煎饼，鸡蛋和吐司"</span>, <span class="keyword">true</span>, <span class="number">2.99</span>);</span><br><span class="line">        addItem(<span class="string">"薄煎饼早餐"</span>, <span class="string">"薄煎饼带鸡蛋、香肠"</span>, <span class="keyword">false</span>, <span class="number">2.99</span>);</span><br><span class="line">        addItem(<span class="string">"蓝莓薄煎饼"</span>, <span class="string">"蓝莓薄煎饼"</span>, <span class="keyword">true</span>, <span class="number">3.49</span>);</span><br><span class="line">        addItem(<span class="string">"松饼"</span>, <span class="string">"松饼，可以选择蓝莓或者草莓"</span>, <span class="keyword">true</span>, <span class="number">3.59</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(String name, String description, <span class="keyword">boolean</span> vegetarian, <span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        MenuItem menuItem = <span class="keyword">new</span> MenuItem(name, description, vegetarian, price);</span><br><span class="line">        menuItems.add(menuItem);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>餐厅菜单 - 数组实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DinerMenu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ITMES = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> numberOfItems = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    MenuItem[] menuItems;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenu</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.menuItems = <span class="keyword">new</span> MenuItem[MAX_ITMES];</span><br><span class="line">        addItem(<span class="string">"素食BIT"</span>, <span class="string">"素食BIT"</span>, <span class="keyword">true</span>, <span class="number">2.99</span>);</span><br><span class="line">        addItem(<span class="string">"BIT"</span>, <span class="string">"培根，生菜和西红柿"</span>, <span class="keyword">false</span>, <span class="number">2.99</span>);</span><br><span class="line">        addItem(<span class="string">"例汤"</span>, <span class="string">"例汤"</span>, <span class="keyword">false</span>, <span class="number">3.29</span>);</span><br><span class="line">        addItem(<span class="string">"热狗"</span>, <span class="string">"热狗，酸菜莓"</span>, <span class="keyword">false</span>, <span class="number">3.59</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(String name, String description, <span class="keyword">boolean</span> vegetarian, <span class="keyword">double</span> price)</span></span>&#123;</span><br><span class="line">        MenuItem menuItem = <span class="keyword">new</span> MenuItem(name, description, vegetarian, price);</span><br><span class="line">        <span class="keyword">if</span> (numberOfItems &gt;= MAX_ITMES)&#123;</span><br><span class="line">            System.out.println(<span class="string">"餐厅菜单满了，放不下了！"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            menuItems[numberOfItems] = menuItem;</span><br><span class="line">            numberOfItems++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两种不同的菜单会带来什么问题"><a href="#两种不同的菜单会带来什么问题" class="headerlink" title="两种不同的菜单会带来什么问题"></a>两种不同的菜单会带来什么问题</h3><p>让我们试着实现一个同时使用这2个菜单的客户代码。即创建一个java版本的女招待，按如下规格实现。<br><img data-src="https://chentianming11.github.io/images/design/iterator/68640047.png" alt="68640047"></p>
<p><strong>我们总是需要处理2个菜单，并且用2个循环去遍历这些项。</strong>如果还有第三家餐厅以不同的形式出现，我们就需要3个循环。<br>目前煎饼屋和餐厅都不想改变他们的代码，因为这些代码使用的地方太多了。如果我们能找到一种方法，让他们的菜单实现一个相同的接口。这样，我们可以最小化女招待代码中的具体引用，同时还有希望摆脱这2个菜单所需的多个循环。</p>
<h3 id="会见迭代器模式"><a href="#会见迭代器模式" class="headerlink" title="会见迭代器模式"></a>会见迭代器模式</h3><p>关于迭代器模式，你所需要知道的第一件事情，就是它依赖于一个称为迭代器的接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，我们实现一个具体的迭代器，为餐厅菜单服务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DinerMenuIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">MenuItem</span>&gt; </span>&#123;</span><br><span class="line">    MenuItem[] menuItems;</span><br><span class="line">    <span class="keyword">int</span> position = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DinerMenuIterator</span><span class="params">(MenuItem[] menuItems)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.menuItems = menuItems;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position &gt;= menuItems.length || menuItems[position] == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MenuItem <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MenuItem menuItem = menuItems[position];</span><br><span class="line">        position++;</span><br><span class="line">        <span class="keyword">return</span> menuItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h3><p>首先，java util下已经有了Iterator接口，我们不需要重复创建。其次ArrayList已经有了获取迭代器的方法，我们不需要自己在定义了一个针对于餐厅菜单的迭代器。女招待只需要知道有2种菜单，然后可以使用迭代器来统一遍历菜单。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitress</span> </span>&#123;</span><br><span class="line">    Menu pancakeHouseMenu;</span><br><span class="line">    Menu dinerMenu;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造女招待的时候，需要传入2个菜单</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pancakeHouseMenu</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dinerMenu</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Waitress</span><span class="params">(Menu pancakeHouseMenu, Menu dinerMenu)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pancakeHouseMenu = pancakeHouseMenu;</span><br><span class="line">        <span class="keyword">this</span>.dinerMenu = dinerMenu;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Iterator&lt;MenuItem&gt; pancakeHouseMenuIterator = pancakeHouseMenu.getIterator();</span><br><span class="line">        Iterator&lt;MenuItem&gt; dinerMenuIterator = dinerMenu.getIterator();</span><br><span class="line">        System.out.println(<span class="string">"煎饼屋菜单"</span>);</span><br><span class="line">        printMenu(pancakeHouseMenuIterator);</span><br><span class="line">        System.out.println(<span class="string">"餐厅菜单"</span>);</span><br><span class="line">        printMenu(dinerMenuIterator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">(Iterator&lt;MenuItem&gt; iterator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            MenuItem item = iterator.next();</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类图：<br><img data-src="https://chentianming11.github.io/images/design/iterator/74970366.png" alt="74970366"></p>
<h3 id="定义迭代器"><a href="#定义迭代器" class="headerlink" title="定义迭代器"></a>定义迭代器</h3><p><strong>迭代器模式提供了一种方法来顺序访问一个聚合对象中的各个元素，而又不暴露其内部的实现。</strong></p>
<p>在设计中，使用迭代器的影响是很明显的：如果你有一个统一的方法访问聚合中的每一个对象，你就可以编写多态的代码合这些聚合搭配使用。如同前面的printMenu()方法一样，只要有了迭代器这个方法，根本不用管菜单项是由数据还是ArrayList实现的。</p>
<p>另外，迭代器模式把元素之间游走的责任交给了迭代器，而不是聚合对象。这不仅让聚合的接口变得更简洁，也可以让聚合更专注它所专注的事情上面。</p>
<ul>
<li>设计原则</li>
</ul>
<p><strong>一个类应该只有一个引起变化的原因。</strong></p>
<p>类的每个责任都有改变的潜在区域。超过一个责任，意味着超过一个改变的区域。<br>这个原则告诉我们，尽量让每个类保持单一责任。<br>目前，每次我们有新的菜单项加入，就需要修改女招待的代码。这违反了开闭原则。因此，我们可以使用一个ArrayList来存放菜单项。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Waitress</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Menu&gt; menus = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Menu menu : menus) &#123;</span><br><span class="line">            Iterator&lt;MenuItem&gt; iterator = menu.getIterator();</span><br><span class="line">            printMenu(iterator);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printMenu</span><span class="params">(Iterator&lt;MenuItem&gt; iterator)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">            MenuItem item = iterator.next();</span><br><span class="line">            System.out.println(item);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>现在，我们期望餐厅菜单中能有一份甜点子菜单。<br><img data-src="https://chentianming11.github.io/images/design/iterator/76483900.png" alt="76483900"></p>
<p><strong>组合模式允许你将对象组合成树形结构来表现“整体部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合</strong><br>以菜单为例：组合模式能够创建一个树形结构，在同一个结构中处理嵌套菜单和菜单项组。通过将菜单和项放在相同的结构中，我们创建了“整体、部分”层次的结构。<br>组合模式让我们能用树形方式创建对象的结构，树里面包含了组合以及个别的对象。<br>使用组合结构，我们能把相同的操作应用到组合和个别对象上。换句话说，在大多数情况下，我们可以忽略对象组合和个别对象之间的差别。<br><img data-src="https://chentianming11.github.io/images/design/iterator/77606045.png" alt="77606045"></p>
<h4 id="利用组合模式设计菜单"><a href="#利用组合模式设计菜单" class="headerlink" title="利用组合模式设计菜单"></a>利用组合模式设计菜单</h4><p>我们需要创建一个组件接口来作为菜单和菜单项的共同接口，让我们能够用统一的做法来处理菜单和菜单项。<br><img data-src="https://chentianming11.github.io/images/design/iterator/78101926.png" alt="78101926"></p>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>iterator包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>六、适配器模式与外观模式</title>
    <url>/posts/1338925870/</url>
    <content><![CDATA[<h3 id="面向对象适配"><a href="#面向对象适配" class="headerlink" title="面向对象适配"></a>面向对象适配</h3><p>假设已有一个软件系统，你希望它能和新的厂商类库搭配使用，但是这个新厂商所设计出来的接口，不同于旧厂商的接口：</p>
<a id="more"></a>
<p><img data-src="https://chentianming11.github.io/images/design/adapter/52424771.png" alt="52424771"></p>
<p>你不想改变现有的代码，而且你也不能改变厂商的代码。可以写一个类，将新厂商的接口转换成你所期望的接口。<br><img data-src="https://chentianming11.github.io/images/design/adapter/52559318.png" alt="52559318"></p>
<p>这个适配器工作起来就如同一个中间人，它将客户所发出的请求转换成厂商类能理解的请求。<br><img data-src="https://chentianming11.github.io/images/design/adapter/52650867.png" alt="52650867"></p>
<p><strong>如果它走起来像只鸭子，叫起来像只鸭子，它可能是一只包装了鸭子适配器的火鸡</strong>。</p>
<ul>
<li><p>鸭子接口</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绿头鸭是鸭子的子类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MallardDuck</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"嘎嘎叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"飞起来了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>火鸡接口</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>野生火鸡</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"咯咯叫"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"只能飞一点距离"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>现在，假设你缺鸭子对象，想用一些火鸡来冒充。显而易见，因为火鸡接口的不同，所以我们不能公然拿来用</strong>。</p>
<p><strong>写个适配器吧</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 火鸡适配器</span></span><br><span class="line"><span class="comment"> * 将火鸡适配成鸭子</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/1/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    Turkey turkey;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.gobble();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            turkey.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="适配器模式解析"><a href="#适配器模式解析" class="headerlink" title="适配器模式解析"></a>适配器模式解析</h3><p>现在我们已经知道什么事适配器了，让我们后退一步，再次看看各部分之间的依赖。<br><img data-src="https://chentianming11.github.io/images/design/adapter/55403105.png" alt="55403105"></p>
<p><strong>客户使用适配器的过程如下</strong>：</p>
<ul>
<li>客户通过目标调用适配器的方法对适配器发出请求。</li>
<li>适配器使用被适配者接口把请求转换成被适配者的一个或多个调用接口。</li>
<li>客户接收到调用的结果，但并未察觉这一切是适配器在起转换作用。</li>
</ul>
<h3 id="定义适配器模式"><a href="#定义适配器模式" class="headerlink" title="定义适配器模式"></a>定义适配器模式</h3><p><strong>将一个类的接口，转换成客户所期望的另一个接口，适配器让原本接口不兼容的类可以合作无间</strong>。<br><img data-src="https://chentianming11.github.io/images/design/adapter/56209055.png" alt="56209055"></p>
<p>适配器模式充满了良好的OO设计原则：使用对象组合，以修改的接口包装被适配者。这种做法还有额外的优点：被适配者的任何子类，都可以搭配适配器使用。</p>
<h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>假设你要建立一个家庭影院系统，内含DVD播放器、投影机、自动屏幕、环绕立体声，甚至还有爆米花机。<br><img data-src="https://chentianming11.github.io/images/design/adapter/68996552.png" alt="68996552"></p>
<h4 id="观赏电影（用困难方式）"><a href="#观赏电影（用困难方式）" class="headerlink" title="观赏电影（用困难方式）"></a>观赏电影（用困难方式）</h4><p>想看电影，必须先执行一系列任务。<br><img data-src="https://chentianming11.github.io/images/design/adapter/69113994.png" alt="69113994"></p>
<h4 id="使用外观"><a href="#使用外观" class="headerlink" title="使用外观"></a>使用外观</h4><p><img data-src="https://chentianming11.github.io/images/design/adapter/69515218.png" alt="69515218"></p>
<ul>
<li>现在为家庭影院系统创建一个外观类，它对外暴露了几个简单的方法，例如：watchMovie()；</li>
<li>这个外观将家庭影院的诸多组件视为一个子系统，通过调用这个子系统，来实现watchMovie()方法。</li>
<li>外观只是提供更直接的操作，并未将原来的子系统隔离起来。如果你愿意使用子系统的高级功能，还是可以使用原来的子系统的。</li>
<li>外观不只是简化了接口，还将客户熊组件的子系统中解耦</li>
<li>外观和适配器都可以包装许多类，但是外观的意图是简化接口，而适配器的意图是将接口转换成不同的接口。</li>
</ul>
<h4 id="定义外观模式"><a href="#定义外观模式" class="headerlink" title="定义外观模式"></a>定义外观模式</h4><p><strong>外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。</strong><br><img data-src="https://chentianming11.github.io/images/design/adapter/70037392.png" alt="70037392"></p>
<p><strong>最少知识原则</strong><br>最少知识原则告诉我们要减少对象之间的交互，只留下几个“密友”。<br><strong>最少知识原则：只和你的密友交谈</strong><br>这个原则希望我们在设计中，不要让太多的类耦合在一起，免得修改系统中的一部分，会影响到其他部分。</p>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>adapter包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>十、单例模式</title>
    <url>/posts/4179133156/</url>
    <content><![CDATA[<h3 id="单例模式的应用场景"><a href="#单例模式的应用场景" class="headerlink" title="单例模式的应用场景"></a>单例模式的应用场景</h3><p><strong>单例模式（Singleton Pattern）是指确保一个类在任何情况下都绝对只有一个实例，并 提供一个全局访问点。</strong>单例模式是创建型模式。在 J2EE 标准中，ServletContext、ServletContextConfig 等；在 Spring 框架应用中 ApplicationContext；数据库的连接池也都是单例形式。</p>
<a id="more"></a>

<h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><p><strong>饿汉式单例是在类加载的时候就立即初始化，并且创建单例对象。绝对线程安全，在线 程还没出现以前就是实例化了，不可能存在访问安全问题</strong>。</p>
<p>优点：没有加任何的锁、执行效率比较高，在用户体验上来说，比懒汉式更好。<br>缺点：类加载的时候就初始化，不管用与不用都占着空间，可能会浪费内存。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态字段初始化实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HungrySingleton INSTANCE = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 提供静态方法获取实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><p>懒汉式单例的特点是：<strong>被外部类调用的时候内部类才会加载。</strong></p>
<h4 id="double-check"><a href="#double-check" class="headerlink" title="double-check"></a>double-check</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用volatile防止因为指令重排序导致空指针异常。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// double-check加锁</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazySingleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InnerClassSingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 在返回结果以前， 一定会先加载内部类</span></span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态内部类在没有调用的时候，不会加载</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassSingleton INSTANCE = <span class="keyword">new</span> InnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种形式兼顾饿汉式的内存浪费，也兼顾<code>synchronized</code>性能问题。内部类一定是要在方 法调用之前初始化，巧妙地避免了线程安全问题。</p>
<h3 id="反射破坏单例"><a href="#反射破坏单例" class="headerlink" title="反射破坏单例"></a>反射破坏单例</h3><p>上面介绍的单例模式的构造方法除了加上<code>private</code>以外，没有做任何处理。如果我们使用反射来调用其构造方法，然后，再调用<code>getInstance()</code>方法，应该就会两个不同的实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;InnerClassSingleton&gt; clzz = InnerClassSingleton<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Constructor&lt;InnerClassSingleton&gt; constructor = clzz.getDeclaredConstructor(<span class="keyword">null</span>);</span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">InnerClassSingleton o1 = constructor.newInstance();</span><br><span class="line">InnerClassSingleton o2 = InnerClassSingleton.getInstance();</span><br><span class="line"><span class="comment">// 结果：false</span></span><br><span class="line">System.out.println(o1 == o2);</span><br></pre></td></tr></table></figure>

<p>解决方案：我们在其构造方法中做一些限制，一旦出现多次重复创建，则直接抛出异常。来看优化后的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingletonPreventReflect</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (InstanceHolder.INSTANCE != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"不允许构建多个实例！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="序列化破坏单例"><a href="#序列化破坏单例" class="headerlink" title="序列化破坏单例"></a>序列化破坏单例</h3><p>当我们将一个单例对象创建好，有时候需要将对象序列化然后写入到磁盘，下次使用时再从磁盘中读取到对象，反序列化转化为内存对象。反序列化后的对象会重新分配内存，即重新创建。那如果序列化的目标的对象为单例对象，就违背了单例模式的初衷，相当于破坏了单例。</p>
<p><strong>解决方案：只需要给单例对象增加 readResolve()方法即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getInstance();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>源码分析：<br><code>ObjectInputStream.readObject()  -&gt; readObject0(false)</code>：</p>
<p><img data-src="https://chentianming11.github.io/images/design/singleton/54080286.png" alt="54080286"></p>
<p><strong>重点就是readOrdinaryObject(unshared)方法</strong>：<br><img data-src="https://chentianming11.github.io/images/design/singleton/82299289.png" alt="82299289"></p>
<p>发现调用了<code>ObjectStreamClass</code>的<code>isInstantiable()</code>方法，而<code>isInstantiable()</code>里面的代码如下：<br><img data-src="https://chentianming11.github.io/images/design/singleton/82415056.png" alt="82415056"></p>
<p>代码非常简单，就是判断一下构造方法是否为空，构造方法不为空就返回 true。意味着，只要有无参构造方法就会实例化。<br><strong>接着看<code>readOrdinaryObject(unshared)</code>方法</strong>：<br><img data-src="https://chentianming11.github.io/images/design/singleton/82844607.png" alt="82844607"></p>
<p><strong>如果要反序列化的对象存在readResolve()方法，就调用该方法并将方法的返回结果作为readObject的返回结果。</strong><br>因此，我们新增readResolve()方法，并返回当前单例实例即可防止反序列化破坏单例。<br><em>但是，我们通过分析源码以及调试，我们可以看到实际上实例化了两次，只不过新创建的对象没有被返回而已。那如果，创建对象的动作发生频率增大，就意味着内存分配开销也就随之增大。</em></p>
<h3 id="注册式单例"><a href="#注册式单例" class="headerlink" title="注册式单例"></a>注册式单例</h3><p><strong>注册式单例又称为登记式单例，就是将每一个实例都登记到某一个地方，使用唯一的标 识获取实例</strong>。注册式单例有两种写法：一种为容器缓存，一种为枚举登记。</p>
<h4 id="枚举式单例"><a href="#枚举式单例" class="headerlink" title="枚举式单例"></a>枚举式单例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 任意字段或者方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Setter</span></span><br><span class="line">    <span class="meta">@Getter</span></span><br><span class="line">    <span class="keyword">private</span> Object field;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"任意方法！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用jad反编译EnumSingleton.class文件，得到如下信息<br><img data-src="https://chentianming11.github.io/images/design/singleton/53427927.png" alt="53427927"></p>
<ul>
<li>枚举EnumSingleton实际上被编译成了一个继承Enum的EnumSingleton类</li>
<li>类的构造方法被私有了</li>
<li>在静态代码块中，EnumSingleton就被实例化了。</li>
</ul>
<p>综上，枚举式单例实际上也是一种饿汉式单例的实现。自然保证了线程安全相关问题。</p>
<h5 id="枚举式单例避免反序列化破坏单例？"><a href="#枚举式单例避免反序列化破坏单例？" class="headerlink" title="枚举式单例避免反序列化破坏单例？"></a>枚举式单例避免反序列化破坏单例？</h5><p>源码分析：</p>
<p><code>ObjectInputStream.readObject()  -&gt; readObject0(false)</code>：<br><img data-src="https://chentianming11.github.io/images/design/singleton/54157927.png" alt="54157927"></p>
<p>我们看到在<code>readObject0()</code>中调用了<code>readEnum()</code>方法，来看<code>readEnum()</code>中代码实现：<br><img data-src="https://chentianming11.github.io/images/design/singleton/54296048.png" alt="54296048"></p>
<p>我们发现枚举类型其实通过枚举名和 Class 对象类找到一个唯一的枚举对象。因此，枚举对象不可能被类加载器加载多次。</p>
<h5 id="枚举式单例避免反射破坏单例？"><a href="#枚举式单例避免反射破坏单例？" class="headerlink" title="枚举式单例避免反射破坏单例？"></a>枚举式单例避免反射破坏单例？</h5><p><code>Constructor.newInstance(..)</code>源码：<br><img data-src="https://chentianming11.github.io/images/design/singleton/54646102.png" alt="54646102"></p>
<p>在newInstance()方法中做了强制性的判断，如果修饰符是 Modifier.ENUM 枚举类型，直接抛出异常。<br>综上：枚举式单例从JDK层面保证了反序列化和反射时的安全性。枚举式单例也是《Effective Java》书中推荐的一种单例实现写法。</p>
<h4 id="容器缓存单例"><a href="#容器缓存单例" class="headerlink" title="容器缓存单例"></a>容器缓存单例</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ContainerSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; ioc = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; tClass)</span> </span>&#123;</span><br><span class="line">        Object o = ioc.get(tClass.getName());</span><br><span class="line">        <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> (T) o;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (ioc) &#123;</span><br><span class="line">            T t = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t = tClass.newInstance();</span><br><span class="line">                ioc.put(tClass.getName(), t);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容器式写法适用于创建多种类型单例的情况，便于统一管理，例如spring中的ioc容器。</p>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>singleton包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>十一、原型模式</title>
    <url>/posts/2135295138/</url>
    <content><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>原型模式就是从一个对象再创建另外一个可定制的对象， 而且不需要知道任何创建的细节。<br>所谓原型模式， 就是 Java 中的克隆技术， 以某个对象为原型。 复制出新的对象。 显然新的对象具备原型对象的特点， 效率高（避免了重新执行构造过程步骤）。</p>
<a id="more"></a>

<p>原型模式主要适用于以下场景：</p>
<ol>
<li>类初始化消耗资源较多。</li>
<li>new 产生的一个对象需要非常繁琐的过程（数据准备、访问权限等）</li>
<li>构造函数比较复杂。</li>
<li>循环体中生产大量对象时。</li>
</ol>
<h3 id="浅拷贝和深拷贝的特点"><a href="#浅拷贝和深拷贝的特点" class="headerlink" title="浅拷贝和深拷贝的特点"></a>浅拷贝和深拷贝的特点</h3><h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4><ul>
<li>对于数据类型是基本数据类型的成员变量，浅拷贝会直接进行值传递，也就是将该属性值复制一份给新的对象。</li>
<li>对于数据类型是引用数据类型的成员变量，比如说成员变量是某个数组、某个类的对象等，那么浅拷贝会进行引用传递，也就是只是将该成员变量的引用值（内存地址）复制一份给新的对象。因为实际上两个对象的该成员变量都指向同一个实例。在这种情况下，在一个对象中修改该成员变量会影响到另一个对象的该成员变量值。</li>
</ul>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><ul>
<li>复制对象的所有基本数据类型的成员变量值</li>
<li>为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象图进行拷贝！</li>
</ul>
<p>总结：<br><strong>深拷贝对引用数据类型的成员变量的对象图中所有的对象都开辟了内存空间；而浅拷贝只是传递地址指向，新的对象并没有对引用数据类型创建内存空间</strong></p>
<p>原型模式类图：<br><img data-src="https://chentianming11.github.io/images/design/prototype/prototype.webp" alt="prototype"></p>
<h3 id="Java中原型模式的浅拷贝和深拷贝的实现方式"><a href="#Java中原型模式的浅拷贝和深拷贝的实现方式" class="headerlink" title="Java中原型模式的浅拷贝和深拷贝的实现方式"></a>Java中原型模式的浅拷贝和深拷贝的实现方式</h3><ol>
<li>浅拷贝: 通过重写clone()方法进行浅拷贝，需要实现Clonable接口</li>
<li>深拷贝: 通过对象序列化实现深拷贝，推荐使用JSON序列化</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototypeA</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; hobbies;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过clone()方法来实现浅度拷贝</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// object的clone()方法为native方法，效率更高。</span></span><br><span class="line">        <span class="comment">// 不要自己new对象再赋值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过对象序列化实现深拷贝（推荐）</span></span><br><span class="line"><span class="comment">     * 序列化方式可以是JDK序列化，也可以是JSON序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deepClone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>(ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos)) &#123;</span><br><span class="line">            oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line">            ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">            ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">            <span class="keyword">return</span> ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"深拷贝失败！"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过对象序列化实现深拷贝（推荐）</span></span><br><span class="line"><span class="comment">     * 序列化方式可以是JDK序列化，也可以是JSON序列化, 推荐JSON序列化</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ConcretePrototypeA <span class="title">deepCloneWithJSON</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String jsonString = JSON.toJSONString(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(jsonString, <span class="keyword">this</span>.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>深拷贝第二种方式：先调用super.clone()方法克隆出一个新对象来，然后在子类的clone()方法中手动给克隆出来的非基本数据类型（引用类型）赋值。太麻烦，不推荐使用。</p>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>prototype包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>十三、委派模式和策略模式</title>
    <url>/posts/1670445475/</url>
    <content><![CDATA[<h2 id="委派模式"><a href="#委派模式" class="headerlink" title="委派模式"></a>委派模式</h2><h3 id="委派模式的定义及应用场景"><a href="#委派模式的定义及应用场景" class="headerlink" title="委派模式的定义及应用场景"></a>委派模式的定义及应用场景</h3><p><strong>委派模式(Delegate Pattern)的基本作用就是 负责任务的调用和分配任务，跟代理模式很像，可以看做是一种特殊情况下的静态代理 的全权代理，但是代理模式注重过程，而委派模式注重结果。</strong></p>
<a id="more"></a>
<p>委派模式在 Spring 中应用 非常多，大家常用的<code>DispatcherServlet</code>其实就是用到了委派模式。现实生活中也常有委派的场景发生，例如:老板(Boss)给项目经理(Leader)下达任务，项目经理会根据 实际情况给每个员工派发工作任务，待员工把工作任务完成之后，再由项目经理汇报工 作进度和结果给老板。我们用代码来模拟下这个业务场景，先来看一下类图:<br><img data-src="https://chentianming11.github.io/images/design/delegate/48271322.png" alt="48271322"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * boss - 发送命令</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Leader leader;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Boss</span><span class="params">(Leader leader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leader = leader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        leader.doing(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, IEmployee&gt; register = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        register.put(<span class="string">"加密"</span>, <span class="keyword">new</span> EmployeeA());</span><br><span class="line">        register.put(<span class="string">"架构"</span>, <span class="keyword">new</span> EmployeeB());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * leader根据不同的命令，将任务分发给不同的员工</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> command</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doing</span><span class="params">(String command)</span> </span>&#123;</span><br><span class="line">        register.get(command).doing(command);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IEmployee</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doing</span><span class="params">(String command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="委派模式在源码中的体现"><a href="#委派模式在源码中的体现" class="headerlink" title="委派模式在源码中的体现"></a>委派模式在源码中的体现</h3><p>下面我们再来还原一下<code>SpringMVC</code>的<code>DispatcherServlet</code>是如何实现委派模式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DispatcherServlet：</span></span><br><span class="line"><span class="comment"> * 所有的请求统一委派给DispatcherServlet进行处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        doDispatch(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求分发，根据不同的url，执行不同的逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        String uri = req.getRequestURI();</span><br><span class="line">        String mid = req.getParameter(<span class="string">"mid"</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"getMemberById"</span>.equals(uri))&#123;</span><br><span class="line">            <span class="keyword">new</span> MemberController().getMemberById(mid);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"getOrderById"</span>.equals(uri))&#123;</span><br><span class="line">            <span class="keyword">new</span> OrderController().getOrderById(mid);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"logout"</span>.equals(uri))&#123;</span><br><span class="line">            <span class="keyword">new</span> SystemController().logout();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            resp.getWriter().write(<span class="string">"404 Not Found!!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p><strong>策略模式(Strategy Pattern)是指定义了算法家族、分别封装起来，让它们之间可以互 相替换，此模式让算法的变化不会影响到使用算法的用户。</strong></p>
<h3 id="策略模式的应用场景"><a href="#策略模式的应用场景" class="headerlink" title="策略模式的应用场景"></a>策略模式的应用场景</h3><ol>
<li>假如系统中有很多类，而他们的区别仅仅在于他们的行为不同。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
</ol>
<h3 id="以优惠活动为例"><a href="#以优惠活动为例" class="headerlink" title="以优惠活动为例"></a>以优惠活动为例</h3><p>以优惠活动为例，优惠策略会有很多种可能 如:领取优惠券抵扣、返现促销、拼团优惠。下面我们用代码来模拟，首先我们创建一个促销策略的抽象<code>PromotionStrategy</code>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PromotionStrategy</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 执行优惠方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后分别创建优惠券抵扣策略 CouponStrategy 类、返现促销策略 CashbackStrategy 类、拼团优惠策略 GroupbuyStrategy 类和无优惠策略<code>EmptyStrategy</code>类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CouponStrategy</span> <span class="keyword">implements</span> <span class="title">PromotionStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行优惠方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用优惠券抵扣！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CashbackStrategy</span> <span class="keyword">implements</span> <span class="title">PromotionStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行优惠方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"返现优惠！！！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建促销活动方案<code>PromotionActivity</code>类:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionActivity</span> </span>&#123;</span><br><span class="line">    PromotionStrategy promotionStrategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PromotionActivity</span><span class="params">(PromotionStrategy promotionStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.promotionStrategy = promotionStrategy;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优惠活动开始</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        promotionStrategy.doPromotion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们做活动时候往往是要根据不同的需求对促销策略进行动态选择的 ，编写客户端代码进行测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionActivityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PromotionActivity promotionActivity = <span class="keyword">null</span>;</span><br><span class="line">        String promotionKey = <span class="string">"COUPON"</span>;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.equals(promotionKey, <span class="string">"COUPON"</span>)) &#123;</span><br><span class="line">            promotionActivity = <span class="keyword">new</span> PromotionActivity(<span class="keyword">new</span> CouponStrategy());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (StringUtils.equals(promotionKey, <span class="string">"CASHBACK"</span>)) &#123;</span><br><span class="line">            promotionActivity = <span class="keyword">new</span> PromotionActivity(<span class="keyword">new</span> CashbackStrategy());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        promotionActivity.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样改造之后，满足了业务需求，客户可根据自己的需求选择不同的优惠策略了。<strong>但是， 经过一段时间的业务积累，我们的促销活动会越来越多。但是每次上活动之前都要改代码，而且要做重复测试，判断逻辑可能也变得 越来越复杂。</strong>这时候，我们是不需要思考代码是不是应该重构了?回顾我们之前学过的 设计模式应该如何来优化这段代码呢?其实，我们可以结合<strong>单例模式和工厂模式</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionStrategyFactory</span> </span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 注册是单例</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, PromotionStrategy&gt; mapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">      mapping.put(PromotionKey.COUPON, <span class="keyword">new</span> CouponStrategy());</span><br><span class="line">      mapping.put(PromotionKey.CASHBACK, <span class="keyword">new</span> CashbackStrategy());</span><br><span class="line">      mapping.put(PromotionKey.GROUPBUY, <span class="keyword">new</span> GroupbuyStrategy());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据优惠标识获取对应的优惠策略对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> promotionKey</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PromotionStrategy <span class="title">getPromotionStrategy</span><span class="params">(String promotionKey)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> mapping.get(promotionKey);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">private</span> <span class="class"><span class="keyword">interface</span> <span class="title">PromotionKey</span> </span>&#123;</span><br><span class="line">      String COUPON = <span class="string">"COUPON"</span>;</span><br><span class="line">      String CASHBACK = <span class="string">"CASHBACK"</span>;</span><br><span class="line">      String GROUPBUY = <span class="string">"GROUPBUY"</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionActivityTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String promotionKey = <span class="string">"COUPON"</span>;</span><br><span class="line">        PromotionActivity promotionActivity = <span class="keyword">new</span> PromotionActivity(PromotionStrategyFactory</span><br><span class="line">                .getPromotionStrategy(promotionKey));</span><br><span class="line">        promotionActivity.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://chentianming11.github.io/images/design/delegate/58553017.png" alt="58553017"></p>
<h3 id="用策略模式实现选择支付方式的业务场景"><a href="#用策略模式实现选择支付方式的业务场景" class="headerlink" title="用策略模式实现选择支付方式的业务场景"></a>用策略模式实现选择支付方式的业务场景</h3><p>相信小伙伴们都 用过支付宝、微信支付、银联支付以及京东白条。一个常见的应用场景就是大家在下单 支付时会提示选择支付方式，如果用户未选，系统也会默认好推荐的支付方式进行结算。</p>
<ul>
<li><p>创建<code>Payment</code>抽象类，定义支付规范和支付逻辑</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 定义支付规范和支付逻辑</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 支付类型名称</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 查询余额</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">queryBalance</span><span class="params">(String uid)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 扣款支付</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> uid</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> amount</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PayState <span class="title">pay</span><span class="params">(String uid, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (queryBalance(uid) &lt; amount) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PayState(<span class="number">500</span>, <span class="string">"支付失败"</span>, <span class="string">"余额不足"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PayState(<span class="number">200</span>, <span class="string">"支付成功"</span>, <span class="string">"支付金额:"</span> + amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>分别创建具体的支付方式</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliPay</span> <span class="keyword">extends</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"支付宝"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">queryBalance</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">900</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatPay</span> <span class="keyword">extends</span> <span class="title">Payment</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"微信支付"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">double</span> <span class="title">queryBalance</span><span class="params">(String uid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建支付方式管理类:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PaymentManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ALI_PAY = <span class="string">"AliPay"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JD_PAY = <span class="string">"JdPay"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WECHAT_PAY = <span class="string">"WechatPay"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PAY = ALI_PAY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Payment&gt; mapping = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        mapping.put(ALI_PAY, <span class="keyword">new</span> AliPay());</span><br><span class="line">        mapping.put(JD_PAY, <span class="keyword">new</span> JDPay());</span><br><span class="line">        mapping.put(WECHAT_PAY, <span class="keyword">new</span> WeChatPay());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据payKey获取支付方式</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> payKey</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Payment <span class="title">getPayment</span><span class="params">(String payKey)</span> </span>&#123;</span><br><span class="line">        Payment payment = mapping.get(payKey);</span><br><span class="line">        <span class="keyword">return</span> payment == <span class="keyword">null</span> ? mapping.get(DEFAULT_PAY) : payment;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>订单类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String uid;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> amount;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 完美地解决了 switch 的过程，不需要在代码逻辑中写 switch 了</span></span><br><span class="line"><span class="comment">    * 也不用写 if else</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PayState <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pay(PaymentManager.DEFAULT_PAY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PayState <span class="title">pay</span><span class="params">(String payKey)</span> </span>&#123;</span><br><span class="line">        Payment payment = PaymentManager.getPayment(payKey);</span><br><span class="line">        System.out.println(<span class="string">"欢迎使用"</span> + payment.getName());</span><br><span class="line">        System.out.println(<span class="string">"本次交易金额为:"</span> + amount + <span class="string">"，开始扣款..."</span>);</span><br><span class="line">        <span class="keyword">return</span> payment.pay(uid, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img data-src="https://chentianming11.github.io/images/design/delegate/61183186.png" alt="61183186"></p>
<h3 id="策略模式在-JDK-源码中的体现"><a href="#策略模式在-JDK-源码中的体现" class="headerlink" title="策略模式在 JDK 源码中的体现"></a>策略模式在 JDK 源码中的体现</h3><p>首先来看一个比较常用的比较器<code>Comparator</code>接口，我们看到的一个大家常用的<code>compare()</code>方法，就是一个策略抽象实现:<br><img data-src="https://chentianming11.github.io/images/design/delegate/61312317.png" alt="61312317"><br><code>Comparator</code>抽象下面有非常多的实现类，我们经常会把<code>Comparator</code>作为参数传入作 为排序策略，例如<code>Arrays</code>类的<code>parallelSort</code>方法等:<br><img data-src="https://chentianming11.github.io/images/design/delegate/61370759.png" alt="61370759"></p>
<h3 id="策略模式的优缺点"><a href="#策略模式的优缺点" class="headerlink" title="策略模式的优缺点"></a>策略模式的优缺点</h3><p>优点:</p>
<ol>
<li>策略模式符合开闭原则。</li>
<li>避免使用多重条件转移语句，如 <code>if...else...</code>语句、<code>switch</code>语句</li>
<li>使用策略模式可以提高算法的保密性和安全性。</li>
</ol>
<p>缺点:</p>
<ol>
<li>客户端必须知道所有的策略，并且自行决定使用哪一个策略类。</li>
<li>代码中会产生非常多策略类，增加维护难度。</li>
</ol>
<h2 id="委派模式与策略模式综合应用"><a href="#委派模式与策略模式综合应用" class="headerlink" title="委派模式与策略模式综合应用"></a>委派模式与策略模式综合应用</h2><p>现在，我们再来回顾一下，<code>DispatcherServlet</code>的委派逻辑，代码如下:<br><img data-src="https://chentianming11.github.io/images/design/delegate/61583586.png" alt="61583586"></p>
<p>这样的代码扩展性不太优雅，也不现实，因为我们实际项目中一定不止这几个 Controller， 往往是成千上万个 Controller，显然，我们不能写成千上万个 if…else… 。那么我们如何 来改造呢?小伙伴们一定首先就想到了策略模式，来看一下我是怎么优化的:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理器映射</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Handler&gt; handlerMapping = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 初始化处理器映射</span></span><br><span class="line">        handlerMapping.add(<span class="keyword">new</span> Handler()</span><br><span class="line">                .setController(<span class="keyword">new</span> MemberController())</span><br><span class="line">                .setMethod(MemberController.class.getMethod("getMemberById", String.class))</span><br><span class="line">                .setUrl(<span class="string">"/api/member/getMemberById"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        doDispatch(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 请求分发，根据不同的url，执行不同的逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> req</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resp</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doDispatch</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、获取用户请求的 url</span></span><br><span class="line">        <span class="comment">// 如果按照 J2EE 的标准、每个 url 对对应一个 Serlvet，url 由浏览器输入</span></span><br><span class="line">        String uri = req.getRequestURI();</span><br><span class="line">        <span class="comment">//2、Servlet 拿到 url 以后，要做权衡(要做判断，要做选择)</span></span><br><span class="line">        <span class="comment">// 根据用户请求的 URL，去找到这个 url 对应的某一个 java 类的方法</span></span><br><span class="line">        <span class="comment">//3、通过拿到的 URL 去 handlerMapping(我们把它认为是策略常量)</span></span><br><span class="line">        Handler handle = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Handler h : handlerMapping) &#123;</span><br><span class="line">            <span class="keyword">if</span> (uri.equals(h.getUrl())) &#123;</span><br><span class="line">                handle = h;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (handle == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有找到处理器，回404</span></span><br><span class="line">            resp.getWriter().write(<span class="string">"404 not Found"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4、将具体的任务分发给 Method(通过反射去调用其对应的方法)</span></span><br><span class="line">        Object result = handle.getMethod().invoke(handle.getController(), req.getParameter(<span class="string">"mid"</span>));</span><br><span class="line">        resp.getWriter().write(result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Data</span></span><br><span class="line">    <span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object controller;</span><br><span class="line">        <span class="keyword">private</span> Method method;</span><br><span class="line">        <span class="keyword">private</span> String url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码我结合了策略模式、工厂模式、单例模式。<br>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>delegate包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>十二、代理模式</title>
    <url>/posts/3869562206/</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>代理模式（Proxy Pattern）的定义非常简单，是指<strong>为其他对象提供一种代理，以控制对这个对象的访问。</strong> 代理对象在客户端和目标对象之间起到中介作用，代理模式属于结构型设计模式。</p>
<a id="more"></a>
<p>使用 代理模式主要有两个目的：<strong>一保护目标对象，二增强目标对象</strong>。下面我们来看一下代理模式的类结构图：<br><img data-src="https://chentianming11.github.io/images/design/proxy/44095781.png" alt="44095781"></p>
<p><code>Subject</code>是顶层接口，<code>RealSubject</code>是真实对象（被代理对象），<code>Proxy</code>是代理对象，代理对象持有被代理对象的引用，客户端调用代理对象方法，但是在代理对象前后增加一些处理。在代码中，我们想到代理，就会理解为是代码增强。其实就是在原本逻辑前后增加一些逻辑，而调用者无感知。代理模式属于结构型 模式，有静态代理和动态代理。</p>
<h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>静态代理的实现比较简单，代理类通过实现与目标对象相同的接口，并在类中维护一个代理对象。通过构造器塞入目标对象，赋值给代理对象，进而执行代理对象实现的接口方法，并实现前拦截，后拦截等所需的业务功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标对象实现的接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiyukai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BussinessInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标对象实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiyukai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bussiness</span> <span class="keyword">implements</span> <span class="title">BussinessInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行业务逻辑..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类，通过实现与目标对象相同的接口</span></span><br><span class="line"><span class="comment"> * 并维护一个代理对象，通过构造器传入实际目标对象并赋值</span></span><br><span class="line"><span class="comment"> * 执行代理对象实现的接口方法，实现对目标对象实现的干预</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jiyukai</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BussinessProxy</span> <span class="keyword">implements</span> <span class="title">BussinessInterface</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BussinessInterface bussinessImpl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BussinessProxy</span><span class="params">(BussinessInterface bussinessImpl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bussinessImpl = bussinessImpl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前拦截..."</span>);</span><br><span class="line">        bussinessImpl.execute();</span><br><span class="line">        System.out.println(<span class="string">"后拦截..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态代理的总结:</p>
<ul>
<li>优点：可以做到不对目标对象进行修改的前提下，对目标对象进行功能的扩展和拦截。</li>
<li>缺点：因为代理对象，需要实现与目标对象一样的接口，会导致代理类十分繁多，不易维护，同时一旦接口增加方法，则目标对象和代理类都需要维护。</li>
</ul>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>动态代理是指动态的在内存中构建代理对象（需要我们制定要代理的目标对象实现的接口类型），即利用JDK的API生成指定接口的对象，也称之为JDK代理或者接口代理。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkDynamicTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Business targetObject = <span class="keyword">new</span> Business();</span><br><span class="line">        <span class="comment">// 不需要编写代理类，动态创建代理对象</span></span><br><span class="line">        BusinessInterface proxyInstance = (BusinessInterface) Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),</span><br><span class="line">                targetObject.getClass().getInterfaces(),</span><br><span class="line">                (proxy, method, args1) -&gt; &#123;</span><br><span class="line">                    System.out.println(<span class="string">"前置处理！"</span>);</span><br><span class="line">                    Object o = method.invoke(targetObject, args1);</span><br><span class="line">                    System.out.println(<span class="string">"后置处理！"</span>);</span><br><span class="line">                    <span class="keyword">return</span> o;</span><br><span class="line">                &#125;);</span><br><span class="line">        proxyInstance.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>动态代理的总结</strong>：</p>
<ul>
<li>优点：动态创建代理类,免去了编写很多代理类的烦恼，同时接口增加方法也无需再维护目标对象和代理对象，只需在事件处理器中添加对方法的判断即可。</li>
<li>缺点：目标对象一定要实现接口，否则无法使用JDK动态代理。</li>
</ul>
<h3 id="JDK动态代理实现"><a href="#JDK动态代理实现" class="headerlink" title="JDK动态代理实现"></a>JDK动态代理实现</h3><p>我们都知道 JDK Proxy 采用字节重组，重新生的对象来替代原始的对象以达到动态代理的目的。JDK Proxy 生成对象的步骤如下：</p>
<ol>
<li>拿到被代理对象的引用，并且获取到它的所有的接口，反射获取。</li>
<li>JDK Proxy 类重新生成一个新的类、同时新的类要实现被代理类所有实现的所有的接口。</li>
<li>动态生成 Java 代码，把新加的业务逻辑方法由一定的逻辑代码去调用（在代码中体现）。</li>
<li>编译新生成的 Java 代码.class。</li>
<li>再重新加载到 JVM 中运行。</li>
</ol>
<p>以上这个过程就叫字节码重组。JDK 中有一个规范，在<code>ClassPath</code>下只要是<code>$</code>开头的<code>class</code>文件一般都是自动生成的。我们可以从内存中的对象字节码通过文件流输出到一个新的<code>class</code>文件，然后，利用 反编译工具查看<code>class</code>的源代码。<br><img data-src="https://chentianming11.github.io/images/design/proxy/70880224.png" alt="70880224"></p>
<p><code>$proxy.class</code>源码如下：<br><img data-src="https://chentianming11.github.io/images/design/proxy/71032344.png" alt="71032344"></p>
<p><code>$Proxy0</code>继承了<code>Proxy</code>类，同时还实现了我们的<code>BusinessInterface</code>接口，而且重写了<code>execute()</code>等方法。而且在静态块中用反射查找到了目标对象的所有方法，而且保存了所有方法的引用，在重写的方法用反射调用目标对象的方法。</p>
<h4 id="手写JDK动态代理核心实现"><a href="#手写JDK动态代理核心实现" class="headerlink" title="手写JDK动态代理核心实现"></a>手写JDK动态代理核心实现</h4><p><img data-src="https://chentianming11.github.io/images/design/proxy/78388571.png" alt="78388571"></p>
<h3 id="cglib动态代理使用"><a href="#cglib动态代理使用" class="headerlink" title="cglib动态代理使用"></a>cglib动态代理使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibDynamicTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用cglib生成代理对象</span></span><br><span class="line">        BusinessNoInterface businessNoInterface = (BusinessNoInterface) Enhancer.create(</span><br><span class="line">                BusinessNoInterface<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">MethodInterceptor</span>() </span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"前置拦截"</span>);</span><br><span class="line">                        Object result = proxy.invokeSuper(obj, args);</span><br><span class="line">                        System.out.println(<span class="string">"后置拦截"</span>);</span><br><span class="line">                        <span class="keyword">return</span> result;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="comment">// 使用代理对象执行方法</span></span><br><span class="line">        businessNoInterface.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>CGLib 代理的目标对象不需要实现任何接口，它是通过动态继承目标类实现的动态代理。</strong><br>利用 cglib 的代理类可以将内存中的 class 文件写入本地磁盘:<br><img data-src="https://chentianming11.github.io/images/design/proxy/85345036.png" alt="85345036"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">//利用 cglib 的代理类可以将内存中的 class 文件写入本地磁盘</span></span><br><span class="line">       System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY,</span><br><span class="line">               CglibDynamicTest.class.getResource("").getPath());</span><br></pre></td></tr></table></figure>

<h4 id="cglib原理分析"><a href="#cglib原理分析" class="headerlink" title="cglib原理分析"></a>cglib原理分析</h4><p>代理类部分源码：<br><img data-src="https://chentianming11.github.io/images/design/proxy/372955.png" alt="372955"><br><img data-src="https://chentianming11.github.io/images/design/proxy/83430770.png" alt="83430770"></p>
<p>我们通过代理类的源码可以看到，代理类会获得所有在父类继承来的方法，并且会有<code>MethodProxy</code>与之对应。<strong>代理类还会生成一个个直接指向父类进行调用的方法</strong></p>
<p>调用过程：</p>
<ol>
<li>代理对象用<code>this.execute()</code>方法。</li>
<li>调用拦截器<code>MethodInterceptor</code>的拦截方法。</li>
<li><code>methodProxy.invokeSuper</code></li>
<li><code>CGLIB$execute$0Proxy</code>调用被代理对象<code>execute()</code>方法。</li>
</ol>
<p>此时，我们发现拦截器<code>MethodInterceptor</code>中就是由<code>MethodProxy</code>的<code>invokeSupe</code>方法调用代理方法的，<code>MethodProxy</code>非常关键。</p>
<p>代理类部分源码：<br><img data-src="https://chentianming11.github.io/images/design/proxy/81127837.png" alt="81127837"></p>
<p>MethodProxy源码：<br><img data-src="https://chentianming11.github.io/images/design/proxy/82053615.png" alt="82053615"><br><img data-src="https://chentianming11.github.io/images/design/proxy/82944100.png" alt="82944100"></p>
<p>CGLib 动态代理执行代理方法效率之所以比JDK的高是因为<code>Cglib</code>采用了<code>FastClass</code>机制，它的原理简单来说就是：为代理类和被代理类各生成一个<code>Class</code>，这个<code>Class</code>会为代理类或被代理类的方法分配一个 <code>index(int 类型)</code>。这个 index 当做一个入参，<code>FastClass</code>就可以直接定位要调用的方法直接进行调用，这样省去了反射调用，所以调用效率比 JDK动态代理通过反射调用高。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="CGLib-和-JDK-动态代理对比"><a href="#CGLib-和-JDK-动态代理对比" class="headerlink" title="CGLib 和 JDK 动态代理对比"></a>CGLib 和 JDK 动态代理对比</h4><p>1.JDK 动态代理是实现了被代理对象的接口，CGLib 是继承了被代理对象。<br>2.JDK 和 CGLib 都是在运行期生成字节码，JDK 是直接写 Class 字节码，CGLib 使用 ASM框架写 Class 字节码，Cglib 代理实现更复杂，生成代理类比 JDK 效率低。<br>3.JDK 调用代理方法，是通过反射机制调用，CGLib 是通过 FastClass 机制直接调用方法，CGLib 执行效率更高。</p>
<h4 id="Spring-中的代理选择原则"><a href="#Spring-中的代理选择原则" class="headerlink" title="Spring 中的代理选择原则"></a>Spring 中的代理选择原则</h4><ol>
<li><p>当 Bean 有实现接口时，Spring 就会用 JDK 的动态代理</p>
</li>
<li><p>当 Bean 没有实现接口时，Spring 选择 CGLib</p>
</li>
<li><p>Spring 可以通过配置强制使用 CGLib，只需在 Spring 的配置文件中加入如下代码：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">`</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="静态代理和动态的本质区别"><a href="#静态代理和动态的本质区别" class="headerlink" title="静态代理和动态的本质区别"></a>静态代理和动态的本质区别</h4><ol>
<li>静态代理只能通过手动完成代理操作，如果被代理类增加新的方法，代理类需要同步新增，违背开闭原则。</li>
<li>动态代理采用在运行时动态生成代码的方式，取消了对被代理类的扩展限制，遵循开闭原则。</li>
<li>若动态代理要对目标类的增强逻辑扩展，结合策略模式，只需要新增策略类便可完成，无需修改代理类的代码。</li>
</ol>
<h4 id="代理模式的优缺点"><a href="#代理模式的优缺点" class="headerlink" title="代理模式的优缺点"></a>代理模式的优缺点</h4><p>使用代理模式具有以下几个优点：</p>
<ol>
<li>代理模式能将代理对象与真实被调用的目标对象分离。</li>
<li>一定程度上降低了系统的耦合度，扩展性好。</li>
<li>可以起到保护目标对象的作用。</li>
<li>可以对目标对象的功能增强。</li>
</ol>
<p>当然，代理模式也是有缺点的：</p>
<ol>
<li>代理模式会造成系统设计中类的数量增加。</li>
<li>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢。</li>
<li>增加了系统的复杂度。</li>
</ol>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>proxy包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>十四、模板模式和适配器模式</title>
    <url>/posts/2184398774/</url>
    <content><![CDATA[<h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>模板模式通常又叫模板方法模式(Template Method Pattern)是指定义一个算法的骨 架，并允许子类为一个或者多个步骤提供实现。</strong>模板方法使得子类可以在不改变算法结 构的情况下，重新定义算法的某些步骤，属于行为性设计模式。</p>
<a id="more"></a>
<p>模板方法适用于以下应用场景:</p>
<ol>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</li>
<li>各子类中公共的行为被提取出来并集中到一个公共的父类中，从而避免代码重复。</li>
</ol>
<p>我们还是以课程创建流程为例:发布预习资料–&gt;制作课件 PPT–&gt;在线直播 –&gt;提交课堂笔记–&gt;提交源码–&gt;布置作业–&gt;检查作业。</p>
<ul>
<li><p>首先我们来创建<code>NetworkCourse</code>抽象类:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkCourse</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建课程 -- 定义算法骨架</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">createCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、发布预习资料</span></span><br><span class="line">        <span class="keyword">this</span>.postPreResource();</span><br><span class="line">        <span class="comment">//2、制作 PPT 课件</span></span><br><span class="line">        <span class="keyword">this</span>.createPPT();</span><br><span class="line">        <span class="comment">//3、在线直播</span></span><br><span class="line">        <span class="keyword">this</span>.liveVideo();</span><br><span class="line">        <span class="comment">//4、提交课件、课堂笔记</span></span><br><span class="line">        <span class="keyword">this</span>.postNote();</span><br><span class="line">        <span class="comment">//5、提交源码</span></span><br><span class="line">        <span class="keyword">this</span>.postSource();</span><br><span class="line">        <span class="comment">//6、布置作业，有些课是没有作业，有些课是有作业的</span></span><br><span class="line">        <span class="comment">// 如果有作业的话，检查作业，如果没作业，完成了</span></span><br><span class="line">        <span class="keyword">if</span> (needHomework()) &#123;</span><br><span class="line">            checkHomework();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 7. 收集课后反馈</span></span><br><span class="line">        <span class="keyword">this</span>.feedback();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">postPreResource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发布预习资料"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">createPPT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"制作 PPT 课件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">liveVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在线直播"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">postNote</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"提交课件、课堂笔记"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">postSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"提交源码"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 钩子方法:实现流程的微调</span></span><br><span class="line"><span class="comment">    * 是否有作业</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needHomework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 默认空实现</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkHomework</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">feedback</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  <strong>设计钩子方法的主要目的是用来干预执行流程，使得我们控制行为流程更加灵活，更符合实际业 务的需求。钩子方法的返回值一般为适合条件分支语句的返回值(如 boolean、int 等)。</strong></p>
</li>
<li><p>具体的course类</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaCourse</span> <span class="keyword">extends</span> <span class="title">NetworkCourse</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> needHomeworkFlag;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JavaCourse</span><span class="params">(<span class="keyword">boolean</span> needHomeworkFlag)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.needHomeworkFlag = needHomeworkFlag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needHomework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> needHomeworkFlag;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkHomework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"检查Java作业"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">feedback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Java反馈收集"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PythonCourse</span> <span class="keyword">extends</span> <span class="title">NetworkCourse</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * python没有课后作业</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">feedback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"python反馈收集"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img data-src="https://chentianming11.github.io/images/design/template-adapter/76568891.png" alt="76568891"></p>
<h3 id="利用模板模式重构-JDBC-操作业务场景"><a href="#利用模板模式重构-JDBC-操作业务场景" class="headerlink" title="利用模板模式重构 JDBC 操作业务场景"></a>利用模板模式重构 JDBC 操作业务场景</h3><p>创建一个模板类<code>JdbcTemplate</code>，封装所有的<code>JDBC</code>操作。以查询为例，每次查询的表不 同，返回的数据结构也就不一样。我们针对不同的数据，都要封装成不同的实体对象。 而每个实体封装的逻辑都是不一样的，但封装前和封装后的处理流程是不变的，因此， 我们可以使用模板方法模式来设计这样的业务场景。</p>
<ul>
<li><p>先创建约束 ORM 逻辑的接口 RowMapper:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RowMapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 行映射处理</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> rowNum</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">T <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>再创建封装了所有处理流程的抽象类 JdbcTemplate:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JdbcTemplate</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">executeQuery</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper, Object[] params)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、获取连接</span></span><br><span class="line">            Connection conn = <span class="keyword">this</span>.getConnection();</span><br><span class="line">            <span class="comment">//2、创建语句集</span></span><br><span class="line">            PreparedStatement pstm = <span class="keyword">this</span>.createPrepareStatement(conn, sql);</span><br><span class="line">            <span class="comment">//3、执行语句集</span></span><br><span class="line">            ResultSet rs = <span class="keyword">this</span>.executeQuery(pstm, params);</span><br><span class="line">            <span class="comment">//4、处理结果集</span></span><br><span class="line">            List&lt;T&gt; result = <span class="keyword">this</span>.paresResultSet(rs, rowMapper);</span><br><span class="line">            <span class="comment">//5、关闭结果集</span></span><br><span class="line">            <span class="keyword">this</span>.closeResultSet(rs);</span><br><span class="line">            <span class="comment">//6、关闭语句集</span></span><br><span class="line">            <span class="keyword">this</span>.closeStatement(pstm);</span><br><span class="line">            <span class="comment">//7、关闭连接</span></span><br><span class="line">            <span class="keyword">this</span>.closeConnection(conn);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">closeConnection</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">closeStatement</span><span class="params">(PreparedStatement pstm)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        pstm.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">closeResultSet</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        rs.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">paresResultSet</span><span class="params">(ResultSet rs, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> rowNum = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">            result.add(rowMapper.mapRow(rs, rowNum++));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> ResultSet <span class="title">executeQuery</span><span class="params">(PreparedStatement pstm, Object[] params)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">            pstm.setObject(i, params[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pstm.executeQuery();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement <span class="title">createPrepareStatement</span><span class="params">(Connection conn, String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> conn.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dataSource.getConnection();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建实体对象 Member 类:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Accessors</span>(chain = <span class="keyword">true</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Member</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> String nickName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库操作类 MemberDao:</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemberDao</span> <span class="keyword">extends</span> <span class="title">JdbcTemplate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MemberDao</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Member&gt; <span class="title">selectAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from t_member"</span>;</span><br><span class="line">        List&lt;Member&gt; members = executeQuery(sql, (rs, rowNum) -&gt; &#123;</span><br><span class="line">            Member member = <span class="keyword">new</span> Member()</span><br><span class="line">                    .setUsername(rs.getString(<span class="string">"username"</span>))</span><br><span class="line">                    .setAge(rs.getInt(<span class="string">"age"</span>))</span><br><span class="line">                    .setNickName(rs.getString(<span class="string">"nick_name"</span>))</span><br><span class="line">                    .setPassword(rs.getString(<span class="string">"password"</span>));</span><br><span class="line">            <span class="keyword">return</span> member;</span><br><span class="line">        &#125;, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">return</span> members;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="模板模式在源码中的体现"><a href="#模板模式在源码中的体现" class="headerlink" title="模板模式在源码中的体现"></a>模板模式在源码中的体现</h3><p>有一个每天都在用的<code>HttpServlet</code>，有三个方法<code>service()</code>和<code>doGet()</code>、<code>doPost()</code>方法，都是模板方法的抽象实现。<br>在<code>MyBatis</code>框架也有一些经典的应用，我们来一下<code>BaseExecutor</code>类，它是一个基础的<code>SQL</code>执行类，实现了大部分的<code>SQL</code>执行逻辑，然后把几个方法交给子类定制化完成，源码如下:<br><img data-src="https://chentianming11.github.io/images/design/template-adapter/78988674.png" alt="78988674"></p>
<h3 id="模板模式的优缺点"><a href="#模板模式的优缺点" class="headerlink" title="模板模式的优缺点"></a>模板模式的优缺点</h3><p>优点:</p>
<ol>
<li>利用模板方法将相同处理逻辑的代码放到抽象父类中，可以提高代码的复用性。</li>
<li>将不同的代码不同的子类中，通过对子类的扩展增加新的行为，提高代码的扩展性。</li>
<li>把不变的行为写在父类上，去除子类的重复代码，提供了一个很好的代码复用平台， 符合开闭原则。</li>
</ol>
<p>缺点:</p>
<ol>
<li>类数目的增加，每一个抽象类都需要一个子类来实现，这样导致类的个数增加。</li>
<li>类数量的增加，间接地增加了系统实现的复杂度。</li>
<li>继承关系自身缺点，如果父类添加新的抽象方法，所有子类都要改一遍。</li>
</ol>
<p>模板方法模式比较简单，只要勤加练习， 多结合业务场景思考问题，就能够把模板方法模式运用好。</p>
<h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="适配器模式的应用场景"><a href="#适配器模式的应用场景" class="headerlink" title="适配器模式的应用场景"></a>适配器模式的应用场景</h3><p>适配器模式(Adapter Pattern)是指将一个类的接口转换成客户期望的另一个接口，使 原本的接口不兼容的类可以一起工作，属于结构型设计模式。<br>适配器适用于以下几种业务场景:</p>
<ol>
<li>已经存在的类，它的方法和需求不匹配(方法结果相同或相似)的情况。</li>
<li>适配器模式不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不 同厂家造成功能类似而接口不相同情况下的解决方案。有点亡羊补牢的感觉。</li>
</ol>
<p>在中国民用电都是 220V 交流电，但我们手机使用的锂电池使用的 5V 直流电。因此，我 们给手机充电时就需要使用电源适配器来进行转换。下面我们有代码来还原这个生活场 景，创建 AC220 类，表示 220V 交流电:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 现有支持AC220的接口</span></span><br><span class="line"><span class="comment"> * 被适配接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAC220</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputAC220V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AC220</span> <span class="keyword">implements</span> <span class="title">IAC220</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputAC220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> output = <span class="number">220</span>;</span><br><span class="line">        System.out.println(<span class="string">"输出交流电"</span> + output + <span class="string">"V"</span>);</span><br><span class="line">        <span class="keyword">return</span> output;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标接口</span></span><br><span class="line"><span class="comment"> * 新需求要求支持DC5V的接口</span></span><br><span class="line"><span class="comment"> * 但是DC5V可以通过AC220V转换得到</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDC5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器实现目标接口，同时持有被适配对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/4/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DC5VAdapter</span> <span class="keyword">implements</span> <span class="title">IDC5</span> </span>&#123;</span><br><span class="line">    IAC220 iac220;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DC5VAdapter</span><span class="params">(IAC220 iac220)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.iac220 = iac220;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">outputDC5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = iac220.outputAC220V();</span><br><span class="line">        <span class="keyword">int</span> r = i / <span class="number">44</span>;</span><br><span class="line">        System.out.println(<span class="string">"输出直流"</span> + r + <span class="string">"V"</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img data-src="https://chentianming11.github.io/images/design/template-adapter/59584429.png" alt="59584429"></p>
<h3 id="重构第三登录自由适配的业务场景"><a href="#重构第三登录自由适配的业务场景" class="headerlink" title="重构第三登录自由适配的业务场景"></a>重构第三登录自由适配的业务场景</h3><p>下面我们来一个实际的业务场景，利用适配模式来解决实际问题。年纪稍微大一点的小 伙伴一定经历过这样一个过程。我们很早以前开发的老系统应该都有登录接口，但是随 着业务的发展和社会的进步，单纯地依赖用户名密码登录显然不能满足用户需求了。现 在，我们大部分系统都已经支持多种登录方式，如 QQ 登录、微信登录、手机登录、微 博登录等等，同时保留用户名密码的登录方式。虽然登录形式丰富了，但是登录后的处理逻辑可以不必改，同样是将登录状态保存到 session，遵循开闭原则。<em>其他新增的登录方式，可以复用之前登录的逻辑</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SiginService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username * <span class="doctag">@param</span> password * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultMsg <span class="title">regist</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ResultMsg(<span class="number">200</span>, <span class="string">"注册成功"</span>, <span class="keyword">new</span> Member());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username * <span class="doctag">@param</span> password * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultMsg <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为了遵循开闭原则，老系统的代码我们不会去修改。</strong></p>
<ul>
<li><p>现在需要支持第三方登录 – 新的目标接口</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第三方登录接口 -- 目标接口</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPassportForThird</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * QQ登录</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">ResultMsg <span class="title">loginForQQ</span><span class="params">(String id)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 微信登录</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function">ResultMsg <span class="title">loginForWechat</span><span class="params">(String id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第三方登录适配器 - 实现兼容 PassportForThirdAdapter</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 第三方登录适配器</span></span><br><span class="line"><span class="comment">* 实现目标接口，持有被适配对象的引用</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassportForThirdAdapter</span> <span class="keyword">implements</span> <span class="title">IPassportForThird</span> </span>&#123;</span><br><span class="line">    SiginService siginService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PassportForThirdAdapter</span><span class="params">(SiginService siginService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.siginService = siginService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * QQ登录</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultMsg <span class="title">loginForQQ</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、openId 是全局唯一，我们可以把它当做是一个用户名(加长)</span></span><br><span class="line">        <span class="comment">// 2、密码默认为 QQ_EMPTY</span></span><br><span class="line">        <span class="comment">// 3、注册(在原有系统里面创建一个用户)</span></span><br><span class="line">        <span class="comment">//4、调用原来的登录方法</span></span><br><span class="line">        ResultMsg resultMsg = siginService.login(<span class="string">"12345"</span>, <span class="string">"1111"</span>);</span><br><span class="line">        <span class="keyword">return</span> resultMsg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 微信登录</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultMsg <span class="title">loginForWechat</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 一堆微信登录的逻辑</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ResultMsg resultMsg = siginService.login(<span class="string">"12345"</span>, <span class="string">"1111"</span>);</span><br><span class="line">        <span class="keyword">return</span> resultMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  每种登录方式都有各自的逻辑，考虑单一性原则。将不同的适配逻辑分离，同时使用策略模式选择不同的适配器执行处理。</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> SiginService siginService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginAdapter</span><span class="params">(SiginService siginService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.siginService = siginService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 兼容校验</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> adapter</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">support</span><span class="params">(Object adapter)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 登录接口</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ResultMsg <span class="title">login</span><span class="params">(Object... params)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginForQQAdapter</span> <span class="keyword">extends</span> <span class="title">LoginAdapter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LoginForQQAdapter</span><span class="params">(SiginService siginService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(siginService);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 兼容校验</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> adapter</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">support</span><span class="params">(Object adapter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> adapter <span class="keyword">instanceof</span> LoginForQQAdapter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 登录接口</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultMsg <span class="title">login</span><span class="params">(Object... params)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、openId 是全局唯一，我们可以把它当做是一个用户名(加长)</span></span><br><span class="line">        <span class="comment">// 2、密码默认为 QQ_EMPTY</span></span><br><span class="line">        <span class="comment">// 3、注册(在原有系统里面创建一个用户)</span></span><br><span class="line">        <span class="comment">//4、调用原来的登录方法</span></span><br><span class="line">        ResultMsg resultMsg = siginService.login(<span class="string">"12345"</span>, <span class="string">"1111"</span>);</span><br><span class="line">        <span class="keyword">return</span> resultMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassportForThirdService</span> <span class="keyword">implements</span> <span class="title">IPassportForThird</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SiginService siginService;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PassportForThirdService</span><span class="params">(SiginService siginService)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.siginService = siginService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * QQ登录</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultMsg <span class="title">loginForQQ</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> processLogin(LoginForQQAdapter<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 微信登录</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResultMsg <span class="title">loginForWechat</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> processLogin(LoginForWechatAdapter<span class="class">.<span class="keyword">class</span>, <span class="title">id</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ResultMsg <span class="title">processLogin</span><span class="params">(Class&lt;? extends LoginAdapter&gt; clz, Object... params)</span> </span>&#123;</span><br><span class="line">        Constructor&lt;? extends LoginAdapter&gt; constructor = clz.getConstructor(SiginService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        LoginAdapter loginAdapter = constructor.newInstance(siginService);</span><br><span class="line">        <span class="keyword">if</span> (loginAdapter.support(loginAdapter)) &#123;</span><br><span class="line">            <span class="keyword">return</span> loginAdapter.login(params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img data-src="https://chentianming11.github.io/images/design/template-adapter/69005337.png" alt="69005337"></p>
<h3 id="适配器模式在源码中的体现"><a href="#适配器模式在源码中的体现" class="headerlink" title="适配器模式在源码中的体现"></a>适配器模式在源码中的体现</h3><p><code>Spring</code>中适配器模式也应用得非常广泛，例如:<code>SpringAOP</code>中的<code>AdvisorAdapter</code>类， 它有三个实现类 <code>MethodBeforeAdviceAdapter</code>、<code>AfterReturningAdviceAdapter</code> 和 <code>ThrowsAdviceAdapter</code>，先来看顶层接口<code>AdvisorAdapter</code>的源代码:<br><img data-src="https://chentianming11.github.io/images/design/template-adapter/62911191.png" alt="62911191"></p>
<p>再看<code>MethodBeforeAdviceAdapter</code>类:<br><img data-src="https://chentianming11.github.io/images/design/template-adapter/62951178.png" alt="62951178"></p>
<p>Spring 会根据不同的<code>AOP</code>配置来确定使用对应的<code>Advice</code>，跟策略模式不同的一个方法可以同时拥有多个<code>Advice</code>。</p>
<p>下面再来看一个 <code>SpringMVC</code>中的<code>HandlerAdapter</code>类，它也有多个子类，类图如下:<br><img data-src="https://chentianming11.github.io/images/design/template-adapter/63011975.png" alt="63011975"></p>
<h3 id="适配器模式的优缺点"><a href="#适配器模式的优缺点" class="headerlink" title="适配器模式的优缺点"></a>适配器模式的优缺点</h3><p>优点:</p>
<ol>
<li>能提高类的透明性和复用，现有的类复用但不需要改变。</li>
<li>目标类和适配器类解耦，提高程序的扩展性。</li>
<li>在很多业务场景中符合开闭原则。</li>
</ol>
<p>缺点:</p>
<ol>
<li>适配器编写过程需要全面考虑，可能会增加系统的复杂性。</li>
<li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li>
</ol>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>template和adapter包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>四、工厂模式</title>
    <url>/posts/4277255022/</url>
    <content><![CDATA[<h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><a id="more"></a>

<p><strong>假设你有一个披萨店，你的代码可能这么写</strong>：<br><img data-src="https://chentianming11.github.io/images/design/factory/50817134.png" alt="50817134"></p>
<p><strong>当更多的披萨类型的时候，必须修改代码，从而创建适合的披萨类型</strong>：<br><img data-src="https://chentianming11.github.io/images/design/factory/50996013.png" alt="50996013"></p>
<h4 id="封装创建对象的代码"><a href="#封装创建对象的代码" class="headerlink" title="封装创建对象的代码"></a>封装创建对象的代码</h4><ul>
<li>将创建对象的代码从orderPizza()中抽离。</li>
<li>将这部分代码搬到另一个对象中，这个对象只负责如何创建pizza。<br>我们称这个新对象为工厂。工厂处理创建对象的细节。当需要一个披萨时，将让披萨工厂做一个。</li>
</ul>
<p><img data-src="https://chentianming11.github.io/images/design/factory/51455140.png" alt="51455140"></p>
<h4 id="重做PizzaStore类"><a href="#重做PizzaStore类" class="headerlink" title="重做PizzaStore类"></a>重做PizzaStore类</h4><p><img data-src="https://chentianming11.github.io/images/design/factory/51626977.png" alt="51626977"></p>
<h4 id="定义简单工厂"><a href="#定义简单工厂" class="headerlink" title="定义简单工厂"></a>定义简单工厂</h4><p>简单工厂其实不是一个设计模式，反而比较像是一种编程习惯。</p>
<p><img data-src="https://chentianming11.github.io/images/design/factory/52286337.png" alt="52286337"></p>
<h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p>披萨店进行扩张，实行加盟模式。每家加盟店都可能想要提供不同风味的披萨。<br><img data-src="https://chentianming11.github.io/images/design/factory/54006355.png" alt="54006355"></p>
<p><strong>第一个做法</strong><br>如果利用SimplePizzaFactory，写出三种不同的工厂，分别是NYPizzaFactory、ChicagoPizzaFactory、CaliforniaPizzaFactory。那么各地加盟店都有合适的工厂使用。<br><img data-src="https://chentianming11.github.io/images/design/factory/54210336.png" alt="54210336"></p>
<p><strong>多一些质量控制</strong><br>在推广SimpleFactory时，你发现加盟店的确实采用你的工厂创建披萨，但是其他部分，却开始采用他们自创的流程：烘烤做法有差异，不要切片，使用其他厂商的盒子等。<br>在我们之前的SimpleFactory之前，制作披萨的代码绑在PizzaStore里，但这么做并没有弹性。<br>有个做法可以让披萨制作活动局限于PizzaStore中，而同时又能让这些加盟店依然可以自由的制作该区域的风味。所要做的事情就是将createPizza()方法放回到PizzaStore中，不过要将它定义为抽象方法，然后为每个区域创建一个PizzaStore的子类。<br><img data-src="https://chentianming11.github.io/images/design/factory/58157933.png" alt="58157933"></p>
<p>类图：<br><img data-src="https://chentianming11.github.io/images/design/factory/58262465.png" alt="58262465"><br>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。这样，客户端程序中关于超类的代码就和子类对象创建代码解耦了。</p>
<p><strong>认识工厂方法</strong><br>所有工厂模式都是用来封装对象的创建。工厂方法模式通过让子类决定改创建的对象是什么，来达到将对象的创建过程封装的目的。<br><img data-src="https://chentianming11.github.io/images/design/factory/59545558.png" alt="59545558"></p>
<p><strong>定义工厂方法模式</strong><br>定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。<br><img data-src="https://chentianming11.github.io/images/design/factory/65255049.png" alt="65255049"></p>
<h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p><strong>认识抽象工厂</strong><br>要如何确保每家加盟店使用高质量的原料？你打算建造一家生产原料的工厂，并将原料送往各家加盟店。加盟店位于不同区域，纽约的红酱料和芝加哥的红酱料是不一样的。<br>现在，我们要建造一个工厂来生产原料，这个工厂将负责创建原料家族中的每一种原料。</p>
<ol>
<li>为每个区域建造一个工厂。你需要创建一个继承自PizzaIngredientFactory的子类来实现每一个创建方法。</li>
<li>实现一组原料类供工厂使用</li>
<li>然后，你仍然需要将这一切组织起来，将新的原料工厂整合进PizzaStore中。</li>
</ol>
<p><strong>定义抽象工厂</strong><br>提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。<br>抽象工厂允许客户端使用抽象接口来创建一组相关产品，而不需要关心具体产品是什么。这样客户就从具体产品中解耦。</p>
<p><img data-src="https://chentianming11.github.io/images/design/factory/66073710.png" alt="66073710"></p>
<p>源码：<a href="https://github.com/chentianming11/design-pattern" target="_blank" rel="noopener">https://github.com/chentianming11/design-pattern</a><br>factory包!</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解zookeeper-zookeeper基本介绍及使用</title>
    <url>/posts/4128331822/</url>
    <content><![CDATA[<p><strong>zookeeper是一种为分布式应用所设计的高可用、高性能且一致的开源协调服务，主要可用来实现分布式锁、配置维护、分布式消息队列、分布式通知/协调等</strong>。</p>
<p>zookeeper设计了一种全新的数据结构(<code>Znode</code>)，并且在<code>Znode</code>上定义了一些原语（关于该数据结构的一些操作）。因为zookeeper是工作在一个分布式的环境下，所以还需要一个通知机制(<strong>watch机制</strong>)来将消息通过网络发送给分布式应用程序。总结一下，<strong>zookeeper所提供的服务主要是通过：Znode数据结构+原语+watch机制，三个部分来实现的</strong>，那么接下来就从这三个方面来简单介绍一下zookeeper。</p>
<a id="more"></a>

<p>源码：<a href="https://github.com/chentianming11/zookeeper-demo" target="_blank" rel="noopener">https://github.com/chentianming11/zookeeper-demo</a></p>
<h2 id="zookeeper数据模型"><a href="#zookeeper数据模型" class="headerlink" title="zookeeper数据模型"></a>zookeeper数据模型</h2><h3 id="Znode"><a href="#Znode" class="headerlink" title="Znode"></a>Znode</h3><p>zookeeper拥有一个层次的命名空间，这个和标准的文件系统非常相似，如下图所示。<br><img data-src="../../../public/images/zookeeper/znode.png" alt=""><br><img data-src="../../../public/images/zookeeper/znode-file.png" alt=""></p>
<p>从图中我们可以看出，zookeeper的数据模型在结构上和标准文件系统的非常相似，都是采用<strong>树形层次结构</strong>，zookeeper树中的每个节点被称为—<code>Znode</code>。和文件系统的目录树一样，zookeeper树中的每个节点可以拥有子节点。当然，也有不同之处：</p>
<ul>
<li><p>引用方式</p>
<p>Zonde通过路径引用，如同Unix中的文件路径。<strong>路径必须是绝对且唯一的</strong>，因此他们必须由斜杠字符来开头，并且每一个路径只有一个表示。</p>
</li>
<li><p>Znode结构</p>
<p>zookeeper命名空间中的Znode，兼具文件和目录两种特点。<strong>既像文件一样维护着数据、元信息、ACL、时间戳等数据结构，又像目录一样可以作为路径标识的一部分</strong>。图中的每个节点称为一个Znode。 每个Znode由3部分组成:</p>
<ul>
<li><p>stat：状态信息, 描述该Znode的版本, 权限等信息；</p>
</li>
<li><p>data：与该Znode关联的数据；</p>
</li>
<li><p>children：该Znode下的子节点</p>
<p>zookeeper虽然可以关联一些数据，但并没有被设计为常规的数据库或者大数据存储，相反的是，它用来管理调度数据，比如分布式应用中的配置文件信息、状态信息、汇集位置等等。这些数据的共同特性就是它们都是很小的数据，通常以KB为大小单位。zookeeper的服务器和客户端都被设计为严格检查并限制每个Znode的数据大小至多1M，但常规使用中应该远小于此值。</p>
</li>
</ul>
</li>
<li><p>数据访问</p>
<p>  zookeeper中的每个节点存储的数据要被原子性的操作。也就是说读操作将获取与节点相关的所有数据，写操作也将替换掉节点的所有数据。另外，每一个节点都拥有自己的ACL(访问控制列表)，这个列表规定了用户的权限，即限定了特定用户对目标节点可以执行的操作。</p>
</li>
<li><p>节点类型</p>
<p><strong>zookeeper中的节点有两种，分别为临时节点和永久节点。节点的类型在创建时即被确定，并且不能改变</strong>。</p>
<ul>
<li><strong>临时节点</strong>：<em>该节点的生命周期依赖于创建它们的会话。一旦会话(Session)结束，临时节点将被自动删除</em>，当然可以也可以手动删除。虽然每个临时的Znode都会绑定到一个客户端会话，但他们对所有的客户端还是可见的。另外，<em>zookeeper的临时节点不允许拥有子节点</em>。</li>
<li><strong>永久节点</strong>：该节点的生命周期不依赖于会话，并且只有在客户端显示执行删除操作的时候，他们才能被删除。</li>
</ul>
</li>
<li><p>顺序节点</p>
<p><strong>当创建Znode的时候，用户可以请求在zookeeper的路径结尾添加一个递增的计数</strong>。这个计数对于此节点的父节点来说是唯一的，它的格式为”%10d”(10位数字，没有数值的数位用0补充，例如”0000000001”)。当计数值大于232-1时，计数器将溢出。</p>
</li>
<li><p>监视器</p>
<p>客户端可以在节点上设置watch，我们称之为监视器。<strong>当节点状态发生改变时(Znode的增、删、改)将会触发watch所对应的操作</strong>。当watch被触发时，zookeeper将会向客户端发送且仅发送一条通知，因此watch只能被触发一次，这样可以减少网络流量。</p>
</li>
</ul>
<h3 id="zookeeper中的时间"><a href="#zookeeper中的时间" class="headerlink" title="zookeeper中的时间"></a>zookeeper中的时间</h3><p>zookeeper有多种记录时间的形式，其中包含以下几个主要属性：</p>
<ul>
<li><p>Zxid</p>
<p>致使zookeeper节点状态改变的每一个操作都将使节点接收到一个Zxid格式的时间戳，并且这个时间戳全局有序。也就是说，也就是说，<strong>每个对节点的改变都将产生一个唯一的Zxid</strong>。如果Zxid1的值小于Zxid2的值，那么Zxid1所对应的事件发生在Zxid2所对应的事件之前。实际 上，zookeeper的每个节点维护者三个Zxid值，为别为：cZxid、mZxid、pZxid。</p>
<ul>
<li>cZxid：节点创建时间所对应的Zxid格式时间戳</li>
<li>mZxid：节点最近一次修改的时间所对应的Zxid格式时间戳</li>
<li>pZxid：子节点（或该节点）的最近一次创建/删除的时间所对应的Zxid格式时间戳</li>
</ul>
<p>实现中Zxid是一个64为的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个 新的epoch。低32位是个递增计数。</p>
</li>
<li><p>版本号</p>
<p>对节点的每一个操作都将致使这个节点的版本号增加。每个节点维护着三个版本号，他们分别为：</p>
<ul>
<li>version：节点数据版本号</li>
<li>cversion：子节点版本号</li>
<li>aversion：节点所拥有的ACL版本号</li>
</ul>
</li>
</ul>
<h3 id="zookeeper节点属性"><a href="#zookeeper节点属性" class="headerlink" title="zookeeper节点属性"></a>zookeeper节点属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>cZxid</td>
<td>节点创建时间所对应的Zxid格式时间戳</td>
</tr>
<tr>
<td>mZxid</td>
<td>节点最近一次修改的时间所对应的Zxid格式时间戳</td>
</tr>
<tr>
<td>pZxid</td>
<td>子节点（或该节点）的最近一次创建/删除的时间所对应的Zxid格式时间戳</td>
</tr>
<tr>
<td>ctime</td>
<td>节点创建时间</td>
</tr>
<tr>
<td>mtime</td>
<td>节点最近修改时间</td>
</tr>
<tr>
<td>version</td>
<td>节点数据版本号</td>
</tr>
<tr>
<td>cversion</td>
<td>子节点版本号</td>
</tr>
<tr>
<td>aversion</td>
<td>节点所拥有的ACL版本号</td>
</tr>
<tr>
<td>ephemeralOwner</td>
<td>如果此节点为临时节点，这个值为会话ID，否则，值为0</td>
</tr>
<tr>
<td>dataLength</td>
<td>节点数据长度</td>
</tr>
<tr>
<td>numChildren</td>
<td>子节点数量</td>
</tr>
</tbody></table>
<h3 id="zookeeper节点操作"><a href="#zookeeper节点操作" class="headerlink" title="zookeeper节点操作"></a>zookeeper节点操作</h3><table>
<thead>
<tr>
<th>操作</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>create</td>
<td>创建Znode(父节点必须存在)</td>
</tr>
<tr>
<td>delete</td>
<td>删除Znode(没有子节点)</td>
</tr>
<tr>
<td>exists</td>
<td>测试Znode是否存在，并获取它的元数据</td>
</tr>
<tr>
<td>getACL/setACL</td>
<td>为Znode获取/设置ACL</td>
</tr>
<tr>
<td>getChildren</td>
<td>获取Znode所有子节点列表</td>
</tr>
<tr>
<td>getData/setData</td>
<td>获取/设置Znode相关数据</td>
</tr>
<tr>
<td>sync</td>
<td>使客户端的Znode视图与zookeeper同步</td>
</tr>
</tbody></table>
<p>更新zookeeper操作是有限制的。delete或setData必须明确要更新的Znode的版本号，我们可以调用exists找到。如果版本号不匹配，更新将会失败。<br>更新zookeeper操作是非阻塞式的。因此客户端如果失去了一个更新(由于另一个进程在同时更新这个Znode)，他可以在不阻塞其他进程执行的情况下，选择重新尝试或进行其他操作。</p>
<h2 id="watch触发器"><a href="#watch触发器" class="headerlink" title="watch触发器"></a>watch触发器</h2><p><strong>zookeeper可以为所有的读操作设置watch，这些读操作包括：<code>exists()</code>、<code>getChildren()</code>及<code>getData()</code></strong>。watch事件是<strong>一次性的触发器</strong>，当watch的对象状态发生改变时，将会触发此对象上watch所对应的事件。watch事件将被异步地发送给客户端，并且zookeeper为watch机制提供了有序的一致性保证。理论上，客户端接收watch事件的时间要快于其看到watch对象状态变化的时间。</p>
<h3 id="watch类型"><a href="#watch类型" class="headerlink" title="watch类型"></a>watch类型</h3><ul>
<li><strong>数据watch(data watches)</strong>：getData和exists负责设置数据watch;</li>
<li><strong>孩子watch(child watches)</strong>：getChildren负责设置孩子watch。</li>
</ul>
<h3 id="watch注册与处触发"><a href="#watch注册与处触发" class="headerlink" title="watch注册与处触发"></a>watch注册与处触发</h3><p><img data-src="../../../public/images/zookeeper/watch.png" alt=""></p>
<ol>
<li><code>exists</code>操作上的watch，在被监视的Znode创建、删除或数据更新时被触发。</li>
<li><code>getData</code>操作上的watch，在被监视的Znode删除或数据更新时被触发。在被创建时不能被触发，因为只有Znode一定存在，<code>getData</code>操作才会成功。</li>
<li><code>getChildren</code>操作上的watch，在被监视的Znode的子节点创建或删除，或是这个Znode自身被删除时被触发。可以通过查看watch事件类型来区分是Znode，还是他的子节点被删除：<code>NodeDelete</code>表示Znode被删除，<code>NodeDeletedChanged</code>表示子节点被删除。</li>
</ol>
<h2 id="zookeeper的简单操作"><a href="#zookeeper的简单操作" class="headerlink" title="zookeeper的简单操作"></a>zookeeper的简单操作</h2><p>下载zookeeper：<a href="https://downloads.apache.org/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz" target="_blank" rel="noopener">https://downloads.apache.org/zookeeper/zookeeper-3.5.9/apache-zookeeper-3.5.9-bin.tar.gz</a></p>
<h3 id="shell操作"><a href="#shell操作" class="headerlink" title="shell操作"></a>shell操作</h3><p>进入zookeeper目录，在conf目录下，新建一个名为<code>zoo.cfg</code>的文件，其中内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 服务器与客户端之间交互的基本时间单元（ms） </span><br><span class="line">tickTime&#x3D;2000   </span><br><span class="line"># zookeeper所能接受的客户端数量 </span><br><span class="line">initLimit&#x3D;10  </span><br><span class="line"># 服务器和客户端之间请求和应答之间的时间间隔 </span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># zookeeper中使用的基本时间单位, 毫秒值.</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># 数据目录. 可以是任意目录.</span><br><span class="line">dataDir&#x3D;&#x2F;tmp&#x2F;zookeeper&#x2F;data</span><br><span class="line"># log目录, 同样可以是任意目录. 如果没有设置该参数, 将使用和#dataDir相同的设置.</span><br><span class="line">dataLogDir&#x3D;&#x2F;tmp&#x2F;zookeeper&#x2F;log</span><br><span class="line"># t监听client连接的端口号.</span><br><span class="line">clientPort&#x3D;2181</span><br></pre></td></tr></table></figure>

<p>启动zookeeper服务：<code>./bin/zkServer.sh start</code>;<br>在启动Zookeeper服务之后，输入<code>./bin/zkCli.sh -server localhost:2181</code>，连接到Zookeeper服务。</p>
<p>连接成功之后，系统会输出Zookeeper的相关环境及配置信息，并在屏幕输出“welcome to Zookeeper！”等信息。</p>
<ol>
<li><p><code>ls path</code> : 列出指定路径节点下包含的子节点信息，例如 <code>ls /</code><br><img data-src="../../../public/images/zookeeper/ls-path.png" alt=""></p>
</li>
<li><p><code>create path data</code>: 创建一个路径节点。例如 <code>create /zk hello</code><br><img data-src="../../../public/images/zookeeper/create-path-data.png" alt=""></p>
</li>
<li><p><code>get path</code>: 获取指定路径节点的信息<br><img data-src="../../../public/images/zookeeper/get-path.png" alt=""></p>
</li>
<li><p><code>set path data</code>: 给指定路径节点设置数据<br><img data-src="../../../public/images/zookeeper/set-path-data.png" alt=""></p>
</li>
<li><p><code>delete path</code>: 删除指定路径节点<br><img data-src="../../../public/images/zookeeper/delete-path.png" alt=""></p>
</li>
</ol>
<h3 id="Zookeeper的API的简单使用"><a href="#Zookeeper的API的简单使用" class="headerlink" title="Zookeeper的API的简单使用"></a>Zookeeper的API的简单使用</h3><p>Zookeeper API共包含五个包，分别为：</p>
<ul>
<li>org.apache.zookeeper</li>
<li>org.apache.zookeeper.data</li>
<li>org.apache.zookeeper.server</li>
<li>org.apache.zookeeper.server.quorum</li>
<li>org.apache.zookeeper.server.upgrade</li>
</ul>
<p>其中<code>org.apache.zookeeper</code>，包含<code>Zookeeper</code>类，他是我们编程时最常用的类文件。这个类是Zookeeper客户端的主要类文件。如果要使用Zookeeper服务，应用程序首先必须创建一个Zookeeper实例， 这时就需要使用此类。一旦客户端和Zookeeper服务建立起了连接，Zookeeper系统将会给次连接会话分配一个ID值，并且客户端将会周期性的 向服务器端发送心跳来维持会话连接。只要连接有效，客户端就可以使用<code>Zookeeper API</code>来做相应处理了。<br><img data-src="../../../public/images/zookeeper/api.png" alt=""></p>
<h2 id="curator使用详解"><a href="#curator使用详解" class="headerlink" title="curator使用详解"></a>curator使用详解</h2><p><strong><code>Apache Curator</code>是一个比较完善的zookeeper客户端框架，通过封装的一套高级API，简化了ZooKeeper的操作，因此在实际应用中都是使用<code>Apache Curator</code>来操作zookeeper的</strong>。通过查看官方文档，可以发现Curator主要解决了三类问题：</p>
<ul>
<li>封装<code>ZooKeeper client</code>与<code>ZooKeeper server</code>之间的连接处理。</li>
<li>提供了一套Fluent风格的操作API。</li>
<li>提供ZooKeeper各种应用场景(recipe， 比如：分布式锁服务、集群领导选举、共享计数器、缓存机制、分布式队列等)的抽象封装。</li>
</ul>
<h3 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-framework<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.curator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>curator-recipes<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.12.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建会话"><a href="#创建会话" class="headerlink" title="创建会话"></a>创建会话</h3><h4 id="使用静态工程方法创建客户端"><a href="#使用静态工程方法创建客户端" class="headerlink" title="使用静态工程方法创建客户端"></a>使用静态工程方法创建客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重试策略 </span></span><br><span class="line">ExponentialBackoffRetry retry = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">CuratorFramework curatorFramework = CuratorFrameworkFactory.newClient(connectionStr,<span class="number">5000</span>,<span class="number">5000</span>, retry);</span><br></pre></td></tr></table></figure>

<p>newClient静态工厂方法包含四个主要参数：</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>connectionString</td>
<td>服务器列表，格式host1:port1,host2:port2,…</td>
</tr>
<tr>
<td>retryPolicy</td>
<td>重试策略,内建有四种重试策略,也可以自行实现RetryPolicy接口</td>
</tr>
<tr>
<td>sessionTimeoutMs</td>
<td>会话超时时间，单位毫秒，默认60000ms</td>
</tr>
<tr>
<td>connectionTimeoutMs</td>
<td>连接创建超时时间，单位毫秒，默认60000ms</td>
</tr>
</tbody></table>
<h4 id="使用Fluent风格的Api创建客户端"><a href="#使用Fluent风格的Api创建客户端" class="headerlink" title="使用Fluent风格的Api创建客户端"></a>使用Fluent风格的Api创建客户端</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client =</span><br><span class="line">                CuratorFrameworkFactory.builder()</span><br><span class="line">                        .connectString(connectionInfo)</span><br><span class="line">                        .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                        .connectionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                        .retryPolicy(retryPolicy)</span><br><span class="line">                        .build();</span><br></pre></td></tr></table></figure>

<h4 id="创建包含隔离命名空间的客户端"><a href="#创建包含隔离命名空间的客户端" class="headerlink" title="创建包含隔离命名空间的客户端"></a>创建包含隔离命名空间的客户端</h4><p><strong>为了实现不同的Zookeeper业务之间的隔离，需要为每个业务分配一个独立的命名空间（<code>NameSpace</code>），即指定一个Zookeeper的根路径（官方术语：为Zookeeper添加“Chroot”特性）</strong>。例如（下面的例子）当客户端指定了独立命名空间为“/base”，那么该客户端对Zookeeper上的数据节点的操作都是基于该目录进行的。通过设置Chroot可以将客户端应用与Zookeeper服务端的一课子树相对应，在多个应用共用一个Zookeeper集群的场景下，这对于实现不同应用之间的相互隔离十分有意义。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RetryPolicy retryPolicy = <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>);</span><br><span class="line">        CuratorFramework client =</span><br><span class="line">        CuratorFrameworkFactory.builder()</span><br><span class="line">                .connectString(connectionInfo)</span><br><span class="line">                .sessionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                .connectionTimeoutMs(<span class="number">5000</span>)</span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .namespace(<span class="string">"base"</span>)</span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>

<p><em>当客户端创建成功，直接调用<code>start()</code>方法即可启动客户端</em>。</p>
<h3 id="数据节点操作"><a href="#数据节点操作" class="headerlink" title="数据节点操作"></a>数据节点操作</h3><h4 id="创建数据节点"><a href="#创建数据节点" class="headerlink" title="创建数据节点"></a>创建数据节点</h4><p>Zookeeper的节点创建模式：</p>
<ul>
<li>PERSISTENT：持久化节点</li>
<li>PERSISTENT_SEQUENTIAL：持久化顺序节点</li>
<li>EPHEMERAL：临时节点</li>
<li>EPHEMERAL_SEQUENTIAL：临时顺序节点</li>
</ul>
<p><strong>创建一个节点，初始内容为空</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.create().forPath(<span class="string">"/path"</span>);</span><br></pre></td></tr></table></figure>

<p>如果没有设置节点属性，<strong>节点创建模式默认为持久化节点，内容默认为空</strong>。</p>
<p><strong>创建一个节点，附带初始化内容</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.create().forPath(<span class="string">"/path2"</span>, <span class="string">"test1"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p><strong>创建一个节点，指定创建模式（临时节点），内容为空</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/path3"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>创建一个节点，指定创建模式（临时节点），附带初始化内容</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/path"</span>, <span class="string">"demo"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p><strong>创建一个节点，指定创建模式（临时节点），附带初始化内容，并且自动递归创建父节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.create()</span><br><span class="line">      .creatingParentContainersIfNeeded()</span><br><span class="line">      .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">      .forPath(<span class="string">"/abc/path"</span>, <span class="string">"init"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p><code>creatingParentContainersIfNeeded()</code>接口非常有用，因为一般情况开发人员在创建一个子节点必须判断它的父节点是否存在，如果不存在直接创建会抛出<code>NoNodeException</code>，<strong>使用<code>creatingParentContainersIfNeeded()</code>之后Curator能够自动递归创建所有所需的父节点</strong>。</p>
<h4 id="删除数据节点"><a href="#删除数据节点" class="headerlink" title="删除数据节点"></a>删除数据节点</h4><p><strong>删除一个节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.delete().forPath(<span class="string">"/path"</span>);</span><br></pre></td></tr></table></figure>

<p><em>注意，此方法只能删除叶子节点，否则会抛出异常</em>。</p>
<p><strong>删除一个节点，并且递归删除其所有的子节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.delete()</span><br><span class="line">                .deletingChildrenIfNeeded()</span><br><span class="line">                .forPath(<span class="string">"/path"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>删除一个节点，强制指定版本进行删除</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.delete()</span><br><span class="line">      .withVersion(<span class="number">100</span>)</span><br><span class="line">      .forPath(<span class="string">"/path"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>删除一个节点，强制保证删除</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.delete()</span><br><span class="line">      .guaranteed()</span><br><span class="line">      .forPath(<span class="string">"/path"</span>);</span><br></pre></td></tr></table></figure>

<p><em>上面的多个流式接口是可以自由组合</em>，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.delete()</span><br><span class="line">      .guaranteed()</span><br><span class="line">      .deletingChildrenIfNeeded()</span><br><span class="line">      .withVersion(<span class="number">10086</span>)</span><br><span class="line">      .forPath(<span class="string">"path"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="读取数据节点数据"><a href="#读取数据节点数据" class="headerlink" title="读取数据节点数据"></a>读取数据节点数据</h4><p><strong>读取一个节点的数据内容</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">byte[] data &#x3D; client.getData().forPath(&quot;&#x2F;path2&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>读取一个节点的数据内容，同时获取到该节点的stat</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stat stat = <span class="keyword">new</span> Stat();</span><br><span class="line"><span class="keyword">byte</span>[] data = client.getData()</span><br><span class="line">        .storingStatIn(stat)</span><br><span class="line">        .forPath(<span class="string">"/path2"</span>);</span><br></pre></td></tr></table></figure>

<h4 id="更新数据节点数据"><a href="#更新数据节点数据" class="headerlink" title="更新数据节点数据"></a>更新数据节点数据</h4><p><strong>更新一个节点的数据内容</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.setData().forPath(<span class="string">"/path"</span>,<span class="string">"data"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<p><strong>更新一个节点的数据内容，强制指定版本进行更新</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.setData().withVersion(<span class="number">10086</span>).forPath(<span class="string">"/path"</span>,<span class="string">"data"</span>.getBytes());</span><br></pre></td></tr></table></figure>

<h4 id="检查节点是否存在"><a href="#检查节点是否存在" class="headerlink" title="检查节点是否存在"></a>检查节点是否存在</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stat stat = client.checkExists().forPath(<span class="string">"/path"</span>);</span><br></pre></td></tr></table></figure>

<p>注意：该方法返回一个Stat实例，不存在，则返回null。</p>
<h4 id="获取某个节点的所有子节点路径"><a href="#获取某个节点的所有子节点路径" class="headerlink" title="获取某个节点的所有子节点路径"></a>获取某个节点的所有子节点路径</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = client.getChildren().forPath(<span class="string">"/path"</span>);</span><br></pre></td></tr></table></figure>

<p>该方法的返回值为List<String>,获得ZNode的子节点Path列表。 </p>
<h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>CuratorFramework的实例包含<code>inTransaction()</code>接口方法，调用此方法开启一个ZooKeeper事务. 可以复合<code>create</code>, <code>setData</code>, <code>check</code>, <code>and/or delete</code> 等操作然后调用<code>commit()</code>作为一个<strong>原子操作提交</strong>。一个例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">client.inTransaction()</span><br><span class="line">               .check().forPath(<span class="string">"/path"</span>)</span><br><span class="line">               .and()</span><br><span class="line">               .create().withMode(CreateMode.EPHEMERAL).forPath(<span class="string">"/path"</span>, <span class="string">"data"</span>.getBytes())</span><br><span class="line">               .and()</span><br><span class="line">               .setData().withVersion(<span class="number">1000</span>).forPath(<span class="string">"/path"</span>, <span class="string">"data2"</span>.getBytes())</span><br><span class="line">               .and()</span><br><span class="line">               .commit();</span><br></pre></td></tr></table></figure>

<p>上面提到的创建、删除、更新、读取等方法都是同步的，<code>Curator</code>提供异步接口，引入了<code>BackgroundCallback</code>接口用于处理异步接口调用之后服务端返回的结果信息。<code>BackgroundCallback</code>接口中一个重要的回调值为<code>CuratorEvent</code>，里面包含事件类型、响应吗和节点的详细信息。</p>
<p><strong>CuratorEventType</strong></p>
<table>
<thead>
<tr>
<th>事件类型</th>
<th>对应CuratorFramework实例的方法</th>
</tr>
</thead>
<tbody><tr>
<td>CREATE</td>
<td>create()</td>
</tr>
<tr>
<td>DELETE</td>
<td>delete()</td>
</tr>
<tr>
<td>EXISTS</td>
<td>checkExists()</td>
</tr>
<tr>
<td>GET_DATA</td>
<td>getData()</td>
</tr>
<tr>
<td>SET_DATA</td>
<td>setData()</td>
</tr>
<tr>
<td>CHILDREN</td>
<td>getChildren()</td>
</tr>
<tr>
<td>SYNC</td>
<td>sync(String,Object)</td>
</tr>
<tr>
<td>GET_ACL</td>
<td>getACL()</td>
</tr>
<tr>
<td>SET_ACL</td>
<td>setACL()</td>
</tr>
<tr>
<td>WATCHED</td>
<td>Watcher(Watcher)</td>
</tr>
<tr>
<td>CLOSING</td>
<td>close()</td>
</tr>
</tbody></table>
<p><strong>响应码(<code>getResultCode()</code>)</strong></p>
<table>
<thead>
<tr>
<th>响应码</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>OK，即调用成功</td>
</tr>
<tr>
<td>-4</td>
<td>ConnectionLoss，即客户端与服务端断开连接</td>
</tr>
<tr>
<td>-110</td>
<td>NodeExists，即节点已经存在</td>
</tr>
<tr>
<td>-112</td>
<td>SessionExpired，即会话过期</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ExecutorService executor = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        client.create()</span><br><span class="line">                .creatingParentsIfNeeded()</span><br><span class="line">                .withMode(CreateMode.EPHEMERAL)</span><br><span class="line">                <span class="comment">// 异步</span></span><br><span class="line"><span class="comment">// .inBackground()</span></span><br><span class="line">                .inBackground((client1, event) -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 事件类型</span></span><br><span class="line">                    CuratorEventType type = event.getType();</span><br><span class="line">                    <span class="comment">// 结果编码</span></span><br><span class="line">                    <span class="keyword">int</span> resultCode = event.getResultCode();</span><br><span class="line">                    System.out.println(<span class="string">"事件类型: "</span> + type + <span class="string">", 结果编码: "</span> + resultCode);</span><br><span class="line">                &#125;, executor)</span><br><span class="line">                .forPath(<span class="string">"/path"</span>);</span><br></pre></td></tr></table></figure>

<p>注意：如果<code>inBackground()</code>方法不指定executor，那么会默认使用Curator的EventThread去进行异步处理。</p>
<h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p><strong>强烈推荐使用<code>ConnectionStateListener</code>监控连接的状态，当连接状态为LOST，curator-recipes下的所有Api将会失效或者过期</strong>。</p>
<p>zookeeper原生支持通过注册<code>Watcher</code>来进行事件监听，但是开发者需要反复注册(Watcher只能单次注册单次使用)。<strong>Cache是Curator中对事件监听的包装，可以看作是对事件监听的本地缓存视图，能够自动为开发者处理反复注册监听</strong>。Curator提供了三种Watcher(Cache)来监听结点的变化。</p>
<ul>
<li>Path Cache</li>
</ul>
<p><strong>Path Cache用来监控一个Znode的子节点</strong>. 当一个子节点增加， 更新，删除时， Path Cache会改变它的状态，会包含最新的子节点，子节点的数据和状态，而状态的变更将通过<code>PathChildrenCacheListener</code>通知。</p>
<p>实际使用时会涉及到四个类：</p>
<ul>
<li>PathChildrenCache</li>
<li>PathChildrenCacheEvent</li>
<li>PathChildrenCacheListener</li>
<li>ChildData</li>
</ul>
<p>通过下面的构造函数创建Path Cache:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PathChildrenCache</span><span class="params">(CuratorFramework client, String path, <span class="keyword">boolean</span> cacheData)</span></span>;</span><br></pre></td></tr></table></figure>

<p>想使用cache，必须调用它的start方法，使用完后调用close方法。 可以设置StartMode来实现启动的模式。</p>
<ul>
<li>NORMAL：正常初始化。</li>
<li>BUILD_INITIAL_CACHE：在调用start()之前会调用rebuild()。</li>
<li>POST_INITIALIZED_EVENT： 当Cache初始化数据后发送一个<code>PathChildrenCacheEvent.Type#INITIALIZED</code>事件</li>
</ul>
<p><code>addListener(PathChildrenCacheListener listener)</code>可以增加listener监听缓存的变化。<br><code>getCurrentData()</code>方法返回一个List对象，可以遍历所有的子节点。</p>
<p><em>设置/更新、移除其实是使用client (CuratorFramework)来操作, 不通过PathChildrenCache操作</em>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建path cache</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注意：如果new PathChildrenCache(client, PATH, cacheData)中的参数cacheData值设置为false，</span></span><br><span class="line"><span class="comment"> * 则示例中的event.getData() 将返回null，cache将不会缓存节点数据。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">PathChildrenCache cache = <span class="keyword">new</span> PathChildrenCache(client, PATH, <span class="keyword">true</span>);</span><br><span class="line">cache.start(PathChildrenCache.StartMode.NORMAL);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加一个监听器</span></span><br><span class="line">cache.getListenable()</span><br><span class="line">        .addListener((client1, event) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 事件类型</span></span><br><span class="line">            PathChildrenCacheEvent.Type type = event.getType();</span><br><span class="line">            System.out.println(<span class="string">"事件类型："</span> + type);</span><br><span class="line">            <span class="comment">// 子节点数据</span></span><br><span class="line">            ChildData data = event.getData();</span><br><span class="line">            System.out.println(<span class="string">"子节点数据："</span> + data);</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>注意：如果<code>new PathChildrenCache(client, PATH, cacheData)</code>中的参数<code>cacheData</code>值设置为<code>false</code>，则示例中的<code>event.getData()</code>将返回null，cache将不会缓存节点数据。</p>
<h4 id="Node-Cache"><a href="#Node-Cache" class="headerlink" title="Node Cache"></a>Node Cache</h4><p><code>Node Cache</code>与<code>Path Cache</code>类似，<strong><code>Node Cache</code>只是监听某一个特定的节点</strong>。它涉及到下面的三个类：</p>
<ul>
<li><code>NodeCache</code>：Node Cache实现类</li>
<li><code>NodeCacheListener</code>：节点监听器</li>
<li><code>ChildData</code>： 节点数据</li>
</ul>
<p><code>getCurrentData()</code>将得到节点当前的状态，通过它的状态可以得到当前的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建NodeCache</span></span><br><span class="line">NodeCache nodeCache = <span class="keyword">new</span> NodeCache(client, PATH);</span><br><span class="line"><span class="comment">// 必须要先start</span></span><br><span class="line">nodeCache.start();</span><br><span class="line"></span><br><span class="line">NodeCacheListener listener = () -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">"节点变化"</span>);</span><br><span class="line">    ChildData currentData = nodeCache.getCurrentData();</span><br><span class="line">    <span class="keyword">if</span> (currentData != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(<span class="string">"节点数据："</span> + currentData);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"节点无数据"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">nodeCache.getListenable().addListener(listener);</span><br></pre></td></tr></table></figure>

<h4 id="Tree-Cache"><a href="#Tree-Cache" class="headerlink" title="Tree Cache"></a>Tree Cache</h4><p>Tree Cache可以监控整个树上的所有节点，主要涉及到下面四个类：</p>
<ul>
<li><code>TreeCache</code>：Tree Cache实现类</li>
<li><code>TreeCacheListener</code>：监听器类</li>
<li><code>TreeCacheEvent</code>：触发的事件类</li>
<li><code>ChildData</code>：节点数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeCache treeCache = <span class="keyword">new</span> TreeCache(client, PATH);</span><br><span class="line">treeCache.start();</span><br><span class="line"></span><br><span class="line">treeCache.getListenable().addListener((client1, event) -&gt; &#123;</span><br><span class="line">    TreeCacheEvent.Type type = event.getType();</span><br><span class="line">    ChildData data = event.getData();</span><br><span class="line">    System.out.println(<span class="string">"事件类型："</span> + type + <span class="string">", 节点数据："</span> + data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p>在分布式计算中，<code>leader elections</code>是很重要的一个功能。这个选举过程是这样子的： 指派一个进程作为组织者，将任务分发给各节点。 在任务开始前， 哪个节点都不知道谁是leader(领导者)或者coordinator(协调者). 当选举算法开始执行后， 每个节点最终会得到一个唯一的节点作为任务leader. 除此之外，选举还经常会发生在leader意外宕机的情况下，新的leader要被选举出来。</p>
<p><strong>在zookeeper集群中，leader负责写操作，然后通过Zab协议实现follower的同步，leader或者follower都可以处理读操作</strong>。<br>Curator有两种leader选举的recipe,分别是<code>LeaderSelector</code>和<code>LeaderLatch</code>。</p>
<ul>
<li><code>LeaderSelector</code>：所有存活的客户端不间断的轮流做Leader。</li>
<li><code>LeaderLatch</code>：一旦选举出Leader，除非有客户端挂掉重新触发选举，否则不会交出领导权。</li>
</ul>
<h4 id="LeaderLatch"><a href="#LeaderLatch" class="headerlink" title="LeaderLatch"></a>LeaderLatch</h4><p><code>LeaderLatch</code>会和其它使用相同latch path的其它<code>LeaderLatch</code>交涉，然后其中一个最终会被选举为<code>leader</code>，可以通过<code>hasLeadership()</code>方法查看<code>LeaderLatch</code>实例是否leader。</p>
<p>类似JDK的<code>CountDownLatch</code>， <code>LeaderLatch</code>在请求成为<code>leadership</code>会<code>block</code>(阻塞)，一旦不使用<code>LeaderLatch</code>了，必须调用<code>close()</code>方法。 如果它是leader,会释放leadership， 其它的参与者将会选举一个leader。</p>
<p>异常处理： <code>LeaderLatch</code>实例可以增加<code>ConnectionStateListener</code>来监听网络连接问题。 当<code>SUSPENDED</code>或<code>LOST</code>时, leader不再认为自己还是leader。当<code>LOST</code>后连接重连后<code>RECONNECTED</code>, LeaderLatch会删除先前的ZNode然后重新创建一个。<strong>LeaderLatch用户必须考虑导致leadership丢失的连接问题。 强烈推荐你使用<code>ConnectionStateListener</code></strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参与选举的所有节点，会创建一个顺序节点，其中最小的 节点会设置为 master 节点, 没抢到 Leader 的节点都监听 前一个节点的删除事件，</span></span><br><span class="line"><span class="comment"> * 在前一个节点删除后进行重新抢主，当 master 节点手动调用 close()方法或者 master 节点挂了之后，后续的子节点会抢占 master。</span></span><br><span class="line"><span class="comment"> 其中 spark 使用的就是这种方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderLatchTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> String PATH = <span class="string">"/francis/leader"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String connectionInfo = <span class="string">"127.0.0.1:2181"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CLIENT_QTY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;CuratorFramework&gt; clients = Lists.newArrayList();</span><br><span class="line">        List&lt;LeaderLatch&gt; examples = Lists.newArrayList();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 创建10个客户端，并且创建对应的LeaderLatch</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; CLIENT_QTY; i++) &#123;</span><br><span class="line">                CuratorFramework client</span><br><span class="line">                        = CuratorFrameworkFactory.newClient(connectionInfo, <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">20000</span>, <span class="number">3</span>));</span><br><span class="line">                clients.add(client);</span><br><span class="line">                LeaderLatch latch = <span class="keyword">new</span> LeaderLatch(client, PATH, <span class="string">"Client #"</span> + i);</span><br><span class="line"></span><br><span class="line">                latch.addListener(<span class="keyword">new</span> LeaderLatchListener()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"I am Leader"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notLeader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        System.out.println(<span class="string">"I am not Leader"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                examples.add(latch);</span><br><span class="line">                client.start();</span><br><span class="line">                latch.start();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">10_000</span>);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取当前的leader</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            LeaderLatch currentLeader = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (LeaderLatch latch : examples) &#123;</span><br><span class="line">                <span class="keyword">if</span> (latch.hasLeadership()) &#123;</span><br><span class="line">                    currentLeader = latch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"current leader is "</span> + currentLeader.getId());</span><br><span class="line">            System.out.println(<span class="string">"release the leader "</span> + currentLeader.getId());</span><br><span class="line">            <span class="comment">// 只能通过close释放当前的领导权</span></span><br><span class="line">            currentLeader.close();</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 再次获取leader</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">for</span> (LeaderLatch latch : examples) &#123;</span><br><span class="line">                <span class="keyword">if</span> (latch.hasLeadership()) &#123;</span><br><span class="line">                    currentLeader = latch;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"current leader is "</span> + currentLeader.getId());</span><br><span class="line">            System.out.println(<span class="string">"release the leader "</span> + currentLeader.getId());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (LeaderLatch latch : examples) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != latch.getState())</span><br><span class="line">                    CloseableUtils.closeQuietly(latch);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (CuratorFramework client : clients) &#123;</span><br><span class="line">                CloseableUtils.closeQuietly(client);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们创建了10个<code>LeaderLatch</code>，启动后它们中的一个会被选举为leader。 因为选举会花费一些时间，start后并不能马上就得到leader。 通过<code>hasLeadership()</code>查看自己是否是leader， 如果是的话返回true。 可以通过<code>getId()</code>可以得到当前的leader的ID。只能通过<code>close()</code>释放当前的领导权。</p>
<h4 id="LeaderSelector"><a href="#LeaderSelector" class="headerlink" title="LeaderSelector"></a>LeaderSelector</h4><p>LeaderSelector使用的时候主要涉及下面几个类：</p>
<ul>
<li>LeaderSelector</li>
<li>LeaderSelectorListener</li>
<li>LeaderSelectorListenerAdapter </li>
<li>CancelLeadershipException</li>
</ul>
<p>类似<code>LeaderLatch</code>,<code>LeaderSelector</code>必须start:<code>leaderSelector.start()</code>; 一旦启动，当实例取得领导权时你的listener的<code>takeLeadership()</code>方法被调用。而<code>takeLeadership()</code>方法只有领导权被释放时才返回。 当你不再使用LeaderSelector实例时，应该调用它的<code>close()</code>方法。</p>
<p><strong>异常处理</strong>：<code>LeaderSelectorListener</code>类继承<code>ConnectionStateListener</code>。LeaderSelector必须小心连接状态的改变。如果实例成为leader, 它应该响应<code>SUSPENDED</code>或<code>LOST</code>。 当<code>SUSPENDED</code>状态出现时，实例必须假定在重新连接成功之前, 它可能不再是leader了。 如果LOST状态出现， 实例不再是leader， <code>takeLeadership()</code>方法返回。</p>
<p><strong>重要</strong>: 推荐处理方式是当收到<code>SUSPENDED</code> 或<code>LOST</code>时抛出<code>CancelLeadershipException</code>异常。这是会导致<code>LeaderSelector</code>实例中断并取消执行<code>takeLeadership</code>方法的异常。这非常重要， 你必须考虑扩展<code>LeaderSelectorListenerAdapter</code>。 <code>LeaderSelectorListenerAdapter</code>提供了推荐的处理逻辑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当实例被选为leader之后，调用takeLeadership方法进行业务逻辑处理，处理完成即释放领导权。</span></span><br><span class="line"><span class="comment"> * autoRequeue()方法的调用确保此实例在释放领导权后还可能获得领导权。</span></span><br><span class="line"><span class="comment"> * 这样保证了每个节点都可以获得领导权。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2019/11/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderSelectorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        List&lt;LeaderSelector&gt; leaderSelectors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;CuratorFramework&gt; clients = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            CuratorFramework client = CuratorFrameworkFactory.newClient(<span class="string">"localhost:2181"</span>, <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">            client.start();</span><br><span class="line">            clients.add(client);</span><br><span class="line"></span><br><span class="line">            LeaderSelector leaderSelector = <span class="keyword">new</span> LeaderSelector(client, <span class="string">"/master"</span>, <span class="keyword">new</span> LeaderSelectorListenerAdapter() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">takeLeadership</span><span class="params">(CuratorFramework curatorFramework)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" is a leader"</span>);</span><br><span class="line">                    Thread.sleep(Integer.MAX_VALUE);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stateChanged</span><span class="params">(CuratorFramework client, ConnectionState newState)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.stateChanged(client, newState);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            leaderSelectors.add(leaderSelector);</span><br><span class="line">        &#125;</span><br><span class="line">        leaderSelectors.forEach(leaderSelector -&gt; &#123;</span><br><span class="line">            leaderSelector.autoRequeue();</span><br><span class="line">            leaderSelector.start();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"=================="</span>);</span><br><span class="line">        clients.forEach(client -&gt; &#123;</span><br><span class="line">            client.close();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">100</span> * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><ol>
<li>推荐使用<code>ConnectionStateListener</code>监控连接的状态，因为当连接LOST时你不再拥有锁。</li>
<li>分布式的锁全局同步，这意味着任何一个时间点不会有两个客户端都拥有相同的锁。</li>
</ol>
<h4 id="可重入共享锁—Shared-Reentrant-Lock"><a href="#可重入共享锁—Shared-Reentrant-Lock" class="headerlink" title="可重入共享锁—Shared Reentrant Lock"></a>可重入共享锁—Shared Reentrant Lock</h4><p><code>Shared</code>意味着锁是全局可见的，客户端都可以请求锁。<code>Reentrant</code>和JDK的<code>ReentrantLock</code>类似，即可重入。意味着<strong>同一个客户端在拥有锁的同时，可以多次获取，不会被阻塞</strong>。 它是由类<code>InterProcessMutex</code>来实现。 它的构造函数为：<code>public InterProcessMutex(CuratorFramework client, String path)</code>。</p>
<ul>
<li>通过<code>acquire()</code>获得锁，并提供超时机制。</li>
<li>通过<code>release()</code>方法释放锁。<code>InterProcessMutex</code>实例可以重用。</li>
</ul>
<p>zookeeper还提供了可协商的撤销机制，通过为<code>mutex</code>设置<em>撤销监听器</em>来支持撤销<code>mutex</code>, 通过调用<code>makeRevocable(RevocationListener&lt;T&gt; listener)</code>来实现。</p>
<p>如果你请求撤销当前的锁，可以调用<code>Revoker.attemptRevoke(CuratorFramework client, String path)</code>方法,此时<code>RevocationListener</code>将会回调。</p>
<p><strong>代码示例</strong>：</p>
<p>首先让我们创建一个模拟的共享资源， 这个资源期望只能单客户端的访问，否则会有并发问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 共享资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FakeLimitedResource</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean inUse = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * use方法最多只能有一个客户端调用</span></span><br><span class="line"><span class="comment">     * 否则，抛出异常</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 真实环境中我们会在这里访问/维护一个共享的资源</span></span><br><span class="line">        <span class="comment">//这个例子在使用锁的情况下不会非法并发异常IllegalStateException</span></span><br><span class="line">        <span class="comment">//但是在无锁的情况由于sleep了一段时间，很容易抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (!inUse.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"同一时间，只能被一个客户端访问！！！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(random.nextInt(<span class="number">2_000</span>));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            inUse.set(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后创建一个<code>InterProcessMutexDemo</code>类， 它负责请求锁， 使用资源，释放锁这样一个完整的访问过程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 然后创建一个InterProcessMutexDemo类， 它负责请求锁， 使用资源，释放锁这样一个完整的访问过程。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/12/15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterProcessMutexDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代码也很简单，生成10个client， 每个client重复执行10次 请求锁–访问资源–释放锁的过程。</span></span><br><span class="line"><span class="comment">     * 每个client都在独立的线程中。 结果可以看到，锁是随机的被每个实例排他性的使用。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> InterProcessMutex lock;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FakeLimitedResource resource;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String clientName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterProcessMutexDemo</span><span class="params">(CuratorFramework client, String lockPath, FakeLimitedResource resource, String clientName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.resource = resource;</span><br><span class="line">        <span class="keyword">this</span>.clientName = clientName;</span><br><span class="line">        <span class="keyword">this</span>.lock = <span class="keyword">new</span> InterProcessMutex(client, lockPath);</span><br><span class="line">        <span class="comment">// 将锁设为可撤销的. 当别的进程或线程想让你释放锁时Listener会被调用。</span></span><br><span class="line">        lock.makeRevocable((forLock -&gt; &#123;</span><br><span class="line"></span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 同一线程再次 acquire，首先判断当前的 映射表内(threadData)是否有该线程的锁信息，如果有 则原子+1，然后返回</span></span><br><span class="line"><span class="comment">     * 可重入互斥锁</span></span><br><span class="line"><span class="comment">     * 加锁执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!lock.acquire(time, unit)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(clientName + <span class="string">"获取互斥锁锁失败"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(clientName + <span class="string">" 获取到互斥锁"</span>);</span><br><span class="line">            resource.use(); <span class="comment">//access resource exclusively</span></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(clientName + <span class="string">" 释放互斥锁"</span>);</span><br><span class="line">            lock.release(); <span class="comment">// always release the lock in a finally block</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> QTY = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REPETITIONS = QTY * <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PATH = <span class="string">"/examples/locks"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> FakeLimitedResource resource = <span class="keyword">new</span> FakeLimitedResource();</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(QTY);</span><br><span class="line">        <span class="keyword">final</span> TestingServer server = <span class="keyword">new</span> TestingServer();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; QTY; ++i) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> index = i;</span><br><span class="line">                Callable&lt;Void&gt; task = () -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 创建客户端</span></span><br><span class="line">                    CuratorFramework client = CuratorFrameworkFactory.newClient(server.getConnectString(), <span class="keyword">new</span> ExponentialBackoffRetry(<span class="number">1000</span>, <span class="number">3</span>));</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 启动</span></span><br><span class="line">                        client.start();</span><br><span class="line">                        <span class="keyword">final</span> InterProcessMutexDemo example = <span class="keyword">new</span> InterProcessMutexDemo(client, PATH, resource, <span class="string">"Client "</span> + index);</span><br><span class="line">                        <span class="comment">// 执行</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; REPETITIONS; ++j) &#123;</span><br><span class="line">                            example.doWork(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        CloseableUtils.closeQuietly(client);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;;</span><br><span class="line">                service.submit(task);</span><br><span class="line">            &#125;</span><br><span class="line">            service.shutdown();</span><br><span class="line">            service.awaitTermination(<span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            CloseableUtils.closeQuietly(server);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="不可重入共享锁—Shared-Lock"><a href="#不可重入共享锁—Shared-Lock" class="headerlink" title="不可重入共享锁—Shared Lock"></a>不可重入共享锁—Shared Lock</h4><p>这个锁和上面的<code>InterProcessMutex</code>相比，就是少了<code>Reentrant</code>的功能，也就意味着它不能在同一客户端中重入。这个类是<code>InterProcessSemaphoreMutex</code>,使用方法和<code>InterProcessMutex</code>类似</p>
<blockquote>
<p>源码见<code>InterProcessSemaphoreMutexDemo</code>类。</p>
</blockquote>
<p>运行后发现，有且只有一个client成功获取第一个锁(第一个<code>acquire()</code>方法返回true)，然后它自己阻塞在第二个<code>acquire()</code>方法，获取第二个锁超时；其他所有的客户端都阻塞在第一个<code>acquire()</code>方法超时并且抛出异常。<br>这样也就验证了<code>InterProcessSemaphoreMutex</code>实现的锁是不可重入的。</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>【转载】为何springMVC可获取到方法参数名，而MyBatis却不行？</title>
    <url>/posts/2790402318/</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://cloud.tencent.com/developer/article/1497751" target="_blank" rel="noopener">为何springMVC可获取到方法参数名，而MyBatis却不行？</a></p>
</blockquote>
<p><code>Spring MVC</code>和<code>MyBatis</code>作为当下最为流行的两个框架，大家平时开发中都在用。如果你往深了一步去思考，你应该会有这样的疑问：</p>
<ul>
<li>在使用<code>Spring MVC</code>的时候，即使不使用注解，只要参数名和请求参数的key对应上了，就能自动完成数值的封装</li>
<li>在使用<code>MyBatis</code>（接口模式）时，接口方法向xml里的SQL语句传参时，必须使用<code>@Param(&#39;&#39;)</code>指定key值，在SQL中才可以取到。</li>
</ul>
<p><strong>为什么<code>Spring MVC</code>可以动态取到方法参数名称，而<code>MyBatis</code>的<code>Mapper</code>接口却无法支持</strong>？</p>
<a id="more"></a>

<h2 id="问题发现"><a href="#问题发现" class="headerlink" title="问题发现"></a>问题发现</h2><p>大家都知道，<code>.java</code>文件必须经过<code>javac</code>编译成<code>.class</code>文件才能被JVM执行。<strong>而在编译的时候，默认是不会保留方法参数名称的</strong>，取而代之的是<code>arg0</code>、<code>arg1</code>等表示。因此，<strong>想在运行时通过<code>.class</code>字节码直接拿到方法的参数名称是不可能做到的</strong>。</p>
<p>如下示例，很明显就是获取不到参数名称：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException </span>&#123;</span><br><span class="line">    Method method = Main.class.getMethod("test1", String.class, Integer.class);</span><br><span class="line">    <span class="keyword">int</span> parameterCount = method.getParameterCount();</span><br><span class="line">    Parameter[] parameters = method.getParameters();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印输出：</span></span><br><span class="line">    System.out.println(<span class="string">"方法参数总数："</span> + parameterCount);</span><br><span class="line">    Arrays.stream(parameters).forEach(p -&gt; System.out.println(p.getType() + <span class="string">"----"</span> + p.getName()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打印内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">方法参数总数：2</span><br><span class="line">class java.lang.String----arg0</span><br><span class="line">class java.lang.Integer----arg1</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>这样实现Redis分布式锁最简单</title>
    <url>/posts/82102136/</url>
    <content><![CDATA[<p>分布式锁是实际应用中最常见的场景之一，Redisson虽然支持了分布式锁实现，但是使用上仍然不够方便。本文介绍了一种优雅的分布式锁的静态方法封装和注解式封装实现。</p>
<a id="more"></a>

<h2 id="静态方法封装"><a href="#静态方法封装" class="headerlink" title="静态方法封装"></a>静态方法封装</h2><p>为了方便在业务代码中使用分布式锁，可以通过静态方法直接调用来实现。结合函数式编程，完整接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分布式锁定执行，返回执行结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key         分布式锁标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leaseTimeMs 自动释放时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> executable    可执行单元</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">lockExecute</span><span class="params">(String key, Long leaseTimeMs, Executable executable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 分布式锁定执行，不返回执行结果</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key         分布式锁标识</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leaseTimeMs 自动释放时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable    可执行单元</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lockRun</span><span class="params">(String key, Long leaseTimeMs, Runnable runnable)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong><code>lockExecute()</code>支持返回分布式锁加锁执行结果，<code>lockRun()</code>则无返回结果</strong>。</p>
<p>完整代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 陈添明</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@UtilityClass</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RLockUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁定执行，返回执行结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key         分布式锁标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTimeMs 自动释放时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> executable    可执行单元</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 执行结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">lockExecute</span><span class="params">(String key, Long leaseTimeMs, Executable executable)</span> </span>&#123;</span><br><span class="line">        RLock lock = doLock(key, leaseTimeMs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> executable.execute();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            doUnlock(key, leaseTimeMs, lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁定执行，不返回执行结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key         分布式锁标识</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> leaseTimeMs 自动释放时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> runnable    可执行单元</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lockRun</span><span class="params">(String key, Long leaseTimeMs, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        RLock lock = doLock(key, leaseTimeMs);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            runnable.run();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            doUnlock(key, leaseTimeMs, lock);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doUnlock</span><span class="params">(String key, Long leaseTimeMs, RLock lock)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lock != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">"分布式锁释放失败!不影响业务执行！key=&#123;&#125;, leaseTimeMs=&#123;&#125;"</span>, key, leaseTimeMs, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RLock <span class="title">doLock</span><span class="params">(String key, Long leaseTimeMs)</span> </span>&#123;</span><br><span class="line">        RLock lock = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            RedissonClient redissonClient = SpringUtil.getBean(RedissonClient<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            lock = redissonClient.getLock(key);</span><br><span class="line">            lock.lock(leaseTimeMs, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"分布式锁加锁失败！不影响业务正常执行！key=&#123;&#125;, leaseTimeMs=&#123;&#125;"</span>, key, leaseTimeMs, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lock;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="注解式封装"><a href="#注解式封装" class="headerlink" title="注解式封装"></a>注解式封装</h2><p>注解式编程是日常工作中更常用的一种方式，下面重点介绍注解式的实现方案。</p>
<h3 id="定义注解-RLock"><a href="#定义注解-RLock" class="headerlink" title="定义注解@RLock"></a>定义注解<code>@RLock</code></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RLock &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 分布式锁标识，支持以下格式：</span></span><br><span class="line"><span class="comment">     * abc</span></span><br><span class="line"><span class="comment">     * #&#123;param&#125;</span></span><br><span class="line"><span class="comment">     * #&#123;user.id&#125;</span></span><br><span class="line"><span class="comment">     * abc_#&#123;param&#125;_#&#123;user.id&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> key</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">key</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自动释放锁时间，单位毫秒,默认5_000</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> leaseTime</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">leaseTimeMs</span><span class="params">()</span> <span class="keyword">default</span> 5_000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义切面实现"><a href="#定义切面实现" class="headerlink" title="定义切面实现"></a>定义切面实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Order</span>(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RLockAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ExpressionParser parser = <span class="keyword">new</span> SpelExpressionParser();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PropertyPlaceholderHelper defaultHelper = <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="string">"#&#123;"</span>, <span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ParameterNameDiscoverer parameterNameDiscoverer = <span class="keyword">new</span> DefaultParameterNameDiscoverer();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(<span class="string">"@annotation(rLock)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">lock</span><span class="params">(ProceedingJoinPoint joinPoint, RLock rLock)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        String key;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            key = generateKey(joinPoint, rLock);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"生成分布式锁标识失败，执行单元将会直接执行！"</span>);</span><br><span class="line">            <span class="keyword">return</span> joinPoint.proceed();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> RLockUtils.lockExecute(key, rLock.leaseTimeMs(), joinPoint::proceed);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成分布式锁标识</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> joinPoint 连接点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rLock     锁注解</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 分布式锁标识</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateKey</span><span class="params">(ProceedingJoinPoint joinPoint, RLock rLock)</span> </span>&#123;</span><br><span class="line">        String key = rLock.key();</span><br><span class="line">        Assert.hasText(key, <span class="string">"key不能配置空白字符！"</span>);</span><br><span class="line">        EvaluationContext context = <span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">        MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">        Method method = signature.getMethod();</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        String[] parameterNames = parameterNameDiscoverer.getParameterNames(method);</span><br><span class="line">        <span class="keyword">if</span> (parameterNames != <span class="keyword">null</span> &amp;&amp; parameterNames.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterNames.length; i++) &#123;</span><br><span class="line">                context.setVariable(parameterNames[i], args[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> defaultHelper.replacePlaceholders(key, placeholderName -&gt; &#123;</span><br><span class="line">            Expression expression = parser.parseExpression(<span class="string">"#"</span> + placeholderName);</span><br><span class="line">            <span class="keyword">return</span> String.valueOf(expression.getValue(context));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>切面将会自动拦截所有标注了<code>@RLock</code>的方法，并织入分布式锁的代码。重点有3个<code>Spring</code>相关类需要关注一下：</p>
<ul>
<li><code>ParameterNameDiscoverer</code>：用于获取方法参数名称。详细信息可参考<a href="https://cloud.tencent.com/developer/article/1497751" target="_blank" rel="noopener">为何Spring MVC可获取到方法参数名，而MyBatis却不行？</a></li>
<li><code>PropertyPlaceholderHelper</code>: 用于处理占位符解析。详细信息可参考<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/util/PropertyPlaceholderHelper.html" target="_blank" rel="noopener">PropertyPlaceholderHelper文档</a>。</li>
<li><code>ExpressionParser</code>： 用于解析<code>SpringEL</code>表达式。详细信息可参考<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/expression/ExpressionParser.html" target="_blank" rel="noopener">ExpressionParser文档</a></li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在任意方法上，标注<code>@RLock</code>即可自动织入分布式锁：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RLock</span>(key = <span class="string">"abc_#&#123;id&#125;_#&#123;person.name&#125;_#&#123;person.age&#125;"</span>)</span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRLock</span><span class="params">(Long id, Person person)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 做业务处理</span></span><br><span class="line">    Thread.sleep(<span class="number">5000L</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原创不易，觉得文章写得不错的小伙伴，点个赞👍 鼓励一下吧~</p>
</blockquote>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA快捷键（mac）</title>
    <url>/posts/81062828/</url>
    <content><![CDATA[<p>IDEA快捷键（mac）</p>
<a id="more"></a>

<h2 id="无处不在的跳转"><a href="#无处不在的跳转" class="headerlink" title="无处不在的跳转"></a>无处不在的跳转</h2><p><code>command + 数字键</code> ：打开数字标识的侧边栏或者是底栏。</p>
<p><code>alt + command +  [ 或 ]</code>：切换到上一个项目窗口。</p>
<p><code>shift + command + A</code> : 查找命令</p>
<p><code>command + E</code> : 最近打开的文件</p>
<p><code>shift + command + E</code> : 最近编辑的文件</p>
<p><code>shift + command + delete</code> ：跳转到上一个编辑的位置</p>
<p><code>alt + command + &lt;-  /  -&gt;</code>  : 跳转到  上一个  / 下一个  浏览的位置</p>
<p><code>F2</code> : 跳转到错误的位置。</p>
<p><code>F11</code> : 添加到书签</p>
<p><code>command + F11 + 数字</code> : 添加到书签x</p>
<p><code>ctrl + 数字</code> ：跳转到对应书签</p>
<p><code>shift + F11</code> : 显示所有书签</p>
<p><code>alt + shift + F</code>：添加到收藏。可以是类或者是方法。</p>
<p><code>command + G</code>：跳转指定行数</p>
<h2 id="精准搜索"><a href="#精准搜索" class="headerlink" title="精准搜索"></a>精准搜索</h2><p><code>command + N</code> ：搜索类</p>
<p><code>shift + command + N</code> ：搜索文件</p>
<p><code>ctrl + shift + ccommand + N</code> ：搜索符号（匹配方法名或者字段名）</p>
<p><code>ctrl + shift + f</code>：可以搜索项目下、模块下或者指定目录下的字符串</p>
<p><code>command+ shift+ +/-</code>：折叠代码</p>
<h2 id="live-template"><a href="#live-template" class="headerlink" title="live template"></a>live template</h2><p><code>psvm</code> : 生成main方法</p>
<p><code>iter</code> : 迭代</p>
<p><code>psf</code> ：public static final</p>
<p><code>psfi</code> : public static final Integer $var1$ = $var2$;</p>
<p><code>psfs</code> : public static final String $var1$ = “$var2$”;</p>
<p><code>ps</code> : private String $var1$ = “$var2$”;</p>
<p><code>psc</code> ：带注释版</p>
<p><code>pi</code> : private Integer $var1$ = $var2$;</p>
<p><code>pic</code> ：带注释版</p>
<p><code>st</code> : String</p>
<p><code>tna</code> ：throw new AppException(“$var1$”);</p>
<h2 id="postfix"><a href="#postfix" class="headerlink" title="postfix"></a>postfix</h2><p><code>.fori</code></p>
<p><code>.iter</code></p>
<p><code>.nn</code></p>
<p><code>.if</code></p>
<p><code>.sout</code></p>
<p><code>.return</code></p>
<p><code>.not</code></p>
<p><code>.null</code></p>
<p><code>alt + enter</code>：神器，不同的位置有不同的功能。</p>
<h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><p><code>shift + F6</code>：重命名</p>
<p><code>command+ F6</code>：方法重构</p>
<h2 id="抽取"><a href="#抽取" class="headerlink" title="抽取"></a>抽取</h2><p><code>alt + command + v</code>：补全代码；抽取为方法变量；</p>
<p><code>alt + command + C</code>：抽取为静态成员变量；</p>
<p><code>alt + command + F</code>：抽取为成员变量</p>
<p><code>alt + command+ P</code>：抽取成方法参数</p>
<p><code>alt + command+ M</code>：抽取成一个方法；</p>
<h2 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h2><p><code>command + Z</code>：撤销</p>
<p><code>shift +command  + Z</code>：还原</p>
<p><code>alt +command + L</code>：格式化代码</p>
<p><code>alt +command + O</code>：优化导包</p>
<p><code>command + F</code>：查找文本</p>
<p><code>command+ R</code>：替换文本</p>
<p><code>alt + /</code>：代码提示</p>
<p><code>command+ X</code>：剪切行</p>
<p><code>command+ Y</code>：删除行</p>
<p><code>command+ D</code>：复制行</p>
<p><code>command+ /</code>：单行注释</p>
<p><code>shift +command + /</code> ：多行注释</p>
<p><code>shift +command + up/down</code>：选中的代码上下移动</p>
<p><code>command+ F4</code>：关闭当前标签页</p>
<p><code>shift +command + t</code>：为一个类创建测试用例</p>
<p><code>shift +command + U</code>：大小写转换</p>
<p><code>SHIFT + ALT + U</code>: 驼峰，下划线，中杆格式转化</p>
<p><code>command + alt + T</code>：使用语句块(try catch, if esle…)包围代码</p>
<p><code>ctrl + N</code> ：智能插入</p>
<p><code>ctrl + command + G</code> ： 列操作</p>
<p><code>alt + -&gt;</code> : 光标移动到单词结尾</p>
<p><code>shift + alt + -&gt;</code> : 选中到单词结尾</p>
<p><code>command + -&gt;</code> : 光标移动到行尾</p>
<p><code>shift + command + -&gt;</code> : 选中到行尾</p>
<p><code>command + .</code> : 折叠代码</p>
<h2 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h2><p><code>command+ F8</code>：添加断点</p>
<p><code>shift + F9</code>：debug运行</p>
<p><code>shift + F10</code>：run运行</p>
<p><code>ctrl + alt + R</code>：jrebel的debug运行</p>
<p><code>F7</code>：进入方法</p>
<p><code>F8</code>：单步</p>
<p><code>F9</code>：Resume（跳到下一个断点）</p>
<p><code>shift +command + F8</code>：查看所有断点。在断点位置，测试设置断点的条件</p>
<p><code>alt + F8</code>：表达式求值</p>
<p><code>alt + F9</code>：运行到光标处</p>
<p>在debug时，选中变量按<code>F2 :</code>为该变量设值。</p>
<ol start="9">
<li>结构图</li>
</ol>
<p><code>command + F12</code>：查看结构（如类的方法和成员变量）</p>
<p><code>alt + shift + command + U</code>：显示结构图（maven的依赖图 或者是  类图）</p>
<p><code>ctrl + H</code>：显示类的层级关系。</p>
<p><code>ctrl +alt + H</code>：显示方法的调用关系</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>F5</code>：复制文件到当前目录</p>
<p><code>F6</code>：移动文件到指定目录</p>
<p><code>command + c</code> ： 复制文件名</p>
<p><code>shift + comand + c</code> ： 复制文件完整路径名</p>
<p><code>alt + shift + comand + c</code> ：复制类的引用路径</p>
<p><code>command + ,</code>  :  打开设置</p>
<p><code>command + ;</code> : 打开项目设置</p>
]]></content>
      <categories>
        <category>tool</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
</search>
